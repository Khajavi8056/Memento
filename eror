//+------------------------------------------------------------------+
//|                                     StrategyEA_Rewritten.mq5 |
//|                        Copyright 2025, Grok & Gemini Alliance |
//|                                                 https://x.ai |
//+------------------------------------------------------------------+
#property copyright "Rewritten by Gemini for Mohammad"
#property link      "https://google.com"
#property version   "2.00"
#property strict
#property description "A fully rewritten, cleaner, and more robust version of the EMA Crossover EA."

// --- Include the Standard Library for Trading ---
// This is essential for using the CTrade class, which simplifies trade operations.
#include <Trade\Trade.mqh>

// --- Input Parameters ---
// All user-configurable settings are here.
input group "Strategy Parameters"
input int    EMA_Fast_Period = 21;      // Fast EMA Period
input int    EMA_Slow_Period = 50;      // Slow EMA Period

input group "Trend & Momentum Filters"
input int    ADX_Period = 14;           // ADX Period
input double ADX_Threshold = 25.0;      // ADX value to confirm a trend
input int    RSI_Period = 14;           // RSI Period
input double RSI_Threshold = 50.0;      // RSI level for buy/sell bias

input group "Risk & Position Management"
input double Risk_Percent = 1.5;        // Risk per trade as a percentage of equity
input double ATR_Multiplier_SL = 2.5;   // Multiplier for ATR to set Stop Loss
input double RR_Breakeven = 1.0;        // Profit/Risk ratio to move SL to Breakeven (e.g., 1.0 means at 1R profit)
input double ATR_Multiplier_Trail = 2.5;// Multiplier for ATR for the trailing stop distance
input ulong  Slippage = 10;             // Allowed slippage in points

// --- Global Variables ---
// Handles for our indicators
int h_ema_fast, h_ema_slow, h_adx, h_rsi, h_atr;

// Trade object for executing orders
CTrade trade;

// To check for new bars
datetime g_last_bar_time = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//| Runs once when the EA is first loaded.                           |
//+------------------------------------------------------------------+
int OnInit()
{
   // --- Setup Indicator Handles ---
   h_ema_fast = iMA(_Symbol, PERIOD_H4, EMA_Fast_Period, 0, MODE_EMA, PRICE_CLOSE);
   h_ema_slow = iMA(_Symbol, PERIOD_H4, EMA_Slow_Period, 0, MODE_EMA, PRICE_CLOSE);
   h_adx      = iADX(_Symbol, PERIOD_H4, ADX_Period);
   h_rsi      = iRSI(_Symbol, PERIOD_H4, RSI_Period, PRICE_CLOSE);
   h_atr      = iATR(_Symbol, PERIOD_H4, ATR_Period);

   // --- Validate Handles ---
   // If any handle is invalid, the EA cannot work.
   if(h_ema_fast == INVALID_HANDLE || h_ema_slow == INVALID_HANDLE || h_adx == INVALID_HANDLE || h_rsi == INVALID_HANDLE || h_atr == INVALID_HANDLE)
   {
      Print("Error: Failed to create one or more indicator handles. EA will not run.");
      return(INIT_FAILED);
   }
   
   // --- Configure the Trade Object ---
   trade.SetDeviationInPoints(Slippage);
   trade.SetTypeFillingBySymbol(_Symbol); // Automatically set order filling type
   
   Print("EA Initialized Successfully. Let's make some money!");
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//| Runs when the EA is removed from the chart.                      |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // --- Clean up ---
   // It's good practice to release indicator handles.
   IndicatorRelease(h_ema_fast);
   IndicatorRelease(h_ema_slow);
   IndicatorRelease(h_adx);
   IndicatorRelease(h_rsi);
   IndicatorRelease(h_atr);
   
   Print("EA Deinitialized. Reason: ", reason);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//| Runs on every incoming tick.                                     |
//+------------------------------------------------------------------+
void OnTick()
{
   // --- Manage Open Positions ---
   // Trailing stop should be checked on every tick to react quickly.
   ManageTrailingStop();

   // --- Check for Trading Signals on a New Bar ---
   // We only want to check for new trade signals once per bar to avoid over-trading.
   if(IsNewBar())
   {
      CheckForTradeSignals();
   }
}

//+------------------------------------------------------------------+
//| Checks if a new H4 bar has formed.                               |
//+------------------------------------------------------------------+
bool IsNewBar()
{
   datetime current_bar_time = (datetime)SeriesInfoInteger(_Symbol, PERIOD_H4, SERIES_LASTBAR_DATE);
   
   if(g_last_bar_time < current_bar_time)
   {
      g_last_bar_time = current_bar_time;
      return true;
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Main logic function to check for entry signals.                  |
//+------------------------------------------------------------------+
void CheckForTradeSignals()
{
   // --- Get Indicator Values ---
   // We need values from the most recently closed bar (index 1) and the one before it (index 2).
   double ema_fast[2], ema_slow[2], adx[1], rsi[1], atr[1];

   if(CopyBuffer(h_ema_fast, 0, 1, 2, ema_fast) < 2 ||
      CopyBuffer(h_ema_slow, 0, 1, 2, ema_slow) < 2 ||
      CopyBuffer(h_adx, 0, 1, 1, adx) < 1 ||
      CopyBuffer(h_rsi, 0, 1, 1, rsi) < 1 ||
      CopyBuffer(h_atr, 0, 1, 1, atr) < 1)
   {
      Print("Error: Could not get indicator data.");
      return;
   }
   
   // Assign values to meaningful variables
   double ema_fast_now = ema_fast[0];   // Bar at index 1
   double ema_slow_now = ema_slow[0];
   double ema_fast_prev = ema_fast[1];  // Bar at index 2
   double ema_slow_prev = ema_slow[1];
   double adx_now = adx[0];
   double rsi_now = rsi[0];
   double atr_now = atr[0];
   
   // --- Define Entry Conditions ---
   bool is_trending = adx_now > ADX_Threshold;
   bool bullish_cross = ema_fast_now > ema_slow_now && ema_fast_prev <= ema_slow_prev;
   bool bearish_cross = ema_fast_now < ema_slow_now && ema_fast_prev >= ema_slow_prev;
   
   bool buy_signal = is_trending && bullish_cross && rsi_now > RSI_Threshold;
   bool sell_signal = is_trending && bearish_cross && rsi_now < RSI_Threshold;

   // --- Execute Trades ---
   if(PositionSelect(_Symbol)) // If a position already exists
   {
      long pos_type = PositionGetInteger(POSITION_TYPE);
      
      // If we get a buy signal and we are in a sell, close the sell and open a buy.
      if(buy_signal && pos_type == POSITION_TYPE_SELL)
      {
         ClosePosition();
         OpenPosition(ORDER_TYPE_BUY, atr_now);
      }
      // If we get a sell signal and we are in a buy, close the buy and open a sell.
      else if(sell_signal && pos_type == POSITION_TYPE_BUY)
      {
         ClosePosition();
         OpenPosition(ORDER_TYPE_SELL, atr_now);
      }
   }
   else // No position exists, open a new one on signal
   {
      if(buy_signal)
      {
         OpenPosition(ORDER_TYPE_BUY, atr_now);
      }
      else if(sell_signal)
      {
         OpenPosition(ORDER_TYPE_SELL, atr_now);
      }
   }
}

//+------------------------------------------------------------------+
//| Opens a new position (Buy or Sell).                              |
//+------------------------------------------------------------------+
void OpenPosition(ENUM_ORDER_TYPE type, double atr_value)
{
   // Calculate Stop Loss distance in points
   double sl_distance_points = atr_value * ATR_Multiplier_SL;
   
   // Calculate Lot Size based on risk
   double lot_size = CalculateLotSize(sl_distance_points);
   if(lot_size <= 0)
   {
      Print("Error: Calculated lot size is zero or negative. Cannot open position.");
      return;
   }
   
   // Determine entry and SL prices
   double entry_price = (type == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double sl_price = (type == ORDER_TYPE_BUY) ? entry_price - sl_distance_points : entry_price + sl_distance_points;
   
   // TP is 0 because we exit on opposite signal or trailing stop
   double tp_price = 0.0;
   
   // Send the order
   string comment = (type == ORDER_TYPE_BUY) ? "Gemini Buy" : "Gemini Sell";
   if(!trade.PositionOpen(_Symbol, type, lot_size, entry_price, sl_price, tp_price, comment))
   {
      Print("Error opening position: ", GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Closes the current open position for the symbol.                 |
//+------------------------------------------------------------------+
void ClosePosition()
{
   if(!trade.PositionClose(_Symbol))
   {
      Print("Error closing position: ", GetLastError());
   }
}

//+------------------------------------------------------------------+
//| Manages trailing stop and breakeven for the open position.       |
//+------------------------------------------------------------------+
void ManageTrailingStop()
{
   if(!PositionSelect(_Symbol)) return; // No position, nothing to do

   // Get current position details
   long pos_type = PositionGetInteger(POSITION_TYPE);
   double entry_price = PositionGetDouble(POSITION_PRICE_OPEN);
   double current_sl = PositionGetDouble(POSITION_SL);
   
   // --- Calculate the initial risk distance (1R) ---
   // This is fixed at the time of entry and does not change.
   double initial_risk_dist = (pos_type == POSITION_TYPE_BUY) ? entry_price - current_sl : current_sl - entry_price;
   if(initial_risk_dist <= 0) return; // Invalid SL, cannot manage

   // Get current ATR for trailing stop calculation
   double atr_now[1];
   if(CopyBuffer(h_atr, 0, 0, 1, atr_now) < 1) return;
   double trail_distance = atr_now[0] * ATR_Multiplier_Trail;

   // Determine new SL based on position type
   double new_sl = current_sl;
   if(pos_type == POSITION_TYPE_BUY)
   {
      double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double profit_dist = current_price - entry_price;
      
      // 1. Breakeven: If profit is >= 1R and SL is below entry, move SL to entry.
      if(profit_dist >= (RR_Breakeven * initial_risk_dist) && current_sl < entry_price)
      {
         new_sl = entry_price;
      }
      
      // 2. Trailing: Calculate potential new trailing SL.
      double potential_trail_sl = current_price - trail_distance;
      // If the potential SL is higher than the current (or breakeven) SL, update it.
      if(potential_trail_sl > new_sl)
      {
         new_sl = potential_trail_sl;
      }
   }
   else // POSITION_TYPE_SELL
   {
      double current_price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double profit_dist = entry_price - current_price;
      
      // 1. Breakeven
      if(profit_dist >= (RR_Breakeven * initial_risk_dist) && current_sl > entry_price)
      {
         new_sl = entry_price;
      }
      
      // 2. Trailing
      double potential_trail_sl = current_price + trail_distance;
      if(potential_trail_sl < new_sl)
      {
         new_sl = potential_trail_sl;
      }
   }
   
   // --- Modify the Position if SL has changed ---
   if(new_sl != current_sl)
   {
      if(!trade.PositionModify(_Symbol, NormalizeDouble(new_sl, _Digits), PositionGetDouble(POSITION_TP)))
      {
         Print("Error modifying SL: ", GetLastError());
      }
   }
}

//+------------------------------------------------------------------+
//| Calculates lot size based on risk percentage and SL distance.    |
//+------------------------------------------------------------------+
double CalculateLotSize(double sl_distance_in_points)
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double risk_amount = equity * (Risk_Percent / 100.0);
   
   // Get symbol properties
   double tick_value = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tick_size = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   if(tick_size == 0 || tick_value == 0) return 0.0; // Avoid division by zero
   
   // Calculate how much is risked per lot with the given SL distance
   double risk_per_lot = (sl_distance_in_points / tick_size) * tick_value;
   if(risk_per_lot == 0) return 0.0;
   
   double lot_size = risk_amount / risk_per_lot;
   
   // Normalize the lot size according to symbol's rules
   double min_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double max_lot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lot_size = lot_step * MathRound(lot_size / lot_step);
   
   // Clamp the lot size between min and max allowed values
   lot_size = MathMax(min_lot, MathMin(max_lot, lot_size));
   
   return lot_size;
}
