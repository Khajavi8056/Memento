//+------------------------------------------------------------------+
//| باز کردن معامله (با مدیریت سرمایه اصلاح شده و دقیق)                |
//+------------------------------------------------------------------+
void CStrategyManager::OpenTrade(bool is_buy)
{
    // اگر تعداد معاملات باز به حد مجاز رسیده باشد، از تابع خارج می‌شویم
    if(CountTotalTrades() >= m_settings.max_total_trades || CountSymbolTrades() >= m_settings.max_trades_per_symbol)
    {
        Log("رسیدن به حد مجاز معاملات. معامله جدید باز نشد.");
        return;
    }

    // گرفتن قیمت ورود
    double entry_price = is_buy ? SymbolInfoDouble(m_symbol, SYMBOL_ASK) : SymbolInfoDouble(m_symbol, SYMBOL_BID);
    
    // ✅✅✅ اصلاحیه اصلی: فراخوانی تابع CalculateStopLoss با تایم‌فریم انتخابی ✅✅✅
    double sl = CalculateStopLoss(is_buy, entry_price, m_settings.sl_timeframe);

    // اگر محاسبه استاپ لاس با خطا مواجه شد، معامله باز نمی‌شود
    if(sl == 0)
    {
        Log("خطا در محاسبه استاپ لاس. معامله باز نشد.");
        return;
    }
    
    // --- گام ۱: محاسبه ریسک به ازای هر معامله به پول حساب ---
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double risk_amount = balance * (m_settings.risk_percent_per_trade / 100.0);

    // --- گام ۲: محاسبه میزان ضرر برای ۱ لات معامله با این استاپ لاس ---
    double loss_for_one_lot = 0;
    // از تابع تخصصی متاتریدر برای این کار استفاده می‌کنیم
    if(!OrderCalcProfit(is_buy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL, m_symbol, 1.0, entry_price, sl, loss_for_one_lot))
    {
        Log("خطا در محاسبه سود/زیان با OrderCalcProfit. کد خطا: " + (string)GetLastError());
        return;
    }
    loss_for_one_lot = MathAbs(loss_for_one_lot);

    if(loss_for_one_lot <= 0)
    {
        Log("میزان ضرر محاسبه شده برای ۱ لات معتبر نیست. معامله باز نشد.");
        return;
    }

    // --- گام ۳: محاسبه حجم دقیق لات بر اساس ریسک و میزان ضرر ۱ لات ---
    double lot_size = NormalizeDouble(risk_amount / loss_for_one_lot, 2);

    // --- گام ۴: نرمال‌سازی و گرد کردن لات بر اساس محدودیت‌های بروکر ---
    double min_lot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MIN);
    double max_lot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MAX);
    double lot_step = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_STEP);
    
    // اطمینان از اینکه لات در محدوده مجاز است
    lot_size = MathMax(min_lot, MathMin(max_lot, lot_size));
    
    // گرد کردن لات بر اساس گام مجاز بروکر
    lot_size = MathRound(lot_size / lot_step) * lot_step;

    if(lot_size < min_lot)
    {
        Log("حجم محاسبه شده (" + DoubleToString(lot_size,2) + ") کمتر از حداقل لات مجاز (" + DoubleToString(min_lot,2) + ") است. معامله باز نشد.");
        return;
    }

    // --- گام ۵: محاسبه حد سود و ارسال معامله ---
    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT);
    double sl_distance_points = MathAbs(entry_price - sl) / point;
    double tp_distance_points = sl_distance_points * m_settings.take_profit_ratio;
    double tp = is_buy ? entry_price + tp_distance_points * point : entry_price - tp_distance_points * point;
    
    int digits = (int)SymbolInfoInteger(m_symbol, SYMBOL_DIGITS);
    sl = NormalizeDouble(sl, digits);
    tp = NormalizeDouble(tp, digits);
    
    string comment = "Memento " + (is_buy ? "Buy" : "Sell");
    
    if(is_buy)
    {
        m_trade.Buy(lot_size, m_symbol, 0, sl, tp, comment);
    }
    else
    {
        m_trade.Sell(lot_size, m_symbol, 0, sl, tp, comment);
    }
    
    // لاگ کردن نتیجه
    if(m_trade.ResultRetcode() == TRADE_RETCODE_DONE)
    {
        Log("معامله " + comment + " با لات " + DoubleToString(lot_size, 2) + " با موفقیت باز شد.");
    }
    else
    {
        Log("خطا در باز کردن معامله " + comment + ": " + (string)m_trade.ResultRetcode() + " - " + m_trade.ResultComment());
    }
}
//+------------------------------------------------------------------+
//| (نسخه نهایی با منطق انتخاب بهینه - کاملاً سازگار) محاسبه استاپ لاس |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateStopLoss(bool is_buy, double entry_price, ENUM_TIMEFRAMES timeframe)
{
    // اگر کاربر روش ساده یا ATR را انتخاب کرده بود، همان را اجرا کن (بدون تغییر)
    if (m_settings.stoploss_type == MODE_SIMPLE)
    {
        double buffer = m_settings.sl_buffer_multiplier * SymbolInfoDouble(m_symbol, SYMBOL_POINT);
        // ✅✅✅ اصلاحیه: پاس دادن تایم‌فریم به تابع کمکی ✅✅✅
        return FindBackupStopLoss(is_buy, buffer, timeframe);
    }
    if (m_settings.stoploss_type == MODE_ATR)
    {
        // ✅✅✅ اصلاحیه: پاس دادن تایم‌فریم به تابع کمکی ✅✅✅
        double sl_price = CalculateAtrStopLoss(is_buy, entry_price, timeframe);
        if (sl_price == 0) // اگر ATR به هر دلیلی جواب نداد
        {
            Log("محاسبه ATR SL با خطا مواجه شد. استفاده از روش پشتیبان...");
            double buffer = m_settings.sl_buffer_multiplier * SymbolInfoDouble(m_symbol, SYMBOL_POINT);
            // ✅✅✅ اصلاحیه: پاس دادن تایم‌فریم به تابع کمکی ✅✅✅
            return FindBackupStopLoss(is_buy, buffer, timeframe);
        }
        return sl_price;
    }

    // --- قلب تپنده منطق جدید: انتخاب بهینه (برای MODE_COMPLEX) ---

    Log("شروع فرآیند انتخاب استاپ لاس بهینه...");

    // --- مرحله ۱: تشکیل لیست کاندیداها ---
    double candidates[];
    int count = 0;
    double sl_candidate = 0; // متغیر کمکی برای نگهداری نتیجه هر تابع
    double buffer = m_settings.sl_buffer_multiplier * SymbolInfoDouble(m_symbol, SYMBOL_POINT);
    
    // کاندیدای ۱: کیجون فلت
    // ✅✅✅ اصلاحیه: پاس دادن تایم‌فریم به تابع کمکی ✅✅✅
    sl_candidate = FindFlatKijun(timeframe);
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1);
        candidates[count] = is_buy ? sl_candidate - buffer : sl_candidate + buffer;
        count++;
    }
    
    // کاندیدای ۲: پیوت کیجون
    // ✅✅✅ اصلاحیه: پاس دادن تایم‌فریم به تابع کمکی ✅✅✅
    sl_candidate = FindPivotKijun(is_buy, timeframe);
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1);
        candidates[count] = is_buy ? sl_candidate - buffer : sl_candidate + buffer;
        count++;
    }

    // کاندیدای ۳: پیوت تنکان
    // ✅✅✅ اصلاحیه: پاس دادن تایم‌فریم به تابع کمکی ✅✅✅
    sl_candidate = FindPivotTenkan(is_buy, timeframe);
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1);
        candidates[count] = is_buy ? sl_candidate - buffer : sl_candidate + buffer;
        count++;
    }

    // کاندیدای ۴: روش ساده (کندل مخالف)
    // ✅✅✅ اصلاحیه: پاس دادن تایم‌فریم به تابع کمکی ✅✅✅
    sl_candidate = FindBackupStopLoss(is_buy, buffer, timeframe);
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1);
        candidates[count] = sl_candidate;
        count++;
    }
    
    // کاندیدای ۵: روش ATR
    // ✅✅✅ اصلاحیه: پاس دادن تایم‌فریم به تابع کمکی ✅✅✅
    sl_candidate = CalculateAtrStopLoss(is_buy, entry_price, timeframe);
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1);
        candidates[count] = sl_candidate;
        count++;
    }

    if (count == 0)
    {
        Log("خطا: هیچ کاندیدای اولیه‌ای برای استاپ لاس پیدا نشد.");
        return 0.0;
    }

    // --- مرحله ۲: اعتبارسنجی و بهینه‌سازی کاندیداها ---
    double valid_candidates[];
    int valid_count = 0;
    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT);
    double spread = (double)SymbolInfoInteger(m_symbol, SYMBOL_SPREAD) * point;
    double min_safe_distance = spread + buffer; 

    for (int i = 0; i < count; i++)
    {
        double current_sl = candidates[i];
        
        if ((is_buy && current_sl >= entry_price) || (!is_buy && current_sl <= entry_price))
        {
            continue; 
        }

        if (MathAbs(entry_price - current_sl) < min_safe_distance)
        {
            current_sl = is_buy ? entry_price - min_safe_distance : entry_price + min_safe_distance;
            Log("کاندیدای شماره " + (string)(i+1) + " به دلیل نزدیکی بیش از حد به قیمت " + DoubleToString(current_sl, _Digits) + " اصلاح شد.");
        }

        ArrayResize(valid_candidates, valid_count + 1);
        valid_candidates[valid_count] = current_sl;
        valid_count++;
    }

    if (valid_count == 0)
    {
        Log("خطا: پس از فیلترینگ، هیچ کاندیدای معتبری برای استاپ لاس باقی نماند.");
        return 0.0;
    }
    
    // --- مرحله ۳: انتخاب نزدیک‌ترین گزینه معتبر ---
    double best_sl_price = 0.0;
    double smallest_distance = DBL_MAX;

    for (int i = 0; i < valid_count; i++)
    {
        double distance = MathAbs(entry_price - valid_candidates[i]);
        if (distance < smallest_distance)
        {
            smallest_distance = distance;
            best_sl_price = valid_candidates[i];
        }
    }

    Log("✅ استاپ لاس بهینه پیدا شد: " + DoubleToString(best_sl_price, _Digits) + ". فاصله: " + DoubleToString(smallest_distance / point, 1) + " پوینت.");

    return best_sl_price;
}


//+------------------------------------------------------------------+
//| تابع استاپ لاس پشتیبان (بازنویسی کامل بر اساس منطق رنگ مخالف)   |
//+------------------------------------------------------------------+
double CStrategyManager::FindBackupStopLoss(bool is_buy, double buffer, ENUM_TIMEFRAMES timeframe) // ✅✅✅ تغییر در امضا ✅✅✅
{
    // تعداد کندلی که می‌خواهیم در گذشته برای پیدا کردن استاپ لاس جستجو کنیم.
    int bars_to_check = m_settings.sl_lookback_period;
    
    // اگر تعداد کندل‌های موجود در چارت کافی نیست، از تابع خارج می‌شویم.
    if (iBars(m_symbol, timeframe) < bars_to_check + 1) return 0; // ✅✅✅ استفاده از تایم‌فریم جدید ✅✅✅
    
    // یک حلقه 'for' می‌سازیم که از کندل شماره ۱ (کندل قبلی) شروع به حرکت به عقب می‌کند.
    for (int i = 1; i <= bars_to_check; i++)
    {
        // رنگ کندلی که در حال بررسی آن هستیم را مشخص می‌کنیم.
        bool is_candle_bullish = (iClose(m_symbol, timeframe, i) > iOpen(m_symbol, timeframe, i)); // ✅✅✅ استفاده از تایم‌فریم جدید ✅✅✅
        bool is_candle_bearish = (iClose(m_symbol, timeframe, i) < iOpen(m_symbol, timeframe, i)); // ✅✅✅ استفاده از تایم‌فریم جدید ✅✅✅

        // اگر معامله ما از نوع "خرید" (Buy) باشد...
        if (is_buy)
        {
            // ...پس ما به دنبال اولین کندل با رنگ مخالف، یعنی کندل "نزولی" (Bearish) هستیم.
            if (is_candle_bearish)
            {
                // به محض پیدا کردن اولین کندل نزولی، استاپ لاس را چند پوینت زیر کفِ (Low) همان کندل قرار می‌دهیم.
                double sl_price = iLow(m_symbol, timeframe, i) - buffer; // ✅✅✅ استفاده از تایم‌فریم جدید ✅✅✅
                Log("استاپ لاس ساده: اولین کندل نزولی در شیفت " + (string)i + " پیدا شد.");
                
                // قیمت محاسبه شده را برمی‌گردانیم و کار تابع تمام می‌شود.
                return sl_price;
            }
        }
        // اگر معامله ما از نوع "فروش" (Sell) باشد...
        else // is_sell
        {
            // ...پس ما به دنبال اولین کندل با رنگ مخالف، یعنی کندل "صعودی" (Bullish) هستیم.
            if (is_candle_bullish)
            {
                // به محض پیدا کردن اولین کندل صعودی، استاپ لاس را چند پوینت بالای سقفِ (High) همان کندل قرار می‌دهیم.
                double sl_price = iHigh(m_symbol, timeframe, i) + buffer; // ✅✅✅ استفاده از تایم‌فریم جدید ✅✅✅
                Log("استاپ لاس ساده: اولین کندل صعودی در شیفت " + (string)i + " پیدا شد.");
                
                // قیمت محاسبه شده را برمی‌گردانیم و کار تابع تمام می‌شود.
                return sl_price;
            }
        }
    }
    
    // --- بخش پشتیبانِ پشتیبان ---
    // اگر حلقه 'for' تمام شود و کد به اینجا برسد، یعنی در کل بازه مورد بررسی، هیچ کندل رنگ مخالفی پیدا نشده است.
    Log("هیچ کندل رنگ مخالفی برای استاپ لاس ساده پیدا نشد. از روش سقف/کف مطلق استفاده می‌شود.");
    
    // داده‌های سقف و کف کندل‌ها را در آرایه‌ها کپی می‌کنیم.
    CopyHigh(m_symbol, timeframe, 1, bars_to_check, m_high_buffer); // ✅✅✅ استفاده از تایم‌فریم جدید ✅✅✅
    CopyLow(m_symbol, timeframe, 1, bars_to_check, m_low_buffer); // ✅✅✅ استفاده از تایم‌فریم جدید ✅✅✅

    if(is_buy)
    {
       // برای خرید، ایندکس پایین‌ترین کندل را پیدا کرده و قیمت Low آن را برمی‌گردانیم.
       int min_index = ArrayMinimum(m_low_buffer, 0, bars_to_check);
       return m_low_buffer[min_index] - buffer;
    }
    else
    {
       // برای فروش، ایندکس بالاترین کندل را پیدا کرده و قیمت High آن را برمی‌گردانیم.
       int max_index = ArrayMaximum(m_high_buffer, 0, bars_to_check);
       return m_high_buffer[max_index] + buffer;
    }
}


//+------------------------------------------------------------------+
//| (نسخه نهایی و ضد ضربه) محاسبه حد ضرر ATR                          |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateAtrStopLoss(bool is_buy, double entry_price, ENUM_TIMEFRAMES timeframe) // ✅✅✅ تغییر در امضا ✅✅✅
{
    // اگر حالت پویای SL (رژیم نوسان) غیرفعال باشد، از منطق ساده قبلی استفاده کن
    if (!m_settings.enable_sl_vol_regime)
    {
        // هندل ATR قبلا با تایم‌فریم فیلتر مقداردهی شده، پس باید یک هندل جدید برای تایم‌فریم SL بسازیم
        int atr_sl_handle = iATR(m_symbol, timeframe, m_settings.atr_filter_period); // ✅✅✅ استفاده از تایم‌فریم جدید ✅✅✅
        if (atr_sl_handle == INVALID_HANDLE)
        {
            Log("خطای بحرانی در CalculateAtrStopLoss: هندل ATR نامعتبر است!");
            return 0.0;
        }
        
        double atr_buffer[];
        if(CopyBuffer(atr_sl_handle, 0, 1, 1, atr_buffer) < 1)
        {
            Log("داده ATR برای محاسبه حد ضرر ساده موجود نیست.");
            IndicatorRelease(atr_sl_handle);
            return 0.0;
        }
        IndicatorRelease(atr_sl_handle); // هندل را آزاد می‌کنیم
        
        double atr_value = atr_buffer[0];
        return is_buy ? entry_price - (atr_value * m_settings.sl_atr_multiplier) : entry_price + (atr_value * m_settings.sl_atr_multiplier);
    }

    // --- منطق جدید: SL پویا بر اساس رژیم نوسان ---
    int history_size = m_settings.sl_vol_regime_ema_period + 5;
    double atr_values[], ema_values[];

    // ✅✅✅ اصلاحیه: هندل ATR را با تایم‌فریم جدید می‌سازیم ✅✅✅
    int atr_sl_handle = iATR(m_symbol, timeframe, m_settings.sl_vol_regime_atr_period); 
    if (atr_sl_handle == INVALID_HANDLE || CopyBuffer(atr_sl_handle, 0, 0, history_size, atr_values) < history_size)
    {
        Log("داده کافی برای محاسبه SL پویا موجود نیست.");
        if(atr_sl_handle != INVALID_HANDLE) 
            IndicatorRelease(atr_sl_handle);
        return 0.0;
    }
    
    IndicatorRelease(atr_sl_handle);
    ArraySetAsSeries(atr_values, true); 

    if(SimpleMAOnBuffer(history_size, 0, m_settings.sl_vol_regime_ema_period, MODE_EMA, atr_values, ema_values) < 1)
    {
         Log("خطا در محاسبه EMA روی ATR.");
         return 0.0;
    }

    double current_atr = atr_values[1]; 
    double ema_atr = ema_values[1];     

    bool is_high_volatility = (current_atr > ema_atr);
    double final_multiplier = is_high_volatility ? m_settings.sl_high_vol_multiplier : m_settings.sl_low_vol_multiplier;

    Log("رژیم نوسان: " + (is_high_volatility ? "بالا" : "پایین") + ". ضریب SL نهایی: " + (string)final_multiplier);

    return is_buy ? entry_price - (current_atr * final_multiplier) : entry_price + (current_atr * final_multiplier);
}


//+------------------------------------------------------------------+
//| پیدا کردن سطح کیجون سن فلت (صاف)                                  |
//+------------------------------------------------------------------+
double CStrategyManager::FindFlatKijun(ENUM_TIMEFRAMES timeframe) // ✅✅✅ تغییر در امضا ✅✅✅
{
    double kijun_values[];
    // هندل ایچیموکو را با تایم‌فریم جدید می‌سازیم
    int ichi_handle = iIchimoku(m_symbol, timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period);
    if (ichi_handle == INVALID_HANDLE || CopyBuffer(ichi_handle, 1, 1, m_settings.flat_kijun_period, kijun_values) < m_settings.flat_kijun_period)
    {
        if(ichi_handle != INVALID_HANDLE) IndicatorRelease(ichi_handle);
        return 0.0;
    }
    IndicatorRelease(ichi_handle);
    
    ArraySetAsSeries(kijun_values, true);

    int flat_count = 1;
    for (int i = 1; i < m_settings.flat_kijun_period; i++)
    {
        if (kijun_values[i] == kijun_values[i - 1])
        {
            flat_count++;
            if (flat_count >= m_settings.flat_kijun_min_length)
            {
                return kijun_values[i];
            }
        }
        else
        {
            flat_count = 1;
        }
    }
    return 0.0;
}

//+------------------------------------------------------------------+
//| پیدا کردن پیوت (نقطه چرخش) روی کیجون سن                          |
//+------------------------------------------------------------------+
double CStrategyManager::FindPivotKijun(bool is_buy, ENUM_TIMEFRAMES timeframe) // ✅✅✅ تغییر در امضا ✅✅✅
{
    double kijun_values[];
    int ichi_handle = iIchimoku(m_symbol, timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period);
    if (ichi_handle == INVALID_HANDLE || CopyBuffer(ichi_handle, 1, 1, m_settings.pivot_lookback, kijun_values) < m_settings.pivot_lookback)
    {
        if(ichi_handle != INVALID_HANDLE) IndicatorRelease(ichi_handle);
        return 0.0;
    }
    IndicatorRelease(ichi_handle);

    ArraySetAsSeries(kijun_values, true);

    for (int i = 1; i < m_settings.pivot_lookback - 1; i++)
    {
        if (is_buy && kijun_values[i] < kijun_values[i - 1] && kijun_values[i] < kijun_values[i + 1])
        {
            return kijun_values[i];
        }
        if (!is_buy && kijun_values[i] > kijun_values[i - 1] && kijun_values[i] > kijun_values[i + 1])
        {
            return kijun_values[i];
        }
    }
    return 0.0;
}

//+------------------------------------------------------------------+
//| پیدا کردن پیوت (نقطه چرخش) روی تنکان سن                          |
//+------------------------------------------------------------------+
double CStrategyManager::FindPivotTenkan(bool is_buy, ENUM_TIMEFRAMES timeframe) // ✅✅✅ تغییر در امضا ✅✅✅
{
    double tenkan_values[];
    int ichi_handle = iIchimoku(m_symbol, timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period);
    if (ichi_handle == INVALID_HANDLE || CopyBuffer(ichi_handle, 0, 1, m_settings.pivot_lookback, tenkan_values) < m_settings.pivot_lookback)
    {
        if(ichi_handle != INVALID_HANDLE) IndicatorRelease(ichi_handle);
        return 0.0;
    }
    IndicatorRelease(ichi_handle);

    ArraySetAsSeries(tenkan_values, true);

    for (int i = 1; i < m_settings.pivot_lookback - 1; i++)
    {
        if (is_buy && tenkan_values[i] < tenkan_values[i - 1] && tenkan_values[i] < tenkan_values[i + 1])
        {
            return tenkan_values[i];
        }
        if (!is_buy && tenkan_values[i] > tenkan_values[i - 1] && tenkan_values[i] > tenkan_values[i + 1])
        {
            return tenkan_values[i];
        }
    }
    return 0.0;
}

//+------------------------------------------------------------------+
//| (نسخه نهایی و ضد ضربه) تابع کمکی برای بررسی فیلتر ابر کومو
//+------------------------------------------------------------------+
bool CStrategyManager::CheckKumoFilter(bool is_buy, ENUM_TIMEFRAMES timeframe) // ✅✅✅ تغییر در امضا ✅✅✅
{
    double senkou_a[], senkou_b[];
    int ichi_handle = iIchimoku(m_symbol, timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period);
    if(ichi_handle == INVALID_HANDLE || CopyBuffer(ichi_handle, 2, 0, 1, senkou_a) < 1 || CopyBuffer(ichi_handle, 3, 0, 1, senkou_b) < 1)
    {
       Log("خطا: داده کافی برای فیلتر کومو موجود نیست.");
       if(ichi_handle != INVALID_HANDLE) IndicatorRelease(ichi_handle);
       return false;
    }
    IndicatorRelease(ichi_handle);
    
    double high_kumo = MathMax(senkou_a[0], senkou_b[0]);
    double low_kumo = MathMin(senkou_a[0], senkou_b[0]);
    double close_price = iClose(m_symbol, timeframe, 1);
    
    if (is_buy) return (close_price > high_kumo);
    else return (close_price < low_kumo);
}

//+------------------------------------------------------------------+
//| (نسخه نهایی و ضد ضربه) تابع کمکی برای بررسی فیلتر ATR
//+------------------------------------------------------------------+
bool CStrategyManager::CheckAtrFilter(ENUM_TIMEFRAMES timeframe) // ✅✅✅ تغییر در امضا ✅✅✅
{
    int atr_handle = iATR(m_symbol, timeframe, m_settings.atr_filter_period);
    if (atr_handle == INVALID_HANDLE)
    {
        Log("فیلتر ATR رد شد چون هندل آن نامعتبر است.");
        return false;
    }
    
    double atr_value_buffer[];
    if(CopyBuffer(atr_handle, 0, 1, 1, atr_value_buffer) < 1)
    {
       Log("خطا: داده کافی برای فیلتر ATR موجود نیست.");
       IndicatorRelease(atr_handle);
       return false;
    }
    IndicatorRelease(atr_handle);
    
    double current_atr = atr_value_buffer[0];
    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT);
    double min_atr_threshold = m_settings.atr_filter_min_value_pips * point;
    
    if(_Digits == 3 || _Digits == 5)
    {
        min_atr_threshold *= 10;
    }

    return (current_atr >= min_atr_threshold);
}

//+------------------------------------------------------------------+
//| (جدید) تابع کمکی برای بررسی فیلتر قدرت و جهت روند ADX
//+------------------------------------------------------------------+
bool CStrategyManager::CheckAdxFilter(bool is_buy, ENUM_TIMEFRAMES timeframe) // ✅✅✅ تغییر در امضا ✅✅✅
{  
    double adx_buffer[1], di_plus_buffer[1], di_minus_buffer[1];  
    int adx_handle = iADX(m_symbol, timeframe, m_settings.adx_period);
    if (adx_handle == INVALID_HANDLE || CopyBuffer(adx_handle, 0, 1, 1, adx_buffer) < 1 || 
        CopyBuffer(adx_handle, 1, 1, 1, di_plus_buffer) < 1 || 
        CopyBuffer(adx_handle, 2, 1, 1, di_minus_buffer) < 1)
    {
        Log("داده کافی برای فیلتر ADX موجود نیست.");
        if(adx_handle != INVALID_HANDLE) IndicatorRelease(adx_handle);
        return false;
    }
    IndicatorRelease(adx_handle);
    
    if (adx_buffer[0] <= m_settings.adx_threshold) 
    {
        return false;
    }
    
    if (is_buy)
    {
        return (di_plus_buffer[0] > di_minus_buffer[0]);
    }
    else
    {
        return (di_minus_buffer[0] > di_plus_buffer[0]);
    }
}



