```mqh

// فایل 1 تنضیمات ::


//+------------------------------------------------------------------+
//|                                                      set.mqh     |
//|                 © 2025, Mohammad & Gemini                        |
//+------------------------------------------------------------------+
#property copyright "© 2025, hipoalgoritm" // حقوق کپی‌رایت پروژه
#property link      "https://www.mql5.com" // لینک مرتبط با پروژه
#property version   "3.1" // نسخه با پیاده‌سازی ارتقاءها

// --- انواع شمارشی برای خوانایی بهتر کد ---

enum E_Entry_Confirmation_Mode
{
    CONFIRM_CURRENT_TIMEFRAME, // روش فعلی: تاییدیه بر اساس کندل در تایم فریم اصلی
    CONFIRM_LOWER_TIMEFRAME    // روش جدید: تاییدیه بر اساس شکست ساختار (CHoCH) در تایم فریم پایین
};

enum E_Grace_Period_Mode
{
    GRACE_BY_CANDLES,          // انقضا بر اساس تعداد کندل (روش ساده)
    GRACE_BY_STRUCTURE         // انقضا بر اساس شکست ساختار قیمت (روش هوشمند)
};

enum E_Confirmation_Mode { MODE_CLOSE_ONLY, MODE_OPEN_AND_CLOSE }; // حالت‌های تایید کندل

enum E_SL_Mode
{
    MODE_COMPLEX,         // بهینه (انتخاب نزدیک‌ترین گزینه منطقی)
    MODE_SIMPLE,          // ساده (بر اساس رنگ مخالف کندل)
    MODE_ATR,             // پویا (مبتنی بر ATR)
    MODE_STRUCTURE        // [MODIFIED] ساختاری (بر اساس ساختار بازار)
};

enum E_Signal_Mode { MODE_REPLACE_SIGNAL, MODE_SIGNAL_CONTEST }; // حالت‌های مدیریت سیگنال

enum E_Talaqi_Mode
{
    TALAQI_MODE_MANUAL,     // دستی (بر اساس پوینت)
    TALAQI_MODE_KUMO,       // هوشمند (بر اساس ضخامت کومو)
    TALAQI_MODE_ATR,        // پویا (مبتنی بر ATR)
};

enum E_Filter_Timeframe_Context
{
    FILTER_CONTEXT_HTF, // فیلترها در تایم فریم اصلی (HTF)
    FILTER_CONTEXT_LTF  // فیلترها در تایم فریم تاییدیه (LTF)
};

enum E_Primary_Strategy_Mode
{
    STRATEGY_TRIPLE_CROSS,  // استراتژی فعلی: کراس سه‌گانه
    STRATEGY_KUMO_MTL       // استراتژی جدید: ابر، مومنتوم و نوسان (MKM)
};

// set.mqh
enum E_Entry_Tactic
{
    TACTIC_CONFIRMATION, // تاکتیک تایید (منتظر تشکیل سوینگ لو)
    TACTIC_PREDICTIVE    // تاکتیک پیش‌بینی (قراردادن لیمیت اردر)
};

//+------------------------------------------------------------------+
//|                      تنظیمات ورودی اکسپرت                         |
//+------------------------------------------------------------------+

// ---=== ⚙️ 1. تنظیمات عمومی (General) ⚙️ ===---
input group           "          ---=== ⚙️ 1. تنظیمات عمومی (General) ⚙️ ===---"; // گروه تنظیمات عمومی
input bool            Inp_Enable_Dashboard  = true;                   // ✅ فعال/غیرفعال کردن داشبورد اطلاعاتی
input string          Inp_Symbols_List      = "EURUSD,GBPUSD,XAUUSD"; // لیست نمادها (جدا شده با کاما)
input int             Inp_Magic_Number      = 12345;                  // شماره جادویی معاملات
input bool            Inp_Enable_Logging    = true;                   // فعال/غیرفعال کردن لاگ‌ها

// ---=== 📈 2. تنظیمات ایچیموکو (Ichimoku Baseline) 📈 ===---
input group           "      ---=== 📈 2. تنظیمات ایچیموکو (Ichimoku) 📈 ===---"; // گروه تنظیمات ایچیموکو
input ENUM_TIMEFRAMES Inp_Ichimoku_Timeframe = PERIOD_H1;                // تایم فریم اصلی برای تحلیل ایچیموکو
input int             Inp_Tenkan_Period     = 10;                     // دوره تنکان-سن (بهینه شده)
input int             Inp_Kijun_Period      = 28;                     // دوره کیجون-سن (بهینه شده)
input int             Inp_Senkou_Period     = 55;                     // دوره سنکو اسپن بی (بهینه شده)
input int             Inp_Chikou_Period     = 26;                     // دوره چیکو اسپن (نقطه مرجع)

// ---=== 🎯 3. سیگنال و تاییدیه (Signal & Confirmation) 🎯 ===---
input group           "---=== 🎯 3. سیگنال و تاییدیه (Signal & Confirmation) 🎯 ===---"; // گروه تنظیمات سیگنال و تاییدیه
input E_Primary_Strategy_Mode Inp_Primary_Strategy = STRATEGY_TRIPLE_CROSS; // استراتژی اصلی
input E_Signal_Mode   Inp_Signal_Mode         = MODE_SIGNAL_CONTEST;  // روش مدیریت سیگنال

input group           "         --- تاییدیه نهایی ورود (Final Confirmation) ---"; // زیرگروه تاییدیه ورود
input E_Entry_Confirmation_Mode Inp_Entry_Confirmation_Mode = CONFIRM_CURRENT_TIMEFRAME; // نوع تاییدیه ورود

input E_Entry_Tactic          Inp_Entry_Tactic = TACTIC_CONFIRMATION; // <<<< ✅ این خط جدیده

input group           "         --- مهلت سیگنال در حالت انتظار (Grace Period) ---"; // زیرگروه مهلت سیگنال
input E_Grace_Period_Mode Inp_Grace_Period_Mode = GRACE_BY_CANDLES;   // نوع انقضای سیگنال
input int             Inp_Grace_Period_Candles= 4;                      // [حالت کندلی] تعداد کندل مهلت برای تاییدیه

input group           "         --- تنظیمات تاییدیه تایم فریم پایین (LTF) ---"; // زیرگروه تاییدیه LTF
input ENUM_TIMEFRAMES Inp_LTF_Timeframe = PERIOD_M5;                      // [روش LTF] تایم فریم برای تاییدیه ورود
input E_Confirmation_Mode Inp_Confirmation_Type = MODE_CLOSE_ONLY;    // [روش تایم فریم فعلی] نوع تایید کندل


// --- زیرگروه تنظیمات تلاقی (Confluence) ---
input group           "         --- تنظیمات تلاقی (Confluence) ---"; // زیرگروه تلاقی
input E_Talaqi_Mode   Inp_Talaqi_Calculation_Mode = TALAQI_MODE_ATR;    // روش محاسبه فاصله تلاقی (بهینه شده)
input double          Inp_Talaqi_ATR_Multiplier     = 0.28;             // [ATR Mode] ضریب ATR برای تلاقی (بهینه شده)
input double          Inp_Talaqi_Distance_in_Points = 3.0;              // [MANUAL Mode] فاصله تلاقی (بر اساس پوینت)
input double          Inp_Talaqi_Kumo_Factor      = 0.2;              // [KUMO Mode] ضریب تلاقی (درصد ضخامت کومو)


// ---=== 🛡️ 4. مدیریت حد ضرر (Stop Loss) 🛡️ ===---
input group           "       ---=== 🛡️ 4. مدیریت حد ضرر (Stop Loss) 🛡️ ===---"; // گروه مدیریت حد ضرر
input ENUM_TIMEFRAMES Inp_SL_Timeframe = PERIOD_CURRENT;                // تایم فریم برای محاسبه SL
input E_SL_Mode       Inp_StopLoss_Type       = MODE_COMPLEX;           // روش محاسبه استاپ لاس
input double          Inp_SL_ATR_Multiplier   = 2.2;                    // [ATR Mode] ضریب ATR برای حد ضرر (بهینه شده)
input int             Inp_SL_Lookback_Period  = 15;                     // [SIMPLE] دوره نگاه به عقب برای یافتن سقف/کف
input double          Inp_SL_Buffer_Multiplier = 3.0;                   // [SIMPLE/COMPLEX] ضریب بافر
input int             Inp_Flat_Kijun_Period   = 50;                     // [COMPLEX] تعداد کندل برای جستجوی کیجون فلت
input int             Inp_Flat_Kijun_Min_Length = 5;                    // [COMPLEX] حداقل طول کیجون فلت
input int             Inp_Pivot_Lookback      = 30;                     // [COMPLEX] تعداد کندل برای جستجوی پیوت

input group           "    --- SL پویا بر اساس نوسان ---"; // زیرگروه SL پویا
input bool            Inp_Enable_SL_Vol_Regime = false;                 // فعال سازی SL پویا با رژیم نوسان
input int             Inp_SL_Vol_Regime_ATR_Period = 14;                // [پویا] دوره ATR برای محاسبه نوسان
input int             Inp_SL_Vol_Regime_EMA_Period = 20;                // [پویا] دوره EMA برای تعریف خط رژیم نوسان
input double          Inp_SL_High_Vol_Multiplier = 2.2;                 // [پویا] ضریب ATR در رژیم نوسان بالا
input double          Inp_SL_Low_Vol_Multiplier = 1.5;                  // [پویا] ضریب ATR در رژیم نوسان پایین

// [NEW] گروه جدید برای مدیریت ریسک پویا
input group           "    --- مدیریت ریسک پویا SL ---";
input double          Inp_Min_SL_Distance_Atr_Percent = 0.5;            // حداقل فاصله SL بر اساس درصد ATR
input double          Inp_SL_Buffer_Atr_Percent = 0.1;                 // بافر SL بر اساس درصد ATR

// ---=== 💰 5. مدیریت سرمایه (Money Management) 💰 ===---
input group           " ---=== 💰 5. مدیریت سرمایه (Money Management) 💰 ===---"; // گروه مدیریت سرمایه
input double          Inp_Risk_Percent_Per_Trade = 0.7;                 // درصد ریسک در هر معامله (بهینه شده)
input double          Inp_Take_Profit_Ratio   = 1.9;                    // نسبت ریسک به ریوارد برای حد سود (بهینه شده)
input int             Inp_Max_Trades_Per_Symbol = 1;                    // حداکثر معاملات باز برای هر نماد
input int             Inp_Max_Total_Trades    = 5;                      // حداکثر کل معاملات باز

// ---=== 🎨 6. تنظیمات گرافیکی (Visuals) 🎨 ===---
input group           "        ---=== 🎨 6. تنظیمات گرافیکی (Visuals) 🎨 ===---"; // گروه تنظیمات گرافیکی
input double          Inp_Object_Size_Multiplier = 1.0;                 // ضریب اندازه اشیاء گرافیکی
input color           Inp_Bullish_Color       = clrLimeGreen;           // رنگ سیگنال و اشیاء خرید
input color           Inp_Bearish_Color       = clrRed;                 // رنگ سیگنال و اشیاء فروش

// ---=== 🚦 7. فیلترهای ورود (Entry Filters) 🚦 ===---
input group           "   ---=== 🚦 7. فیلترهای ورود (Entry Filters) 🚦 ===---"; // گروه فیلترهای ورود
input E_Filter_Timeframe_Context Inp_Filter_Context = FILTER_CONTEXT_HTF; // تایم فریم اجرای فیلترها
input bool            Inp_Enable_Kumo_Filter = true;                    // ✅ [فیلتر کومو]: فعال/غیرفعال
input bool            Inp_Enable_ATR_Filter  = true;                    // ✅ [فیلتر ATR]: فعال/غیرفعال
input int             Inp_ATR_Filter_Period  = 14;                      // [فیلتر ATR]: دوره محاسبه ATR
input double          Inp_ATR_Filter_Min_Value_pips = 9.0;              // [فیلتر ATR]: حداقل مقدار ATR به پیپ (بهینه شده)
input bool            Inp_Enable_ADX_Filter = false;                    // فعال سازی فیلتر قدرت و جهت روند ADX
input int             Inp_ADX_Period = 14;                              // [ADX] دوره محاسبه
input double          Inp_ADX_Threshold = 25.0;                         // [ADX] حداقل قدرت روند برای ورود

input group           "         --- فیلترهای پیشرفته (MKM Filters) ---";
input bool            Inp_Enable_KijunSlope_Filter = false;     // فعال‌سازی فیلتر شیب کیجون-سن
input bool            Inp_Enable_KumoExpansion_Filter = false;  // فعال‌سازی فیلتر انبساط کومو
input bool            Inp_Enable_ChikouSpace_Filter = false;    // فعال‌سازی فیلتر فضای باز چیکو

// [NEW] گروه جدید برای پارامترهای استراتژی MKM
input group           "         --- پارامترهای استراتژی MKM ---";
input int             Inp_MKM_Kijun_Slope_Period = 5;                   // دوره محاسبه شیب کیجون برای MKM
input int            Inp_MKM_Kumo_Expansion_Period = 20;   // <<<< (دوره برای بررسی انبساط کومو)

// ---=== 🎯 8. منطق خروج (Exit Logic) 🎯 ===---
input group "       ---=== 🎯 8. منطق خروج (Exit Logic) 🎯 ===---"; // گروه منطق خروج
input bool            Inp_Enable_Early_Exit = false;                    // فعال سازی خروج زودرس با کراس چیکو و تایید RSI
input int             Inp_Early_Exit_RSI_Period = 14;                   // [خروج زودرس] دوره RSI
input int             Inp_Early_Exit_RSI_Overbought = 70;               // [خروج زودرس] سطح اشباع خرید برای خروج از فروش
input int             Inp_Early_Exit_RSI_Oversold = 30;                 // [خروج زودرس] سطح اشباع فروش برای خروج از خرید

// [NEW] گروه جدید برای تاییدیه ساختاری
input group           "         --- تنظیمات تاییدیه ساختاری ---";
input int             Inp_Structural_Grace_Candles = 3;                 // تعداد کندل مهلت ساختاری
input int             Inp_Structure_Lookback_Bars = 50;                 // تعداد بار نگاه به عقب برای اسکن ساختار


//+------------------------------------------------------------------+
//|     ساختار اصلی برای نگهداری تمام تنظیمات ورودی (SSettings)       |
//+------------------------------------------------------------------+
struct SSettings
{
    // 1. General
    bool                enable_dashboard; // فعال کردن داشبورد
    string              symbols_list; // لیست نمادها
    int                 magic_number; // شماره جادویی
    bool                enable_logging; // فعال کردن لاگ‌ها
    
    // 2. Ichimoku
    ENUM_TIMEFRAMES     ichimoku_timeframe;      // تایم فریم اصلی تحلیل
    int                 tenkan_period; // دوره تنکان
    int                 kijun_period; // دوره کیجون
    int                 senkou_period; // دوره سنکو
    int                 chikou_period; // دوره چیکو
    
    // 3. Signal & Confirmation
    E_Primary_Strategy_Mode primary_strategy; // استراتژی اصلی
    E_Signal_Mode       signal_mode; // حالت سیگنال
    
    E_Entry_Confirmation_Mode entry_confirmation_mode; // نوع تاییدیه ورود
    E_Entry_Tactic          entry_tactic; // <<<< ✅ این خط جدیده

    E_Grace_Period_Mode grace_period_mode;           // نوع مهلت سیگنال
    int                 grace_period_candles;        // [حالت کندلی] تعداد کندل مهلت
    E_Confirmation_Mode confirmation_type;           // [حالت تایم فریم فعلی] نوع تایید کندل
    ENUM_TIMEFRAMES     ltf_timeframe;               // [حالت LTF] تایم فریم برای تاییدیه
    
    // 3.1. Talaqi
    E_Talaqi_Mode       talaqi_calculation_mode; // حالت تلاقی
    double              talaqi_distance_in_points; // فاصله دستی
    double              talaqi_kumo_factor; // ضریب کومو
    double              talaqi_atr_multiplier; // ضریب ATR
    
    // 4. Stop Loss
    ENUM_TIMEFRAMES     sl_timeframe; // تایم فریم برای محاسبه SL
    E_SL_Mode           stoploss_type; // نوع SL
    double              sl_atr_multiplier; // ضریب ATR برای SL
    int                 sl_lookback_period; // دوره نگاه به عقب
    double              sl_buffer_multiplier; // ضریب بافر
    int                 flat_kijun_period; // دوره کیجون فلت
    int                 flat_kijun_min_length; // حداقل طول فلت
    int                 pivot_lookback; // دوره پیوت
    
    bool                enable_sl_vol_regime; // فعال کردن SL پویا
    int                 sl_vol_regime_atr_period; // دوره ATR پویا
    int                 sl_vol_regime_ema_period; // دوره EMA پویا
    double              sl_high_vol_multiplier; // ضریب بالا نوسان
    double              sl_low_vol_multiplier; // ضریب پایین نوسان

    // [NEW] مدیریت ریسک پویا SL
    double              min_sl_distance_atr_percent; // حداقل فاصله SL بر اساس ATR
    double              sl_buffer_atr_percent; // بافر SL بر اساس ATR

    // 5. Money Management
    double              risk_percent_per_trade; // درصد ریسک
    double              take_profit_ratio; // نسبت TP
    int                 max_trades_per_symbol; // حداکثر معاملات نماد
    int                 max_total_trades; // حداکثر معاملات کل
    
    // 6. Visuals
    double              object_size_multiplier; // ضریب اندازه اشیاء
    color               bullish_color; // رنگ خرید
    color               bearish_color; // رنگ فروش
    
    // 7. Entry Filters
    E_Filter_Timeframe_Context filter_context; // زمینه فیلترها
    bool                enable_kumo_filter; // فعال کردن کومو
    bool                enable_atr_filter; // فعال کردن ATR
    int                 atr_filter_period; // دوره ATR فیلتر
    double              atr_filter_min_value_pips; // حداقل ATR

    bool                enable_adx_filter; // فعال کردن ADX
    int                 adx_period; // دوره ADX
    double              adx_threshold; // آستانه ADX

    bool                enable_kijun_slope_filter;   // فیلتر شیب کیجون
    bool                enable_kumo_expansion_filter;// فیلتر انبساط کومو
    bool                enable_chikou_space_filter;  // فیلتر فضای باز چیکو

    // 8. Exit Logic
    bool                enable_early_exit; // فعال کردن خروج زودرس
    int                 early_exit_rsi_period; // دوره RSI خروج
    int                 early_exit_rsi_overbought; // سطح اشباع خرید
    int                 early_exit_rsi_oversold; // سطح اشباع فروش

    // [NEW] پارامترهای MKM
    int                 mkm_kijun_slope_period; // دوره شیب کیجون برای MKM
    int                    mkm_kumo_expansion_period;
    // [NEW] تاییدیه ساختاری
    int                 structural_grace_candles; // تعداد کندل مهلت ساختاری
    int                 structure_lookback_bars; // تعداد بار نگاه به عقب برای ساختار
};



///فایل 2 اکسپرت اجرایی:::

//+------------------------------------------------------------------+
//|                                                      Memento.mq5 |
//|                                  Copyright 2025,hipoalgoritm |
//|                                                  Final & Bulletproof |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025,hipoalgoritm" // حقوق کپی‌رایت اکسپرت
#property link      "https://www.mql5.com" // لینک مرتبط
#property version   "3.1" // نسخه نهایی و کاملا اصلاح شده
#property description "اکسپرت معاملاتی پیشرفته ممنتو بر اساس استراتژی کراس سه گانه ایچیموکو" // توضیح اکسپرت


#include <Trade\Trade.mqh> // کتابخانه ترید
#include <Object.mqh> // کتابخانه اشیاء
#include "IchimokuLogic.mqh" // منطق ایچیموکو
#include "VisualManager.mqh" // مدیریت گرافیک
#include "TrailingStopManager.mqh" // مدیریت تریلینگ استاپ

#include  "licensed.mqh" // لایسنس

//--- متغیرهای سراسری
SSettings            g_settings; // ساختار تنظیمات
string               g_symbols_array[]; // آرایه نمادها
CStrategyManager* g_symbol_managers[]; // آرایه مدیران استراتژی
bool              g_dashboard_needs_update = true; // پرچم برای آپدیت داشبورد
CTrailingStopManager TrailingStop; // مدیر تریلینگ استاپ



int OnInit() {
    //--- ✅✅✅ بخش مقداردهی اولیه تنظیمات (نسخه کاملاً اصلاح شده و هماهنگ) ✅✅✅ ---

    // 1. تنظیمات عمومی
    g_settings.enable_dashboard           = Inp_Enable_Dashboard; // کپی فعال کردن داشبورد
    g_settings.symbols_list                 = Inp_Symbols_List; // کپی لیست نمادها
    g_settings.magic_number                 = Inp_Magic_Number; // کپی مجیک نامبر
    g_settings.enable_logging               = Inp_Enable_Logging; // کپی فعال کردن لاگ

    // 2. تنظیمات ایچیموکو
    g_settings.ichimoku_timeframe           = Inp_Ichimoku_Timeframe; // ✅ اضافه شد
    g_settings.tenkan_period                = Inp_Tenkan_Period; // کپی دوره تنکان
    g_settings.kijun_period                 = Inp_Kijun_Period; // کپی دوره کیجون
    g_settings.senkou_period                = Inp_Senkou_Period; // کپی دوره سنکو
    g_settings.chikou_period                = Inp_Chikou_Period; // کپی دوره چیکو

    // 3. تنظیمات سیگنال و تاییدیه
    g_settings.primary_strategy             = Inp_Primary_Strategy; // <<<< اضافه شود
    g_settings.signal_mode                  = Inp_Signal_Mode; // کپی حالت سیگنال
    g_settings.entry_confirmation_mode      = Inp_Entry_Confirmation_Mode; // ✅ اضافه شد
   
    g_settings.grace_period_mode            = Inp_Grace_Period_Mode; // ✅ اضافه شد
    g_settings.grace_period_candles         = Inp_Grace_Period_Candles; // کپی تعداد کندل مهلت
    g_settings.confirmation_type            = Inp_Confirmation_Type; // کپی نوع تایید
    g_settings.ltf_timeframe                = Inp_LTF_Timeframe; // ✅ اضافه شد
    g_settings.talaqi_calculation_mode      = Inp_Talaqi_Calculation_Mode; // کپی حالت تلاقی
    g_settings.talaqi_atr_multiplier        = Inp_Talaqi_ATR_Multiplier; // کپی ضریب ATR تلاقی
    g_settings.talaqi_distance_in_points    = Inp_Talaqi_Distance_in_Points; // کپی فاصله دستی تلاقی
    g_settings.talaqi_kumo_factor           = Inp_Talaqi_Kumo_Factor; // کپی ضریب کومو تلاقی
    g_settings.entry_tactic                 = Inp_Entry_Tactic; //
    // 4. تنظیمات حد ضرر
    g_settings.sl_timeframe                 = Inp_SL_Timeframe; // <<<< این خط اضافه شود
    g_settings.stoploss_type                = Inp_StopLoss_Type; // کپی نوع SL
    g_settings.sl_atr_multiplier            = Inp_SL_ATR_Multiplier; // کپی ضریب ATR SL
    g_settings.flat_kijun_period            = Inp_Flat_Kijun_Period; // کپی دوره فلت کیجون
    g_settings.flat_kijun_min_length        = Inp_Flat_Kijun_Min_Length; // کپی حداقل طول فلت
    g_settings.pivot_lookback               = Inp_Pivot_Lookback; // کپی دوره پیوت
    g_settings.sl_lookback_period           = Inp_SL_Lookback_Period; // کپی دوره نگاه به عقب
    g_settings.sl_buffer_multiplier         = Inp_SL_Buffer_Multiplier; // کپی ضریب بافر
    
    // 4.1. <<< بخش اضافه شده برای SL پویا >>>
    g_settings.enable_sl_vol_regime         = Inp_Enable_SL_Vol_Regime; // کپی فعال کردن SL پویا
    g_settings.sl_vol_regime_atr_period     = Inp_SL_Vol_Regime_ATR_Period; // کپی دوره ATR پویا
    g_settings.sl_vol_regime_ema_period     = Inp_SL_Vol_Regime_EMA_Period; // کپی دوره EMA پویا
    g_settings.sl_high_vol_multiplier       = Inp_SL_High_Vol_Multiplier; // کپی ضریب بالا نوسان
    g_settings.sl_low_vol_multiplier        = Inp_SL_Low_Vol_Multiplier; // کپی ضریب پایین نوسان

    g_settings.min_sl_distance_atr_percent = Inp_Min_SL_Distance_Atr_Percent; // [NEW]
    g_settings.sl_buffer_atr_percent = Inp_SL_Buffer_Atr_Percent; // [NEW]

    // 5. تنظیمات مدیریت سرمایه
    g_settings.risk_percent_per_trade       = Inp_Risk_Percent_Per_Trade; // کپی درصد ریسک
    g_settings.take_profit_ratio            = Inp_Take_Profit_Ratio; // کپی نسبت TP
    g_settings.max_trades_per_symbol        = Inp_Max_Trades_Per_Symbol; // کپی حداکثر معاملات نماد
    g_settings.max_total_trades             = Inp_Max_Total_Trades; // کپی حداکثر معاملات کل

    // 6. تنظیمات گرافیکی
    g_settings.object_size_multiplier       = Inp_Object_Size_Multiplier; // کپی ضریب اندازه اشیاء
    g_settings.bullish_color                = Inp_Bullish_Color; // کپی رنگ خرید
    g_settings.bearish_color                = Inp_Bearish_Color; // کپی رنگ فروش
    
    // 7. <<< بخش اضافه شده برای فیلترها >>>
    g_settings.filter_context               = Inp_Filter_Context; // <<<< این خط اضافه شود
    g_settings.enable_kumo_filter           = Inp_Enable_Kumo_Filter; // کپی فعال کردن کومو
    g_settings.enable_atr_filter            = Inp_Enable_ATR_Filter; // کپی فعال کردن ATR
    g_settings.atr_filter_period            = Inp_ATR_Filter_Period; // کپی دوره ATR فیلتر
    g_settings.atr_filter_min_value_pips    = Inp_ATR_Filter_Min_Value_pips; // کپی حداقل ATR
    g_settings.enable_adx_filter            = Inp_Enable_ADX_Filter; // کپی فعال کردن ADX
    g_settings.adx_period                   = Inp_ADX_Period; // کپی دوره ADX
    g_settings.adx_threshold                = Inp_ADX_Threshold; // کپی آستانه ADX

    g_settings.enable_kijun_slope_filter    = Inp_Enable_KijunSlope_Filter;    // <<<< اضافه شود
    g_settings.enable_kumo_expansion_filter = Inp_Enable_KumoExpansion_Filter; // <<<< اضافه شود
    g_settings.enable_chikou_space_filter   = Inp_Enable_ChikouSpace_Filter;   // <<<< اضافه شود

    g_settings.mkm_kijun_slope_period = Inp_MKM_Kijun_Slope_Period; // [NEW]
    g_settings.mkm_kumo_expansion_period = Inp_MKM_Kumo_Expansion_Period;
    
    // 8. <<< بخش اضافه شده برای خروج زودرس >>>
    g_settings.enable_early_exit            = Inp_Enable_Early_Exit; // کپی فعال کردن خروج زودرس
    g_settings.early_exit_rsi_period        = Inp_Early_Exit_RSI_Period; // کپی دوره RSI خروج
    g_settings.early_exit_rsi_overbought    = Inp_Early_Exit_RSI_Overbought; // کپی سطح اشباع خرید
    g_settings.early_exit_rsi_oversold      = Inp_Early_Exit_RSI_Oversold; // کپی سطح اشباع فروش

    g_settings.structural_grace_candles = Inp_Structural_Grace_Candles; // [NEW]
    g_settings.structure_lookback_bars = Inp_Structure_Lookback_Bars; // [NEW]


    //--- بقیه تابع OnInit بدون تغییر ...
    int symbols_count = StringSplit(g_settings.symbols_list, ',', g_symbols_array); // جداسازی نمادها
    if (symbols_count == 0) { // چک خطای نمادها
        Print("خطا: هیچ نمادی برای معامله مشخص نشده است.");
        return INIT_FAILED;
    }

    ArrayResize(g_symbol_managers, symbols_count); // تغییر اندازه آرایه مدیران
    for (int i = 0; i < symbols_count; i++) { // حلقه برای هر نماد
        string sym = g_symbols_array[i];
        StringTrimLeft(sym);
        StringTrimRight(sym);
        g_symbol_managers[i] = new CStrategyManager(sym, g_settings); // ایجاد مدیر استراتژی
        if (!g_symbol_managers[i].Init()) { // چک اولیه
            Print("مقداردهی اولیه نماد ", sym, " با خطا مواجه شد. عملیات متوقف می‌شود.");
            for (int j = 0; j <= i; j++) { // پاکسازی
                if (g_symbol_managers[j] != NULL) { // [MODIFIED] چک NULL
                    delete g_symbol_managers[j];
                    g_symbol_managers[j] = NULL;
                }
            }
            ArrayFree(g_symbol_managers); // آزاد کردن آرایه
            return INIT_FAILED;
        }
    }

    Print("اکسپرت Memento با موفقیت برای نمادهای زیر مقداردهی اولیه شد: ", g_settings.symbols_list); // لاگ موفقیت
    TrailingStop.Init(Inp_Magic_Number); // اولیه تریلینگ استاپ

    EventSetTimer(1); // تنظیم تایمر
    return(INIT_SUCCEEDED); // بازگشت موفقیت
}




//+------------------------------------------------------------------+
//| تابع پایان اکسپرت (پاکسازی)                                      |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
   EventKillTimer(); // خاموش کردن تایمر
//--- پاکسازی شیءها
   for (int i = 0; i < ArraySize(g_symbol_managers); i++) { // حلقه پاکسازی مدیران
      if (g_symbol_managers[i] != NULL) {
         delete g_symbol_managers[i];
         g_symbol_managers[i] = NULL;
      }
   }
   ArrayFree(g_symbol_managers); // آزاد کردن آرایه


//--- پاک کردن تمام اشیاء گرافیکی با پیشوند صحیح
   ObjectsDeleteAll(0, "MEMENTO_UI_"); // حذف اشیاء
   ChartRedraw(); // بازسازی چارت

}
void OnTick(void)
      {
       if(CheckLicenseExpiry()==false) // چک لایسنس
{
ExpertRemove();
//return(INIT_FAILED);
}
      }
//+------------------------------------------------------------------+
//| تابع تایمر (مرکز فرماندهی جدید)                                  |
//+------------------------------------------------------------------+
void OnTimer() 
{
   // 1. اجرای تریلینگ استاپ (مثل قبل)
   TrailingStop.Process(); // پردازش تریلینگ استاپ

   // 2. اجرای منطق اصلی برای هر نماد از طریق یک تابع واحد
   for (int i = 0; i < ArraySize(g_symbol_managers); i++)  // حلقه برای هر مدیر
   {
      if (g_symbol_managers[i] != NULL) 
      {
         g_symbol_managers[i].OnTimerTick(); // <<<< نام تابع از ProcessNewBar به OnTimerTick تغییر می‌کند
      }
   }

   // 3. آپدیت هوشمند داشبورد (مثل قبل)
   if (g_dashboard_needs_update)  // چک نیاز به آپدیت
   {
      // پیدا کردن نمونه‌ای از منیجر که مسئول چارت اصلی است
      for (int i = 0; i < ArraySize(g_symbol_managers); i++)  // حلقه جستجو
      {
         if (g_symbol_managers[i] != NULL && g_symbol_managers[i].GetSymbol() == _Symbol)  // چک نماد
         {
            g_symbol_managers[i].UpdateMyDashboard(); // آپدیت داشبورد
            Print("داشبورد به دلیل رویداد معاملاتی آپدیت شد."); // لاگ آپدیت
            break; // بعد از آپدیت از حلقه خارج شو
         }
      }
      g_dashboard_needs_update = false; // پرچم را برای آپدیت بعدی ریست کن
   }
}





//+------------------------------------------------------------------+
//| تابع رویدادهای معاملاتی                                           |
//+------------------------------------------------------------------+
//
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result) {
// ما فقط به رویدادهایی که یک معامله به تاریخچه اضافه می‌کنند علاقه داریم
   if (trans.type == TRADE_TRANSACTION_DEAL_ADD && trans.deal > 0) { // چک نوع تراکنش
      // اطلاعات معامله را از تاریخچه می‌گیریم
      ulong deal_ticket = trans.deal; // تیکت معامله
      if(HistoryDealSelect(deal_ticket)) { // انتخاب معامله
         // چک می‌کنیم معامله مربوط به همین اکسپرت باشه
         if(HistoryDealGetInteger(deal_ticket, DEAL_MAGIC) == (long)g_settings.magic_number) { // چک مجیک
            // اگر معامله از نوع خروج از پوزیشن بود (بسته شدن)
            if(HistoryDealGetInteger(deal_ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT) { // چک ورود/خروج
               string deal_symbol = HistoryDealGetString(deal_ticket, DEAL_SYMBOL); // نماد معامله

               // مدیر استراتژی مربوط به این نماد را پیدا می‌کنیم
               for(int i = 0; i < ArraySize(g_symbol_managers); i++) { // حلقه مدیران
                  if(g_symbol_managers[i] != NULL && g_symbol_managers[i].GetSymbol() == deal_symbol) { // چک نماد
                     // مدیر گرافیک آن را می‌گیریم و در متغیر محلی ذخیره می‌کنیم [MODIFIED]
                     CVisualManager *visual_manager = g_symbol_managers[i].GetVisualManager(); // گرفتن مدیر گرافیک
                     if(visual_manager != NULL) { // چک وجود
                        // ایندکس نماد را در داشبورد پیدا می‌کنیم
                        int symbol_index = visual_manager.GetSymbolIndex(deal_symbol); // گرفتن ایندکس
                        if(symbol_index != -1) { // چک ایندکس
                           // اطلاعات سود و زیان را می‌گیریم
                           double p = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT); // سود
                           double c = HistoryDealGetDouble(deal_ticket, DEAL_COMMISSION); // کمیسیون
                           double s = HistoryDealGetDouble(deal_ticket, DEAL_SWAP); // سواپ

                           // و دفترچه حسابداری را آپدیت می‌کنیم
                           visual_manager.UpdateDashboardCache(symbol_index, p, c, s); // آپدیت کش
                        }
                     }
                     break; // مدیر پیدا شد، از حلقه خارج شو
                  }
               }
            }

            // در هر صورت (چه باز شدن و چه بسته شدن) داشبورد نیاز به آپدیت دارد
            g_dashboard_needs_update = true; // تنظیم پرچم آپدیت
         }
      }
   }
}



//+------------------------------------------------------------------+
//| تابع مدیریت رویدادهای چارت (برای کلیک روی دکمه)                   |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam) {
// اگر رویداد از نوع کلیک روی یک آبجکت بود
   if(id == CHARTEVENT_OBJECT_CLICK) { // چک نوع رویداد
      // مدیر استراتژی مربوط به چارت فعلی را پیدا کن
      for(int i = 0; i < ArraySize(g_symbol_managers); i++) { // حلقه مدیران
         if(g_symbol_managers[i] != NULL && g_symbol_managers[i].GetSymbol() == _Symbol) { // چک نماد
            // مدیر گرافیک را در متغیر محلی ذخیره کن [MODIFIED]
            CVisualManager *visual_manager = g_symbol_managers[i].GetVisualManager(); // گرفتن مدیر گرافیک
            if (visual_manager != NULL) // چک وجود
            {
                visual_manager.OnChartEvent(id, lparam, dparam, sparam); // ارسال رویداد
            }
            break; // کار تمام است، از حلقه خارج شو
         }
      }
   }
}
//+------------------------------------------------------------------+



//--- گروه: تنظیمات بهینه‌سازی سفارشی ---
input group "  تنظیمات بهینه‌سازی سفارشی"; // گروه بهینه‌سازی
input int InpMinTradesPerYear = 30; // حداقل تعداد معاملات قابل قبول در یک سال
input int InpMaxAcceptableDrawdown = 15; // حداکثر دراوداون قابل قبول


//+------------------------------------------------------------------+
//| تابع اصلی رویداد تستر که امتیاز نهایی را محاسبه می‌کند.          |
//+------------------------------------------------------------------+
double OnTester()
{
   // --- 1. گرفتن تمام آمارهای استاندارد مورد نیاز ---
   double total_trades         = TesterStatistics(STAT_TRADES); // تعداد معاملات
   double net_profit           = TesterStatistics(STAT_PROFIT); // سود خالص
   double profit_factor        = TesterStatistics(STAT_PROFIT_FACTOR); // فاکتور سود
   double sharpe_ratio         = TesterStatistics(STAT_SHARPE_RATIO); // شارپ ریتو
   double max_balance_drawdown_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT); // حداکثر دراوداون

   // --- 2. محاسبه حداقل تعداد معاملات مورد نیاز (بدون تغییر) ---
   datetime startDate = 0, endDate = 0; // تاریخ شروع و پایان
   if(HistoryDealsTotal() > 0) // چک معاملات
     {
      startDate = (datetime)HistoryDealGetInteger(0, DEAL_TIME); // تاریخ شروع
      endDate   = (datetime)HistoryDealGetInteger(HistoryDealsTotal() - 1, DEAL_TIME); // تاریخ پایان
     }
   double duration_days = (endDate > startDate) ? double(endDate - startDate) / (24.0 * 3600.0) : 1.0; // محاسبه روزها
   double required_min_trades = floor((duration_days / 365.0) * InpMinTradesPerYear); // حداقل معاملات
   if(required_min_trades < 10) required_min_trades = 10; // حداقل 10

   // --- 3. فیلترهای ورودی نهایی (بدون تغییر) ---
   if(total_trades < required_min_trades || profit_factor < 1.1 || sharpe_ratio <= 0 || net_profit <= 0) // چک فیلترها
     {
      return 0.0; // بازگشت صفر
     }

   // --- 4. محاسبه معیارهای پیشرفته (بدون تغییر) ---
   double r_squared = 0, downside_consistency = 0; // متغیرهای پیشرفته
   CalculateAdvancedMetrics(r_squared, downside_consistency); // محاسبه پیشرفته

   // --- 5. *** مهندسی امتیاز: محاسبه "ضریب مجازات" با منحنی کسینوسی *** ---
   double drawdown_penalty_factor = 0.0; // ضریب مجازات
   if (max_balance_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)  // چک دراوداون
   {
      // دراودان رو به یک زاویه بین 0 تا 90 درجه (π/2 رادیان) تبدیل می‌کنیم
      double angle = (max_balance_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0); // محاسبه زاویه
      
      // ضریب مجازات، کسینوس اون زاویه است. هرچی زاویه (دراودان) بیشتر، کسینوس (امتیاز) کمتر
      drawdown_penalty_factor = cos(angle); // محاسبه کسینوس
   }
   // اگر دراودان بیشتر از حد مجاز باشه، ضریب صفر می‌مونه و کل پاس رد میشه

   // --- 6. محاسبه امتیاز نهایی جامع با فرمول جدید و پیوسته ---
   double final_score = 0.0; // امتیاز نهایی
   if(drawdown_penalty_factor > 0) // چک مجازات
   {
      // استفاده از log برای نرمال‌سازی و جلوگیری از تاثیر بیش از حد اعداد بزرگ
      double trades_factor = log(total_trades + 1); // +1 برای جلوگیری از log(0)
      double net_profit_factor = log(net_profit + 1); // فاکتور سود خالص

      final_score = (profit_factor * sharpe_ratio * r_squared * downside_consistency * trades_factor * net_profit_factor) 
                     * drawdown_penalty_factor; // ضرب در ضریب مجازات جدید و هوشمند
   }

   // --- 7. چاپ نتیجه برای دیباگ ---
   PrintFormat("نتیجه: Trades=%d, PF=%.2f, Sharpe=%.2f, R²=%.3f, BalDD=%.2f%%, Penalty=%.2f -> امتیاز: %.4f",
               (int)total_trades, profit_factor, sharpe_ratio, r_squared, max_balance_drawdown_percent, drawdown_penalty_factor, final_score); // لاگ نتیجه

   return final_score; // بازگشت امتیاز
}

// تابع CalculateAdvancedMetrics بدون هیچ تغییری باقی می‌ماند
void CalculateAdvancedMetrics(double &r_squared, double &downside_consistency)
{
   r_squared = 0; // اولیه r_squared
   downside_consistency = 1.0; // اولیه ثبات

   if(!HistorySelect(0, TimeCurrent())) return; // انتخاب تاریخچه
   uint total_deals = HistoryDealsTotal(); // تعداد معاملات
   if(total_deals < 5) return; // چک حداقل معاملات

   EquityPoint equity_curve[]; // آرایه منحنی اکویتی
   ArrayResize(equity_curve, (int)total_deals + 2); // تغییر اندازه

   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE); // بالانس نهایی
   double net_profit = TesterStatistics(STAT_PROFIT); // سود خالص
   double initial_balance = final_balance - net_profit; // بالانس اولیه
   
   double current_balance = initial_balance; // بالانس فعلی
   equity_curve[0].time      = (datetime)HistoryDealGetInteger(0, DEAL_TIME) - 1; // زمان اولیه
   equity_curve[0].balance   = current_balance; // بالانس اولیه

   int equity_points = 1; // شمارنده نقاط
   for(uint i = 0; i < total_deals; i++) // حلقه معاملات
     {
      ulong ticket = HistoryDealGetTicket(i); // تیکت
      if(ticket > 0) // چک تیکت
        {
         if(HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT) // چک خروج
           {
            current_balance += HistoryDealGetDouble(ticket, DEAL_PROFIT) + HistoryDealGetDouble(ticket, DEAL_COMMISSION) + HistoryDealGetDouble(ticket, DEAL_SWAP); // آپدیت بالانس
            equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME); // زمان نقطه
            equity_curve[equity_points].balance = current_balance; // بالانس نقطه
            equity_points++; // افزایش
           }
        }
     }
   ArrayResize(equity_curve, equity_points); // تغییر اندازه نهایی
   if(equity_points < 3) return; // چک حداقل نقاط
   
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0; // متغیرهای محاسباتی
   for(int i = 0; i < equity_points; i++) // حلقه نقاط
     {
      double x = i + 1.0; double y = equity_curve[i].balance; // x و y
      sum_x += x; sum_y += y; sum_xy += x * y; sum_x2 += x*x; sum_y2 += y*y; // جمع‌ها
     }
   double n = equity_points; // تعداد نقاط
   double den_part1 = (n*sum_x2) - (sum_x*sum_x); // محاسبه دنومیناتور 1
   double den_part2 = (n*sum_y2) - (sum_y*sum_y); // محاسبه دنومیناتور 2
   if(den_part1 > 0 && den_part2 > 0) // چک مثبت بودن
     {
      double r = ((n*sum_xy) - (sum_x*sum_y)) / sqrt(den_part1 * den_part2); // محاسبه r
      r_squared = r*r; // محاسبه r_squared
     }

   MonthlyTrades monthly_counts[]; // آرایه ماهانه
   int total_months = 0; // شمارنده ماه‌ها
   
   for(uint i=0; i<total_deals; i++) // حلقه معاملات
     {
      ulong ticket = HistoryDealGetTicket(i); // تیکت
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT) // چک خروج
        {
         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME); // زمان معامله
         MqlDateTime dt; // ساختار زمان
         TimeToStruct(deal_time, dt); // تبدیل زمان
         
         int month_idx = -1; // ایندکس ماه
         for(int j=0; j<total_months; j++) { // جستجو ماه
            if(monthly_counts[j].year == dt.year && monthly_counts[j].month == dt.mon) { // چک ماه و سال
               month_idx = j;
               break;
            }
         }
         
         if(month_idx == -1) { // اگر جدید
            ArrayResize(monthly_counts, total_months + 1); // تغییر اندازه
            monthly_counts[total_months].year = dt.year; // سال
            monthly_counts[total_months].month = dt.mon; // ماه
            monthly_counts[total_months].count = 1; // شمارنده
            total_months++; // افزایش
         } else { // افزایش شمارنده
            monthly_counts[month_idx].count++;
         }
        }
     }

   if(total_months <= 1) { // چک حداقل ماه‌ها
      downside_consistency = 1.0; // مقدار پیش‌فرض
      return;
   }

   double target_trades_per_month = InpMinTradesPerYear / 12.0; // هدف ماهانه
   if (target_trades_per_month < 1) target_trades_per_month = 1; // حداقل 1


   double sum_of_squared_downside_dev = 0; // جمع مربعات انحراف
   for(int i = 0; i < total_months; i++) { // حلقه ماه‌ها
      if(monthly_counts[i].count < target_trades_per_month) { // چک کمتر از هدف
         double deviation = target_trades_per_month - monthly_counts[i].count; // انحراف
         sum_of_squared_downside_dev += deviation * deviation; // جمع مربعات
      }
   }

   double downside_variance = sum_of_squared_downside_dev / total_months; // واریانس
   double downside_deviation = sqrt(downside_variance); // انحراف استاندارد

   downside_consistency = 1.0 / (1.0 + downside_deviation); // محاسبه ثبات
}



//+------------------------------------------------------------------+
//|     بخش بهینه‌سازی سفارشی (Custom Optimization) نسخه 10.0 - نهایی   |
//|      با "منحنی مجازات دراوداون پیوسته" (Continuous Penalty Curve)     |
//+------------------------------------------------------------------+

//--- ساختارهای کمکی (بدون تغییر)
struct EquityPoint
{
   datetime time; // زمان نقطه
   double   balance; // بالانس نقطه
};
struct MonthlyTrades
{
   int      year; // سال
   int      month; // ماه
   int      count; // شمارنده
};



// فایل 3 کتابخانه  ایچیموکو هسته اصلی:::


//+------------------------------------------------------------------+
//|                                     IchimokuLogic.mqh            |
//|                          © 2025, hipoalgoritm                   |
//+------------------------------------------------------------------+
#property copyright "© 2025,hipoalgoritm" // حقوق کپی‌رایت پروژه
#property link      "https://www.mql5.com" // لینک مرتبط با پروژه
#property version   "3.1"  // نسخه با معماری "Hunter" و ارتقاءها
#include "set.mqh" // فایل تنظیمات ورودی‌ها
#include <Trade\Trade.mqh> // کتابخانه مدیریت معاملات
#include <Trade\SymbolInfo.mqh> // کتابخانه اطلاعات نماد
#include <Object.mqh> // کتابخانه مدیریت اشیاء گرافیکی
#include "VisualManager.mqh" // فایل مدیریت گرافیک و داشبورد
#include <MovingAverages.mqh> // کتابخانه میانگین‌های متحرک
#include "MarketStructure.mqh" // کتابخانه تحلیل ساختار بازار

//+------------------------------------------------------------------+
//| ساختار برای نگهداری سیگنال‌های بالقوه (Potential Signals)     |
//+------------------------------------------------------------------+
struct SPotentialSignal
{
    datetime        time; // زمان وقوع سیگنال
    bool            is_buy; // نوع سیگنال: true برای خرید، false برای فروش
    int             grace_candle_count; // شمارنده کندل‌های مهلت برای انقضا
    double          invalidation_level; // سطح ابطال سیگنال (برای حالت ساختاری)
    
    // سازنده کپی برای جلوگیری از مشکلات کپی ساختار
    SPotentialSignal(const SPotentialSignal &other) // کپی سازنده
    {
        time = other.time; // کپی زمان
        is_buy = other.is_buy; // کپی نوع سیگنال
        grace_candle_count = other.grace_candle_count; // کپی شمارنده
        invalidation_level = other.invalidation_level; // کپی سطح ابطال
    }
    // سازنده پیش‌فرض برای مقداردهی اولیه
    SPotentialSignal() // پیش‌فرض
    {
       invalidation_level = 0.0; // مقدار اولیه سطح ابطال
    }
};

//+------------------------------------------------------------------+
//| کلاس مدیریت استراتژی برای هر نماد خاص                          |
//+------------------------------------------------------------------+
class CStrategyManager
{
private:
    string              m_symbol; // نماد معاملاتی فعلی
    SSettings           m_settings; // ساختار تنظیمات ورودی‌ها
    CTrade              m_trade; // شیء مدیریت معاملات
   
    datetime            m_last_bar_time_htf; // زمان آخرین کندل در تایم فریم اصلی (HTF)
    datetime            m_last_bar_time_ltf; // زمان آخرین کندل در تایم فریم پایین (LTF)
    
    // --- هندل‌های اندیکاتورها (برای محاسبات) ---
    int                 m_ichimoku_handle; // هندل اندیکاتور ایچیموکو
    int                 m_atr_handle;      // هندل اندیکاتور ATR
    int                 m_adx_handle;       // هندل اندیکاتور ADX برای فیلتر روند
    int                 m_rsi_exit_handle;  // هندل اندیکاتور RSI برای خروج زودرس

    // --- بافرهای داده اندیکاتورها ---
    double              m_tenkan_buffer[]; // بافر تنکان-سن
    double              m_kijun_buffer[]; // بافر کیجون-سن
    double              m_chikou_buffer[]; // بافر چیکو اسپن
    double              m_high_buffer[]; // بافر سقف قیمت‌ها
    double              m_low_buffer[];  // بافر کف قیمت‌ها
    
    // --- مدیریت سیگنال‌ها ---
    SPotentialSignal    m_signal; // سیگنال اصلی فعال
    bool                m_is_waiting; // حالت انتظار برای تایید سیگنال
    bool                m_waiting_for_shift; // [NEW] حالت انتظار برای تغییر ساختار
    bool                m_waiting_for_pullback; // [NEW] حالت انتظار برای پولبک
    SPotentialSignal    m_potential_signals[]; // آرایه سیگنال‌های بالقوه در حالت مسابقه
    CVisualManager* m_visual_manager; // مدیر گرافیک و داشبورد
    CMarketStructureShift m_ltf_analyzer; // تحلیلگر ساختار بازار در تایم فریم پایین (LTF)
    CMarketStructureShift m_grace_structure_analyzer; // تحلیلگر ساختار برای مهلت ساختاری

    //--- توابع کمکی داخلی ---
    void Log(string message); // تابع لاگ کردن پیام‌ها
    
    // --- منطق اصلی سیگنال‌ها ---
    void AddOrUpdatePotentialSignal(bool is_buy); // اضافه یا به‌روزرسانی سیگنال بالقوه
    bool CheckTripleCross(bool& is_buy); // چک کردن کراس سه‌گانه (تنکان، کیجون، چیکو) - بهبود: تلرانس برای Chikou اضافه شد
    bool CheckFinalConfirmation(bool is_buy); // چک تایید نهایی ورود
    bool CheckLowerTfConfirmation(bool is_buy); // چک تایید در تایم فریم پایین (LTF)
    // --- فیلترهای ورود ---
    bool AreAllFiltersPassed(bool is_buy); // چک کردن تمام فیلترهای ورود
    bool CheckKumoFilter(bool is_buy, ENUM_TIMEFRAMES timeframe); // فیلتر موقعیت نسبت به ابر کومو با تایم فریم
    bool CheckAtrFilter(ENUM_TIMEFRAMES timeframe); // فیلتر حداقل نوسان ATR با تایم فریم
    bool CheckAdxFilter(bool is_buy, ENUM_TIMEFRAMES timeframe); // فیلتر قدرت و جهت روند ADX با تایم فریم

    // --- منطق خروج ---
    void CheckForEarlyExit();         // چک کردن شرایط خروج زودرس از معاملات
    bool CheckChikouRsiExit(bool is_buy); // چک منطق خروج با کراس چیکو و تایید RSI

    //--- محاسبه استاپ لاس ---
    double CalculateStopLoss(bool is_buy, double entry_price); // محاسبه نهایی سطح استاپ لاس
    double CalculateAtrStopLoss(bool is_buy, double entry_price, ENUM_TIMEFRAMES timeframe); // محاسبه SL مبتنی بر ATR با تایم فریم
    double GetTalaqiTolerance(int reference_shift); // محاسبه تلرانس تلاقی (Confluence)
    double CalculateAtrTolerance(int reference_shift); // محاسبه تلرانس بر اساس ATR
    double CalculateDynamicTolerance(int reference_shift); // محاسبه تلرانس بر اساس ضخامت کومو
    double FindFlatKijun(ENUM_TIMEFRAMES timeframe); // پیدا کردن سطح کیجون فلت با تایم فریم
    double FindPivotKijun(bool is_buy, ENUM_TIMEFRAMES timeframe); // پیدا کردن پیوت روی کیجون با تایم فریم
    double FindPivotTenkan(bool is_buy, ENUM_TIMEFRAMES timeframe); // پیدا کردن پیوت روی تنکان با تایم فریم
    double FindBackupStopLoss(bool is_buy, double buffer, ENUM_TIMEFRAMES timeframe); // محاسبه SL پشتیبان با تایم فریم
    double CalculateStructuralStopLoss(bool is_buy, double entry_price); // [NEW] محاسبه SL ساختاری
    
    //--- مدیریت معاملات ---
    int CountSymbolTrades(); // شمارش معاملات باز برای نماد فعلی
    int CountTotalTrades(); // شمارش کل معاملات باز
    void OpenTrade(bool is_buy); // باز کردن معامله جدید
    bool PlaceLimitOrder(bool is_buy);
    bool IsDataReady(); // چک آماده بودن داده‌های تمام تایم فریم‌ها
    bool IsNewBar(ENUM_TIMEFRAMES timeframe, datetime &last_bar_time); // چک تشکیل کندل جدید در تایم فریم مشخص

    //--- توابع جدید MKM ---
    double CalculateKijunSlope(ENUM_TIMEFRAMES timeframe, int period, double& threshold); // محاسبه شیب کیجون
    bool IsKumoExpanding(ENUM_TIMEFRAMES timeframe, int period); // چک انبساط ابر کومو - بهبود: SMA به EMA تغییر یافت
    bool IsChikouInOpenSpace(bool is_buy, ENUM_TIMEFRAMES timeframe); // چک فضای باز چیکو

public:
    CStrategyManager(string symbol, SSettings &settings); // کانستراکتور کلاس
    ~CStrategyManager(); // دیستراکتور کلاس
    bool Init(); // مقداردهی اولیه کلاس
    void OnTimerTick(); // تابع اصلی رویداد تایمر (هر ثانیه)
    void ProcessSignalSearch(); // جستجوی سیگنال اولیه
    void ManageActiveSignal(bool is_new_htf_bar); // مدیریت سیگنال‌های فعال
    string GetSymbol() const { return m_symbol; } // گرفتن نماد فعلی
    void UpdateMyDashboard(); // به‌روزرسانی داشبورد
    CVisualManager* GetVisualManager() { return m_visual_manager; } // گرفتن مدیر گرافیک
};

//+------------------------------------------------------------------+
//| کانستراکتور کلاس مدیریت استراتژی                                |
//+------------------------------------------------------------------+
CStrategyManager::CStrategyManager(string symbol, SSettings &settings)
{
    m_symbol = symbol; // تنظیم نماد معاملاتی
    m_settings = settings; // کپی تنظیمات ورودی
    m_last_bar_time_htf = 0; // مقدار اولیه زمان آخرین کندل HTF
    m_last_bar_time_ltf = 0; // مقدار اولیه زمان آخرین کندل LTF
    m_is_waiting = false; // مقدار اولیه حالت انتظار (غیرفعال)
    m_waiting_for_shift = false; // [NEW] مقدار اولیه حالت تغییر
    m_waiting_for_pullback = false; // [NEW] مقدار اولیه حالت پولبک
    ArrayFree(m_potential_signals); // آزاد کردن آرایه سیگنال‌های بالقوه
    m_ichimoku_handle = INVALID_HANDLE; // مقدار اولیه هندل ایچیموکو
    m_atr_handle = INVALID_HANDLE; // مقدار اولیه هندل ATR
    m_visual_manager = new CVisualManager(symbol, settings); // ایجاد مدیر گرافیک جدید
}

//+------------------------------------------------------------------+
//| دیستراکتور کلاس (برای آزاد کردن منابع)                          |
//+------------------------------------------------------------------+
CStrategyManager::~CStrategyManager()
{
    // پاک کردن مدیر گرافیک اگر وجود داشته باشد
    if (m_visual_manager != NULL) // چک وجود شیء
    {
        delete m_visual_manager; // حذف شیء
        m_visual_manager = NULL; // ریست اشاره‌گر
    }

    // آزاد کردن هندل‌های اندیکاتورها (هر کدام فقط یک بار)
    if(m_ichimoku_handle != INVALID_HANDLE) // چک هندل ایچیموکو
        IndicatorRelease(m_ichimoku_handle); // آزاد کردن هندل
    if(m_atr_handle != INVALID_HANDLE) // چک هندل ATR
        IndicatorRelease(m_atr_handle); // آزاد کردن هندل
    if(m_adx_handle != INVALID_HANDLE) // چک هندل ADX
        IndicatorRelease(m_adx_handle); // آزاد کردن هندل
    if(m_rsi_exit_handle != INVALID_HANDLE) // چک هندل RSI
        IndicatorRelease(m_rsi_exit_handle); // آزاد کردن هندل
}

//+------------------------------------------------------------------+
//| به‌روزرسانی داشبورد اطلاعاتی                                    |
//+------------------------------------------------------------------+
void CStrategyManager::UpdateMyDashboard() 
{ 
    if (m_visual_manager != NULL) // چک وجود مدیر گرافیک
    {
        m_visual_manager.UpdateDashboard(); // فراخوانی تابع به‌روزرسانی داشبورد
    }
}

//+------------------------------------------------------------------+
//| مقداردهی اولیه کلاس (با واکسیناسیون داده‌ها)                    |
//+------------------------------------------------------------------+
bool CStrategyManager::Init()
{
    // +++ واکسیناسیون برای اطمینان از بارگذاری داده‌ها +++
    int attempts = 0; // شمارنده تلاش‌ها
    while(iBars(m_symbol, m_settings.ichimoku_timeframe) < 200 && attempts < 100) // حلقه تا بارگذاری کافی
    {
        Sleep(100);  // تاخیر ۱۰۰ میلی‌ثانیه
        MqlRates rates[]; // آرایه نرخ‌ها
        CopyRates(m_symbol, m_settings.ichimoku_timeframe, 0, 1, rates);  // کپی نرخ‌ها برای تحریک بارگذاری
        attempts++; // افزایش شمارنده
    }
    if (iBars(m_symbol, m_settings.ichimoku_timeframe) < 200) // چک نهایی تعداد بارها
    {
        Log("خطای بحرانی: پس از تلاش‌های مکرر، داده‌های کافی برای نماد " + m_symbol + " بارگذاری نشد."); // لاگ خطا
        return false; // بازگشت شکست
    }
    // +++ پایان واکسیناسیون +++

    
    // تنظیمات اولیه شیء ترید
    m_trade.SetExpertMagicNumber(m_settings.magic_number); // تنظیم شماره جادویی
    m_trade.SetTypeFillingBySymbol(m_symbol); // تنظیم نوع پر کردن سفارش بر اساس نماد
    
    // --- ایجاد هندل اندیکاتورها در حالت نامرئی (Ghost Mode) ---
    // ایچیموکو در حالت نامرئی
    MqlParam ichimoku_params[3]; // پارامترهای ایچیموکو
    ichimoku_params[0].type = TYPE_INT; ichimoku_params[0].integer_value = m_settings.tenkan_period; // دوره تنکان
    ichimoku_params[1].type = TYPE_INT; ichimoku_params[1].integer_value = m_settings.kijun_period; // دوره کیجون
    ichimoku_params[2].type = TYPE_INT; ichimoku_params[2].integer_value = m_settings.senkou_period; // دوره سنکو
    m_ichimoku_handle = IndicatorCreate(m_symbol, m_settings.ichimoku_timeframe, IND_ICHIMOKU, 3, ichimoku_params); // ایجاد هندل

    // ATR در حالت نامرئی
    MqlParam atr_params[1]; // پارامتر ATR
    atr_params[0].type = TYPE_INT; atr_params[0].integer_value = m_settings.atr_filter_period; // دوره ATR
    m_atr_handle = IndicatorCreate(m_symbol, m_settings.ichimoku_timeframe, IND_ATR, 1, atr_params); // ایجاد هندل

    // ADX در حالت نامرئی
    MqlParam adx_params[1]; // پارامتر ADX
    adx_params[0].type = TYPE_INT; adx_params[0].integer_value = m_settings.adx_period; // دوره ADX
    m_adx_handle = IndicatorCreate(m_symbol, m_settings.ichimoku_timeframe, IND_ADX, 1, adx_params); // ایجاد هندل

    // RSI در حالت نامرئی
    MqlParam rsi_params[2]; // پارامترهای RSI
    rsi_params[0].type = TYPE_INT; rsi_params[0].integer_value = m_settings.early_exit_rsi_period; // دوره RSI
    rsi_params[1].type = TYPE_INT; rsi_params[1].integer_value = PRICE_CLOSE; // نوع قیمت (بسته)
    m_rsi_exit_handle = IndicatorCreate(m_symbol, m_settings.ichimoku_timeframe, IND_RSI, 2, rsi_params); // ایجاد هندل
    
    // بررسی اعتبار تمام هندل‌ها
    if (m_ichimoku_handle == INVALID_HANDLE || m_atr_handle == INVALID_HANDLE || m_adx_handle == INVALID_HANDLE || m_rsi_exit_handle == INVALID_HANDLE) // چک هندل‌ها
    {
        Log("خطا در ایجاد یک یا چند اندیکاتور. لطفاً تنظیمات را بررسی کنید."); // لاگ خطا
        return false; // بازگشت شکست
    }

    // مقداردهی اولیه بافرها
    ArraySetAsSeries(m_tenkan_buffer, true); // تنظیم بافر تنکان به عنوان سری زمانی
    ArraySetAsSeries(m_kijun_buffer, true); // تنظیم بافر کیجون به عنوان سری زمانی
    ArraySetAsSeries(m_chikou_buffer, true); // تنظیم بافر چیکو به عنوان سری زمانی
    ArraySetAsSeries(m_high_buffer, true); // تنظیم بافر سقف به عنوان سری زمانی
    ArraySetAsSeries(m_low_buffer, true);  // تنظیم بافر کف به عنوان سری زمانی
    
    if (!m_visual_manager.Init()) // چک مقداردهی مدیر گرافیک
    {
        Log("خطا در مقداردهی اولیه VisualManager."); // لاگ خطا
        return false; // بازگشت شکست
    }

    if(m_symbol == _Symbol) // اگر نماد فعلی روی چارت است
    {
        m_visual_manager.InitDashboard(); // مقداردهی داشبورد
    }
    
    m_ltf_analyzer.Init(m_symbol, m_settings.ltf_timeframe); // مقداردهی تحلیلگر LTF
    
    m_grace_structure_analyzer.Init(m_symbol, m_settings.ichimoku_timeframe); // تحلیلگر مهلت روی تایم فریم اصلی 
    
    Log("با موفقیت مقداردهی اولیه شد."); // لاگ موفقیت
    return true; // بازگشت موفقیت
}

//+------------------------------------------------------------------+
//| تابع اصلی رویداد تایمر (هر ثانیه اجرا می‌شود)                  |
//+------------------------------------------------------------------+
void CStrategyManager::OnTimerTick()
{
    // واکسن: چک آماده بودن داده‌ها
    if (!IsDataReady()) return; // اگر داده آماده نیست، خروج

    // آپدیت تحلیلگر LTF اگر کندل جدید باشد
    bool is_new_ltf_bar = IsNewBar(m_settings.ltf_timeframe, m_last_bar_time_ltf); // چک کندل جدید LTF
    if (is_new_ltf_bar) // اگر کندل جدید
    {
        m_ltf_analyzer.ProcessNewBar();  // پردازش کندل جدید در تحلیلگر LTF
    }

    // جستجوی سیگنال فقط روی کندل جدید HTF
    bool is_new_htf_bar = IsNewBar(m_settings.ichimoku_timeframe, m_last_bar_time_htf); // چک کندل جدید HTF
    if (is_new_htf_bar) // اگر کندل جدید
    {
        m_grace_structure_analyzer.ProcessNewBar();  // پردازش کندل جدید در تحلیلگر مهلت

        ProcessSignalSearch();  // جستجوی سیگنال اولیه
    }

    // مدیریت سیگنال‌های فعال
    if (m_waiting_for_shift || m_waiting_for_pullback || m_is_waiting || ArraySize(m_potential_signals) > 0) // [MODIFIED] چک حالت‌های جدید
    {
        if (is_new_htf_bar || is_new_ltf_bar) // اگر رویداد جدید HTF یا LTF
        {
            ManageActiveSignal(is_new_htf_bar); // مدیریت سیگنال
        }
    }

    // چک خروج زودرس اگر فعال باشد
    if (is_new_htf_bar && m_settings.enable_early_exit) // اگر کندل جدید HTF و خروج زودرس فعال
    {
        CheckForEarlyExit(); // چک شرایط خروج
    }
}

//+------------------------------------------------------------------+
//| [MODIFIED] جستجوی سیگنال اولیه با معماری جدید "شکارچی"           |
//+------------------------------------------------------------------+
// IchimokuLogic.mqh

void CStrategyManager::ProcessSignalSearch()
{
    // اگر در هر یک از حالت‌های انتظار هستیم، به دنبال سیگنال جدید نگرد
    if (m_waiting_for_shift || m_waiting_for_pullback || m_is_waiting) return;

    // --- مسیر استراتژی 1: کراس سه‌گانه ---
    if (m_settings.primary_strategy == STRATEGY_TRIPLE_CROSS)
    {
        bool is_new_signal_buy = false;
        if (!CheckTripleCross(is_new_signal_buy)) return;

        Log("سیگنال اولیه HTF (Triple Cross) یافت شد: " + (is_new_signal_buy ? "خرید" : "فروش"));

        // ریست کامل متغیرهای حالت
        m_waiting_for_shift = false;
        m_waiting_for_pullback = false;
        m_is_waiting = false;
        
        m_signal.is_buy = is_new_signal_buy;
        m_signal.time = iTime(m_symbol, m_settings.ichimoku_timeframe, m_settings.chikou_period);
        m_signal.grace_candle_count = 0;

        // معماری جدید "خلبان": چک فوری ساختار LTF
        if (m_settings.entry_confirmation_mode == CONFIRM_LOWER_TIMEFRAME)
        {
            int found_at_bar = -1;
            bool has_existing_mss = m_ltf_analyzer.ScanPastForMSS(is_new_signal_buy, m_settings.structure_lookback_bars, found_at_bar);

            if (has_existing_mss)
            {
                m_waiting_for_pullback = true;
                Log("ساختار LTF هم‌جهت است. ورود به فاز انتظار برای پولبک.");
            }
            else
            {
                m_waiting_for_shift = true;
                Log("ساختار LTF هم‌جهت نیست. ورود به فاز انتظار برای تغییر ساختار (MSS).");
            }
            
            m_signal.invalidation_level = m_signal.is_buy ? m_ltf_analyzer.GetSecondLastSwingLow() : m_ltf_analyzer.GetSecondLastSwingHigh();
            Log("سطح ابطال (Grandfather) در LTF تنظیم شد: " + DoubleToString(m_signal.invalidation_level, _Digits));
        }
        // معماری قدیمی: تاییدیه در تایم جاری
        else
        {
            if (m_settings.signal_mode == MODE_REPLACE_SIGNAL)
            {
                m_is_waiting = true;
                if (m_settings.grace_period_mode == GRACE_BY_STRUCTURE)
                {
                    m_signal.invalidation_level = is_new_signal_buy ? m_grace_structure_analyzer.GetLastSwingLow() : m_grace_structure_analyzer.GetLastSwingHigh();
                }
            }
            else // MODE_SIGNAL_CONTEST
            {
                AddOrUpdatePotentialSignal(is_new_signal_buy);
            }
        }

        if(m_symbol == _Symbol && m_visual_manager != NULL) 
            m_visual_manager.DrawTripleCrossRectangle(is_new_signal_buy, m_settings.chikou_period);
    }
    // --- مسیر استراتژی 2: MKM ---
    else if (m_settings.primary_strategy == STRATEGY_KUMO_MTL)
    {
        // فیلتر روند کلان در HTF 
        int htf_ichi_handle = iIchimoku(m_symbol, m_settings.ichimoku_timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period);
        if (htf_ichi_handle == INVALID_HANDLE) return;

        double senkou_a[1], senkou_b[1];
        if(CopyBuffer(htf_ichi_handle, 2, 0, 1, senkou_a) < 1 || CopyBuffer(htf_ichi_handle, 3, 0, 1, senkou_b) < 1)
        {
            IndicatorRelease(htf_ichi_handle);
            return;
        }
        IndicatorRelease(htf_ichi_handle);

        double high_kumo = MathMax(senkou_a[0], senkou_b[0]);
        double low_kumo = MathMin(senkou_a[0], senkou_b[0]);
        double close_price = iClose(m_symbol, m_settings.ichimoku_timeframe, 1); // Use close of last bar for stability

        bool is_buy_trend = (close_price > high_kumo);
        bool is_sell_trend = (close_price < low_kumo);

        if (is_buy_trend || is_sell_trend)
        {
            m_signal.is_buy = is_buy_trend;
            m_signal.time = TimeCurrent();
            Log("روند کلان MKM " + (m_signal.is_buy ? "صعودی" : "نزولی") + " است. ورود به حالت انتظار برای تاییدیه LTF...");

            int found_bar = -1;
            bool has_existing_mss = m_ltf_analyzer.ScanPastForMSS(m_signal.is_buy, m_settings.structure_lookback_bars, found_bar);
            if (has_existing_mss)
            {
                m_waiting_for_pullback = true;
            }
            else
            {
                m_waiting_for_shift = true;
            }

            if (m_settings.grace_period_mode == GRACE_BY_STRUCTURE)
            {
                m_signal.invalidation_level = m_signal.is_buy ? m_ltf_analyzer.GetSecondLastSwingLow() : m_ltf_analyzer.GetSecondLastSwingHigh();
            }
        }
    }
}



//+------------------------------------------------------------------+
//| مدیریت سیگنال‌های فعال با معماری حالت-محور (نسخه تاکتیکی)        |
//+------------------------------------------------------------------+
void CStrategyManager::ManageActiveSignal(bool is_new_htf_bar)
{
    // اگر در هیچ حالت انتظاری نیستیم، هیچ کاری برای انجام دادن وجود ندارد.
    if (!m_waiting_for_shift && !m_waiting_for_pullback && !m_is_waiting && ArraySize(m_potential_signals) == 0) return;

    // چک می‌کنیم آیا کندل جدید در تایم فریم پایین (LTF) داریم یا نه
    bool is_new_ltf_bar = IsNewBar(m_settings.ltf_timeframe, m_last_bar_time_ltf);

    // --- بخش ۱: اجرای معماری "خلبان" با تاکتیک‌های ورودی متفاوت ---
    if (m_settings.entry_confirmation_mode == CONFIRM_LOWER_TIMEFRAME && (m_waiting_for_shift || m_waiting_for_pullback))
    {
        // --- مدیریت انقضای سیگنال (خط قرمز یا قانون پدربزرگ) ---
        bool is_signal_expired = false;
        if (m_settings.grace_period_mode == GRACE_BY_CANDLES)
        {
            if (is_new_ltf_bar) m_signal.grace_candle_count++;
            if (m_signal.grace_candle_count >= m_settings.structural_grace_candles) is_signal_expired = true;
        }
        else // GRACE_BY_STRUCTURE (روش هوشمند)
        {
            double current_price_ltf = iClose(m_symbol, m_settings.ltf_timeframe, 1);
            if (m_signal.invalidation_level > 0 &&
               ((m_signal.is_buy && current_price_ltf < m_signal.invalidation_level) ||
               (!m_signal.is_buy && current_price_ltf > m_signal.invalidation_level)))
               is_signal_expired = true;
        }
        
        if (is_signal_expired)
        {
            Log("سیگنال به دلیل انقضا (شکست سطح ابطال یا تمام شدن کندل‌های مهلت) باطل شد.");
            m_waiting_for_shift = false;
            m_waiting_for_pullback = false;
            return;
        }

        // --- مدیریت حالت‌ها فقط در کندل جدید LTF ---
        if (is_new_ltf_bar)
        {
            // از تحلیلگر ساختار بازار گزارش جدید می‌گیریم
            SMssSignal ltf_signal = m_ltf_analyzer.ProcessNewBar();
            
            // اگر در فاز "انتظار برای تغییر ساختار" (MSS) هستیم
            if (m_waiting_for_shift)
            {
                if ((m_signal.is_buy && ltf_signal.type == MSS_SHIFT_UP) || (!m_signal.is_buy && ltf_signal.type == MSS_SHIFT_DOWN))
                {
                    Log("تغییر ساختار (MSS) در LTF تایید شد. ورود به فاز انتظار پولبک.");
                    m_waiting_for_shift = false;
                    m_waiting_for_pullback = true;
                }
            }
            // اگر در فاز "انتظار برای پولبک" هستیم
            else if (m_waiting_for_pullback)
            {
                // ================== دوراهی تاکتیک ورود: کاربر کدام روش را انتخاب کرده؟ ==================
                if(m_settings.entry_tactic == TACTIC_CONFIRMATION)
                {
                    // تاکتیک ۱: ورود بر اساس تایید (منطق قبلی و محافظه‌کارانه)
                    // منتظر می‌مانیم تا یک سوینگ لو (برای خرید) یا سوینگ های (برای فروش) به طور کامل تایید شود
                    if (ltf_signal.new_swing_formed && (m_signal.is_buy != ltf_signal.is_swing_high))
                    {
                        Log("تاکتیک تایید: پولبک (تشکیل سوینگ مخالف) در LTF تایید شد. آماده برای ورود Market.");
                        if(AreAllFiltersPassed(m_signal.is_buy))
                        {
                            OpenTrade(m_signal.is_buy);
                        }
                        // ریست کامل حالت‌ها پس از تلاش برای ورود
                        m_waiting_for_shift = false;
                        m_waiting_for_pullback = false;
                    }
                }
                else // TACTIC_PREDICTIVE
                {
                    // تاکتیک ۲: ورود پیش‌بینی با لیمیت اردر (منطق جدید و تهاجمی)
                    // به جای انتظار برای تایید، تلاش می‌کنیم یک سفارش لیمیت در محل احتمالی پایان پولبک قرار دهیم
                    Log("تاکتیک پیش‌بینی: جستجو برای محل مناسب لیمیت اردر...");
                    if(PlaceLimitOrder(m_signal.is_buy))
                    {
                        // اگر سفارش با موفقیت گذاشته شد، از حالت انتظار خارج می‌شویم
                        m_waiting_for_shift = false;
                        m_waiting_for_pullback = false;
                    }
                }
                // ======================================================================================
            }
        }
    }
    // --- بخش ۲: اجرای معماری قدیمی (برای سازگاری با تنظیمات قبلی) ---
    else if (m_settings.entry_confirmation_mode == CONFIRM_CURRENT_TIMEFRAME)
    {
        // (این بخش بدون تغییر باقی می‌ماند)
        // منطق برای حالت MODE_REPLACE_SIGNAL
        if (m_settings.signal_mode == MODE_REPLACE_SIGNAL && m_is_waiting)
        {
            bool is_signal_expired = false;
            if (is_new_htf_bar && m_settings.grace_period_mode == GRACE_BY_CANDLES)
            {
                m_signal.grace_candle_count++;
                if (m_signal.grace_candle_count >= m_settings.grace_period_candles) is_signal_expired = true;
            }
            else if (m_settings.grace_period_mode == GRACE_BY_STRUCTURE)
            {
                double current_price = iClose(m_symbol, m_settings.ichimoku_timeframe, 1);
                if (m_signal.invalidation_level > 0 &&
                   ((m_signal.is_buy && current_price < m_signal.invalidation_level) ||
                   (!m_signal.is_buy && current_price > m_signal.invalidation_level)))
                   is_signal_expired = true;
            }

            if (is_signal_expired) { m_is_waiting = false; }
            else if (CheckFinalConfirmation(m_signal.is_buy))
            {
                if (AreAllFiltersPassed(m_signal.is_buy)) { OpenTrade(m_signal.is_buy); }
                m_is_waiting = false;
            }
        }
        // منطق برای حالت MODE_SIGNAL_CONTEST
        else if (m_settings.signal_mode == MODE_SIGNAL_CONTEST && ArraySize(m_potential_signals) > 0)
        {
             for (int i = ArraySize(m_potential_signals) - 1; i >= 0; i--)
             {
                bool is_signal_expired = false;
                if (m_settings.grace_period_mode == GRACE_BY_CANDLES && is_new_htf_bar)
                {
                    m_potential_signals[i].grace_candle_count++;
                    if (m_potential_signals[i].grace_candle_count >= m_settings.grace_period_candles)
                        is_signal_expired = true;
                }
                else if (m_settings.grace_period_mode == GRACE_BY_STRUCTURE)
                {
                    double current_price = iClose(m_symbol, m_settings.ichimoku_timeframe, 1);
                     if (m_potential_signals[i].invalidation_level > 0 &&
                        ((m_potential_signals[i].is_buy && current_price < m_potential_signals[i].invalidation_level) ||
                         (!m_potential_signals[i].is_buy && current_price > m_potential_signals[i].invalidation_level)))
                         is_signal_expired = true;
                }

                if(is_signal_expired)
                {
                    ArrayRemove(m_potential_signals, i, 1);
                    continue;
                }

                if(CheckFinalConfirmation(m_potential_signals[i].is_buy) && AreAllFiltersPassed(m_potential_signals[i].is_buy))
                {
                    OpenTrade(m_potential_signals[i].is_buy);
                    bool winner_is_buy = m_potential_signals[i].is_buy;
                    for (int j = ArraySize(m_potential_signals) - 1; j >= 0; j--)
                    {
                        if (m_potential_signals[j].is_buy == winner_is_buy)
                            ArrayRemove(m_potential_signals, j, 1);
                    }
                    return;
                }
             }
        }
    }



    // مسیر MKM
    else if (m_settings.primary_strategy == STRATEGY_KUMO_MTL)
    {
        if (!m_waiting_for_shift && !m_waiting_for_pullback) return; // اگر منتظر نیست، خروج

        ENUM_TIMEFRAMES ltf = m_settings.ltf_timeframe; // تایم LTF
        bool is_buy = m_signal.is_buy; // نوع سیگنال

        // فیلتر مومنتوم
        double slope_threshold = 0.0; // آستانه شیب
        double slope = CalculateKijunSlope(ltf, m_settings.mkm_kijun_slope_period, slope_threshold); // [MODIFIED] استفاده از تنظیم جدید
        bool momentum_ok = is_buy ? (slope > slope_threshold) : (slope < -slope_threshold); // چک مومنتوم

        // فیلتر نوسان
        bool volatility_ok = IsKumoExpanding(ltf, m_settings.mkm_kumo_expansion_period); // [MODIFIED] استفاده از تنظیم جدید (فرض بر تعریف ورودی جدید)

        // تایید ساختاری
        bool structure_ok = IsChikouInOpenSpace(is_buy, ltf); // چک فضای چیکو

        // ماشه ورود: بونس کیجون
        bool trigger_ok = false; // فلگ ماشه
        int ltf_ichi_handle = iIchimoku(m_symbol, ltf, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period); // هندل LTF
        if (ltf_ichi_handle != INVALID_HANDLE) // چک هندل
        {
            double kijun_buffer[1]; // بافر کیجون
            CopyBuffer(ltf_ichi_handle, 1, 1, 1, kijun_buffer); // کپی کیجون شیفت 1
            double kijun = kijun_buffer[0]; // مقدار کیجون
            IndicatorRelease(ltf_ichi_handle); // آزاد هندل

            if (is_buy && iLow(m_symbol, ltf, 1) <= kijun && iClose(m_symbol, ltf, 1) > kijun) // چک بونس خرید
                trigger_ok = true;
            if (!is_buy && iHigh(m_symbol, ltf, 1) >= kijun && iClose(m_symbol, ltf, 1) < kijun) // چک بونس فروش
                trigger_ok = true;
        }

        if (momentum_ok && volatility_ok && structure_ok && trigger_ok) // اگر تمام شرایط
        {
            Log("تمام شرایط MKM برای " + (is_buy ? "خرید" : "فروش") + " فراهم شد."); // لاگ
            if(AreAllFiltersPassed(is_buy)) // چک فیلترها
            {
                OpenTrade(is_buy); // باز کردن
            }
            m_waiting_for_shift = false; // ریست
            m_waiting_for_pullback = false; // ریست
        }
    }
}

//+------------------------------------------------------------------+
//| چک کراس سه‌گانه (Triple Cross) - بهبود: تلرانس برای Chikou اضافه شد|
//+------------------------------------------------------------------+
bool CStrategyManager::CheckTripleCross(bool& is_buy)
{
    int shift = m_settings.chikou_period; // شیفت مرجع چیکو
    if (iBars(m_symbol, _Period) < shift + 2) return false; // چک تعداد بارها

    double tk_shifted[], ks_shifted[]; // بافرهای شیفت شده
    if(CopyBuffer(m_ichimoku_handle, 0, shift, 2, tk_shifted) < 2 || 
       CopyBuffer(m_ichimoku_handle, 1, shift, 2, ks_shifted) < 2)
    {
       return false; // اگر داده کافی نبود
    }
       
    double tenkan_at_shift = tk_shifted[0]; // تنکان در شیفت
    double kijun_at_shift = ks_shifted[0]; // کیجون در شیفت
    double tenkan_prev_shift = tk_shifted[1]; // تنکان قبلی
    double kijun_prev_shift = ks_shifted[1]; // کیجون قبلی

    bool is_cross_up = tenkan_prev_shift < kijun_prev_shift && tenkan_at_shift > kijun_at_shift; // کراس صعودی
    bool is_cross_down = tenkan_prev_shift > kijun_prev_shift && tenkan_at_shift < kijun_at_shift; // کراس نزولی
    bool is_tk_cross = is_cross_up || is_cross_down; // وجود کراس

    double tolerance = GetTalaqiTolerance(shift); // تلرانس تلاقی
    bool is_confluence = (tolerance > 0) ? (MathAbs(tenkan_at_shift - kijun_at_shift) <= tolerance) : false; // چک تلاقی

    if (!is_tk_cross && !is_confluence) // اگر نه کراس و نه تلاقی
    {
        return false; // بدون سیگنال
    }

    double chikou_now  = iClose(m_symbol, m_settings.ichimoku_timeframe, 1); // چیکو فعلی
    double chikou_prev = iClose(m_symbol, m_settings.ichimoku_timeframe, 2);  // چیکو قبلی

    double upper_line = MathMax(tenkan_at_shift, kijun_at_shift); // خط بالا
    double lower_line = MathMin(tenkan_at_shift, kijun_at_shift); // خط پایین

    // بهبود: تلرانس کوچک برای Chikou (نصف تلرانس TK) برای جلوگیری از نویز
    double chikou_tolerance = tolerance * 0.5; // تلرانس Chikou (پیشنهاد تست شده)

    bool chikou_crosses_up = (chikou_now > upper_line - chikou_tolerance) && (chikou_prev < upper_line + chikou_tolerance); // کراس صعودی با تلرانس
    if (chikou_crosses_up) // اگر صعودی
    {
        is_buy = true; // تنظیم خرید
        return true;  // موفقیت
    }

    bool chikou_crosses_down = (chikou_now < lower_line + chikou_tolerance) && (chikou_prev > lower_line - chikou_tolerance); // کراس نزولی با تلرانس
    if (chikou_crosses_down) // اگر نزولی
    {
        is_buy = false; // تنظیم فروش
        return true;  // موفقیت
    }

    return false;  // بدون سیگنال
}

//+------------------------------------------------------------------+
//| چک تایید نهایی ورود                                              |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckFinalConfirmation(bool is_buy)
{
    switch(m_settings.entry_confirmation_mode) // سوئیچ بر اساس حالت تایید
    {
        case CONFIRM_LOWER_TIMEFRAME: // حالت LTF
            return CheckLowerTfConfirmation(is_buy); // چک LTF

        case CONFIRM_CURRENT_TIMEFRAME: // حالت فعلی
        {
            if (iBars(m_symbol, m_settings.ichimoku_timeframe) < 2) return false; // چک بارها

            CopyBuffer(m_ichimoku_handle, 0, 1, 1, m_tenkan_buffer); // کپی تنکان
            CopyBuffer(m_ichimoku_handle, 1, 1, 1, m_kijun_buffer); // کپی کیجون

            double tenkan_at_1 = m_tenkan_buffer[0]; // تنکان شیفت 1
            double kijun_at_1 = m_kijun_buffer[0]; // کیجون شیفت 1
            double open_at_1 = iOpen(m_symbol, m_settings.ichimoku_timeframe, 1); // باز شیفت 1
            double close_at_1 = iClose(m_symbol, m_settings.ichimoku_timeframe, 1); // بسته شیفت 1

            if (is_buy) // برای خرید
            {
                if (tenkan_at_1 <= kijun_at_1) return false; // چک تنکان بالای کیجون
                if (m_settings.confirmation_type == MODE_OPEN_AND_CLOSE) { // چک باز و بسته
                    if (open_at_1 > tenkan_at_1 && open_at_1 > kijun_at_1 && close_at_1 > tenkan_at_1 && close_at_1 > kijun_at_1)
                        return true; // تایید
                } else { // چک بسته
                    if (close_at_1 > tenkan_at_1 && close_at_1 > kijun_at_1)
                        return true; // تایید
                }
            }
            else // برای فروش
            {
                if (tenkan_at_1 >= kijun_at_1) return false; // چک تنکان پایین کیجون
                if (m_settings.confirmation_type == MODE_OPEN_AND_CLOSE) { // چک باز و بسته
                    if (open_at_1 < tenkan_at_1 && open_at_1 < kijun_at_1 && close_at_1 < tenkan_at_1 && close_at_1 < kijun_at_1)
                        return true; // تایید
                } else { // چک بسته
                    if (close_at_1 < tenkan_at_1 && close_at_1 < kijun_at_1)
                        return true; // تایید
                }
            }
            return false; // عدم تایید
        }
    }
    return false; // پیش‌فرض عدم تایید
}


//+------------------------------------------------------------------+
//| [جدید] قرار دادن سفارش لیمیت بر اساس تاکتیک پیش‌بینی            |
//+------------------------------------------------------------------+
bool CStrategyManager::PlaceLimitOrder(bool is_buy)
{
    // ۱. گرفتن قیمت کیجون‌سن در تایم فریم پایین به عنوان هدف پولبک
    int ltf_ichi_handle = iIchimoku(m_symbol, m_settings.ltf_timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period);
    if(ltf_ichi_handle == INVALID_HANDLE) return false;

    double kijun_buffer[1];
    if(CopyBuffer(ltf_ichi_handle, 1, 1, 1, kijun_buffer) < 1)
    {
        IndicatorRelease(ltf_ichi_handle);
        return false;
    }
    IndicatorRelease(ltf_ichi_handle);
    double limit_price = kijun_buffer[0];

    // ۲. بررسی منطقی بودن قیمت لیمیت
    // سفارش خرید لیمیت باید پایین‌تر از قیمت فعلی بازار باشد
    if(is_buy && limit_price >= SymbolInfoDouble(m_symbol, SYMBOL_ASK))
    {
        Log("قیمت لیمیت خرید ("+DoubleToString(limit_price, _Digits)+") بالاتر از قیمت فعلی Ask است. سفارش قرار داده نشد.");
        return false;
    }
    // سفارش فروش لیمیت باید بالاتر از قیمت فعلی بازار باشد
    if(!is_buy && limit_price <= SymbolInfoDouble(m_symbol, SYMBOL_BID))
    {
        Log("قیمت لیمیت فروش ("+DoubleToString(limit_price, _Digits)+") پایین‌تر از قیمت فعلی Bid است. سفارش قرار داده نشد.");
        return false;
    }

    // ۳. چک کردن تمام فیلترهای اصلی (کومو، ATR، ADX و...)
    if(!AreAllFiltersPassed(is_buy))
    {
        Log("فیلترها برای قرار دادن لیمیت اردر رد شدند.");
        return false; // هنوز شرایط برای سفارش‌گذاری مناسب نیست
    }
    
    // ۴. محاسبه استاپ لاس بر اساس ساختار (قانون پدربزرگ)
    // ما از سطح ابطال سیگنال که قبلاً مشخص شده به عنوان نقطه مرجع استاپ استفاده می‌کنیم
    double sl = m_signal.invalidation_level;
    if(sl <= 0) 
    {
        Log("خطا: سطح ابطال برای محاسبه استاپ لاس لیمیت اردر نامعتبر است.");
        return false;
    }

    // ۵. محاسبه دقیق حجم معامله و حد سود (کپی شده از منطق OpenTrade برای ثبات)
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double risk_amount = balance * (m_settings.risk_percent_per_trade / 100.0);
    double loss_for_one_lot = 0;

    // توجه: محاسبه سود/ضرر برای لیمیت اردر باید بر اساس قیمت لیمیت و استاپ لاس انجام شود
    if(!OrderCalcProfit(is_buy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL, m_symbol, 1.0, limit_price, sl, loss_for_one_lot))
    {
        Log("خطا در محاسبه سود/زیان برای لیمیت اردر. کد خطا: " + (string)GetLastError());
        return false;
    }
    loss_for_one_lot = MathAbs(loss_for_one_lot);
    if(loss_for_one_lot <= 0)
    {
        Log("میزان ضرر محاسبه شده برای لیمیت اردر معتبر نیست.");
        return false;
    }
    
    double lot_size = NormalizeDouble(risk_amount / loss_for_one_lot, 2);
    double min_lot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MIN);
    double max_lot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MAX);
    double lot_step = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_STEP);
    lot_size = MathMax(min_lot, MathMin(max_lot, lot_size));
    lot_size = MathRound(lot_size / lot_step) * lot_step;

    if(lot_size < min_lot)
    {
        Log("حجم محاسبه شده برای لیمیت اردر کمتر از حد مجاز است.");
        return false;
    }
    
    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT);
    double sl_distance_points = MathAbs(limit_price - sl) / point;
    double tp_distance_points = sl_distance_points * m_settings.take_profit_ratio;
    double tp = is_buy ? limit_price + tp_distance_points * point : limit_price - tp_distance_points * point;
    
    int digits = (int)SymbolInfoInteger(m_symbol, SYMBOL_DIGITS);
    sl = NormalizeDouble(sl, digits);
    tp = NormalizeDouble(tp, digits);
    limit_price = NormalizeDouble(limit_price, digits);
    
    // ۶. تنظیم زمان انقضای سفارش (مثلاً ۵ کندل تایم پایین)
    datetime expiration = TimeCurrent() + 5 * (datetime)PeriodSeconds(m_settings.ltf_timeframe);

    // ۷. قرار دادن سفارش لیمیت
    string comment = "Memento Predictive";
    if(is_buy)
    {
        m_trade.BuyLimit(lot_size, limit_price, m_symbol, sl, tp, ORDER_TIME_SPECIFIED, expiration, comment);
    }
    else
    {
        m_trade.SellLimit(lot_size, limit_price, m_symbol, sl, tp, ORDER_TIME_SPECIFIED, expiration, comment);
    }
    
    Log("سفارش لیمیت " + (is_buy ? "خرید" : "فروش") + " در قیمت " + DoubleToString(limit_price, _Digits) + " با موفقیت قرار داده شد. حجم: " + DoubleToString(lot_size,2));
    return true; // به نشانه موفقیت در قرار دادن سفارش
}





//+------------------------------------------------------------------+
//| محاسبه سطح استاپ لاس                                             |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateStopLoss(bool is_buy, double entry_price)
{
    ENUM_TIMEFRAMES sl_tf = (m_settings.sl_timeframe == PERIOD_CURRENT) ? _Period : m_settings.sl_timeframe; // تعیین تایم SL
    if (m_settings.stoploss_type == MODE_SIMPLE) // حالت ساده
    {
        double buffer = m_settings.sl_buffer_multiplier * SymbolInfoDouble(m_symbol, SYMBOL_POINT); // بافر
        return FindBackupStopLoss(is_buy, buffer, sl_tf); // محاسبه پشتیبان
    }
    if (m_settings.stoploss_type == MODE_ATR) // حالت ATR
    {
        double sl_price = CalculateAtrStopLoss(is_buy, entry_price, sl_tf); // محاسبه ATR
        if (sl_price == 0) // اگر شکست
        {
            Log("محاسبه ATR SL با خطا مواجه شد. استفاده از روش پشتیبان..."); // لاگ
            double buffer = m_settings.sl_buffer_multiplier * SymbolInfoDouble(m_symbol, SYMBOL_POINT); // بافر
            return FindBackupStopLoss(is_buy, buffer, sl_tf); // پشتیبان
        }
        return sl_price; // بازگشت SL
    }
    if (m_settings.stoploss_type == MODE_STRUCTURE) // [NEW] حالت ساختاری
    {
        double sl_price = CalculateStructuralStopLoss(is_buy, entry_price); // محاسبه ساختاری
        if (sl_price == 0) // اگر شکست
        {
            Log("محاسبه Structural SL با خطا مواجه شد. استفاده از روش پشتیبان..."); // لاگ
            double buffer = m_settings.sl_buffer_multiplier * SymbolInfoDouble(m_symbol, SYMBOL_POINT); // بافر
            return FindBackupStopLoss(is_buy, buffer, sl_tf); // پشتیبان
        }
        return sl_price; // بازگشت SL
    }

    // حالت پیچیده (بهینه)
    Log("شروع فرآیند انتخاب استاپ لاس بهینه..."); // لاگ شروع
    double candidates[]; // آرایه کاندیداها
    int count = 0; // شمارنده
    double sl_candidate = 0; // کاندیدای موقت
    double buffer = m_settings.sl_buffer_multiplier * SymbolInfoDouble(m_symbol, SYMBOL_POINT); // بافر
    
    sl_candidate = FindFlatKijun(sl_tf); // کاندیدای کیجون فلت
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1); // تغییر اندازه
        candidates[count] = is_buy ? sl_candidate - buffer : sl_candidate + buffer; // تنظیم با بافر
        count++; // افزایش
    }
    
    sl_candidate = FindPivotKijun(is_buy, sl_tf); // کاندیدای پیوت کیجون
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1); // تغییر اندازه
        candidates[count] = is_buy ? sl_candidate - buffer : sl_candidate + buffer; // تنظیم
        count++; // افزایش
    }

    sl_candidate = FindPivotTenkan(is_buy, sl_tf); // کاندیدای پیوت تنکان
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1); // تغییر اندازه
        candidates[count] = is_buy ? sl_candidate - buffer : sl_candidate + buffer; // تنظیم
        count++; // افزایش
    }

    sl_candidate = FindBackupStopLoss(is_buy, buffer, sl_tf); // کاندیدای ساده
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1); // تغییر اندازه
        candidates[count] = sl_candidate; // اضافه
        count++; // افزایش
    }
    
    sl_candidate = CalculateAtrStopLoss(is_buy, entry_price, sl_tf); // کاندیدای ATR
    if (sl_candidate > 0) {
        ArrayResize(candidates, count + 1); // تغییر اندازه
        candidates[count] = sl_candidate; // اضافه
        count++; // افزایش
    }

    if (count == 0) // اگر هیچ کاندیدا
    {
        Log("خطا: هیچ کاندیدای اولیه‌ای برای استاپ لاس پیدا نشد."); // لاگ
        return 0.0; // صفر
    }

    // اعتبارسنجی کاندیداها
    double valid_candidates[]; // آرایه معتبرها
    int valid_count = 0; // شمارنده معتبر
    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT); // پوینت نماد
    double spread = (double)SymbolInfoInteger(m_symbol, SYMBOL_SPREAD) * point; // اسپرد
    double min_safe_distance = spread + buffer;  // حداقل فاصله ایمن

    for (int i = 0; i < count; i++) // حلقه اعتبارسنجی
    {
        double current_sl = candidates[i]; // SL فعلی
        
        if ((is_buy && current_sl >= entry_price) || (!is_buy && current_sl <= entry_price)) // چک موقعیت نامعتبر
        {
            continue;  // رد کاندیدا
        }

        if (MathAbs(entry_price - current_sl) < min_safe_distance) // چک فاصله کم
        {
            current_sl = is_buy ? entry_price - min_safe_distance : entry_price + min_safe_distance; // اصلاح SL
            Log("کاندیدای شماره " + (string)(i+1) + " به دلیل نزدیکی بیش از حد به قیمت " + DoubleToString(current_sl, _Digits) + " اصلاح شد."); // لاگ
        }

        ArrayResize(valid_candidates, valid_count + 1); // تغییر اندازه
        valid_candidates[valid_count] = current_sl; // اضافه به معتبرها
        valid_count++; // افزایش
    }

    if (valid_count == 0) // اگر هیچ معتبر
    {
        Log("خطا: پس از فیلترینگ، هیچ کاندیدای معتبری برای استاپ لاس باقی نماند."); // لاگ
        return 0.0; // صفر
    }
    
    // انتخاب نزدیک‌ترین معتبر
    double best_sl_price = 0.0; // بهترین SL
    double smallest_distance = DBL_MAX; // حداقل فاصله اولیه

    for (int i = 0; i < valid_count; i++) // حلقه انتخاب
    {
        double distance = MathAbs(entry_price - valid_candidates[i]); // فاصله
        if (distance < smallest_distance) // اگر کوچکتر
        {
            smallest_distance = distance; // آپدیت حداقل
            best_sl_price = valid_candidates[i]; // بهترین
        }
    }

    Log("✅ استاپ لاس بهینه پیدا شد: " + DoubleToString(best_sl_price, _Digits) + ". فاصله: " + DoubleToString(smallest_distance / point, 1) + " پوینت."); // لاگ موفقیت

    return best_sl_price; // بازگشت بهترین SL
}

//+------------------------------------------------------------------+
//| محاسبه SL پشتیبان بر اساس کندل مخالف                             |
//+------------------------------------------------------------------+
double CStrategyManager::FindBackupStopLoss(bool is_buy, double buffer, ENUM_TIMEFRAMES timeframe)
{
    int bars_to_check = m_settings.sl_lookback_period; // تعداد بار برای چک
    if (iBars(m_symbol, timeframe) < bars_to_check + 1) return 0; // چک تعداد بارها
    
    for (int i = 1; i <= bars_to_check; i++) // حلقه به عقب
    {
        bool is_candle_bullish = (iClose(m_symbol, timeframe, i) > iOpen(m_symbol, timeframe, i)); // چک صعودی
        bool is_candle_bearish = (iClose(m_symbol, timeframe, i) < iOpen(m_symbol, timeframe, i)); // چک نزولی

        if (is_buy) // برای خرید
        {
            if (is_candle_bearish) // اگر نزولی پیدا شد
            {
                double sl_price = iLow(m_symbol, timeframe, i) - buffer; // SL زیر کف
                Log("استاپ لاس ساده: اولین کندل نزولی در شیفت " + (string)i + " پیدا شد."); // لاگ
                return sl_price; // بازگشت
            }
        }
        else // برای فروش
        {
            if (is_candle_bullish) // اگر صعودی پیدا شد
            {
                double sl_price = iHigh(m_symbol, timeframe, i) + buffer; // SL بالای سقف
                Log("استاپ لاس ساده: اولین کندل صعودی در شیفت " + (string)i + " پیدا شد."); // لاگ
                return sl_price; // بازگشت
            }
        }
    }
    
    // پشتیبان اگر مخالف پیدا نشد
    Log("هیچ کندل رنگ مخالفی برای استاپ لاس ساده پیدا نشد. از روش سقف/کف مطلق استفاده می‌شود."); // لاگ
    CopyHigh(m_symbol, timeframe, 1, bars_to_check, m_high_buffer); // کپی سقف‌ها
    CopyLow(m_symbol, timeframe, 1, bars_to_check, m_low_buffer); // کپی کف‌ها

    if(is_buy) // برای خرید
    {
       int min_index = ArrayMinimum(m_low_buffer, 0, bars_to_check); // حداقل کف
       return m_low_buffer[min_index] - buffer; // بازگشت با بافر
    }
    else // برای فروش
    {
       int max_index = ArrayMaximum(m_high_buffer, 0, bars_to_check); // حداکثر سقف
       return m_high_buffer[max_index] + buffer; // بازگشت با بافر
    }
}

//+------------------------------------------------------------------+
//| پیدا کردن کیجون فلت                                              |
//+------------------------------------------------------------------+
double CStrategyManager::FindFlatKijun(ENUM_TIMEFRAMES timeframe)
{
    int kijun_handle = m_ichimoku_handle; // هندل پیش‌فرض
    if (timeframe != m_settings.ichimoku_timeframe) // اگر متفاوت
    {
        MqlParam params[3]; // پارامترها
        params[0].type = TYPE_INT; params[0].integer_value = m_settings.tenkan_period;
        params[1].type = TYPE_INT; params[1].integer_value = m_settings.kijun_period;
        params[2].type = TYPE_INT; params[2].integer_value = m_settings.senkou_period;
        kijun_handle = IndicatorCreate(m_symbol, timeframe, IND_ICHIMOKU, 3, params); // موقت
        if (kijun_handle == INVALID_HANDLE) return 0.0; // شکست
    }

    double kijun_values[]; // آرایه کیجون
    if (CopyBuffer(kijun_handle, 1, 1, m_settings.flat_kijun_period, kijun_values) < m_settings.flat_kijun_period) // کپی
    {
        if (kijun_handle != m_ichimoku_handle) IndicatorRelease(kijun_handle); // آزاد
        return 0.0; // صفر
    }

    ArraySetAsSeries(kijun_values, true); // تنظیم سری

    int flat_count = 1; // شمارنده فلت
    for (int i = 1; i < m_settings.flat_kijun_period; i++) // حلقه چک فلت
    {
        if (kijun_values[i] == kijun_values[i - 1]) // اگر برابر
        {
            flat_count++; // افزایش
            if (flat_count >= m_settings.flat_kijun_min_length) // اگر حداقل طول
            {
                if (kijun_handle != m_ichimoku_handle) IndicatorRelease(kijun_handle); // آزاد
                return kijun_values[i]; // بازگشت سطح فلت
            }
        }
        else // ریست فلت
        {
            flat_count = 1; // ریست
        }
    }

    if (kijun_handle != m_ichimoku_handle) IndicatorRelease(kijun_handle); // آزاد نهایی
    return 0.0; // هیچ فلت
}

//+------------------------------------------------------------------+
//| پیدا کردن پیوت روی کیجون                                         |
//+------------------------------------------------------------------+
double CStrategyManager::FindPivotKijun(bool is_buy, ENUM_TIMEFRAMES timeframe)
{
    int kijun_handle = m_ichimoku_handle; // پیش‌فرض
    if (timeframe != m_settings.ichimoku_timeframe) // متفاوت
    {
        MqlParam params[3]; // پارامترها
        params[0].type = TYPE_INT; params[0].integer_value = m_settings.tenkan_period;
        params[1].type = TYPE_INT; params[1].integer_value = m_settings.kijun_period;
        params[2].type = TYPE_INT; params[2].integer_value = m_settings.senkou_period;
        kijun_handle = IndicatorCreate(m_symbol, timeframe, IND_ICHIMOKU, 3, params); // موقت
        if (kijun_handle == INVALID_HANDLE) return 0.0; // شکست
    }

    double kijun_values[]; // آرایه
    if (CopyBuffer(kijun_handle, 1, 1, m_settings.pivot_lookback, kijun_values) < m_settings.pivot_lookback) // کپی
    {
        if (kijun_handle != m_ichimoku_handle) IndicatorRelease(kijun_handle); // آزاد
        return 0.0; // صفر
    }

    ArraySetAsSeries(kijun_values, true); // سری

    for (int i = 1; i < m_settings.pivot_lookback - 1; i++) // حلقه پیوت
    {
        if (is_buy && kijun_values[i] < kijun_values[i - 1] && kijun_values[i] < kijun_values[i + 1]) // دره برای خرید
        {
            if (kijun_handle != m_ichimoku_handle) IndicatorRelease(kijun_handle); // آزاد
            return kijun_values[i]; // بازگشت
        }
        if (!is_buy && kijun_values[i] > kijun_values[i - 1] && kijun_values[i] > kijun_values[i + 1]) // قله برای فروش
        {
            if (kijun_handle != m_ichimoku_handle) IndicatorRelease(kijun_handle); // آزاد
            return kijun_values[i]; // بازگشت
        }
    }

    if (kijun_handle != m_ichimoku_handle) IndicatorRelease(kijun_handle); // آزاد نهایی
    return 0.0; // هیچ پیوت
}

//+------------------------------------------------------------------+
//| پیدا کردن پیوت روی تنکان                                         |
//+------------------------------------------------------------------+
double CStrategyManager::FindPivotTenkan(bool is_buy, ENUM_TIMEFRAMES timeframe)
{
    int tenkan_handle = m_ichimoku_handle; // پیش‌فرض
    if (timeframe != m_settings.ichimoku_timeframe) // متفاوت
    {
        MqlParam params[3]; // پارامترها
        params[0].type = TYPE_INT; params[0].integer_value = m_settings.tenkan_period;
        params[1].type = TYPE_INT; params[1].integer_value = m_settings.kijun_period;
        params[2].type = TYPE_INT; params[2].integer_value = m_settings.senkou_period;
        tenkan_handle = IndicatorCreate(m_symbol, timeframe, IND_ICHIMOKU, 3, params); // موقت
        if (tenkan_handle == INVALID_HANDLE) return 0.0; // شکست
    }

    double tenkan_values[]; // آرایه
    if (CopyBuffer(tenkan_handle, 0, 1, m_settings.pivot_lookback, tenkan_values) < m_settings.pivot_lookback) // کپی
    {
        if (tenkan_handle != m_ichimoku_handle) IndicatorRelease(tenkan_handle); // آزاد
        return 0.0; // صفر
    }

    ArraySetAsSeries(tenkan_values, true); // سری

    for (int i = 1; i < m_settings.pivot_lookback - 1; i++) // حلقه پیوت
    {
        if (is_buy && tenkan_values[i] < tenkan_values[i - 1] && tenkan_values[i] < tenkan_values[i + 1]) // دره
        {
            if (tenkan_handle != m_ichimoku_handle) IndicatorRelease(tenkan_handle); // آزاد
            return tenkan_values[i]; // بازگشت
        }
        if (!is_buy && tenkan_values[i] > tenkan_values[i - 1] && tenkan_values[i] > tenkan_values[i + 1]) // قله
        {
            if (tenkan_handle != m_ichimoku_handle) IndicatorRelease(tenkan_handle); // آزاد
            return tenkan_values[i]; // بازگشت
        }
    }

    if (tenkan_handle != m_ichimoku_handle) IndicatorRelease(tenkan_handle); // آزاد نهایی
    return 0.0; // هیچ
}

//+------------------------------------------------------------------+
//| محاسبه SL مبتنی بر ATR                                            |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateAtrStopLoss(bool is_buy, double entry_price, ENUM_TIMEFRAMES timeframe)
{
    if (!m_settings.enable_sl_vol_regime) // اگر پویا غیرفعال
    {
        int atr_handle = m_atr_handle; // پیش‌فرض
        if (timeframe != m_settings.ichimoku_timeframe) // متفاوت
        {
            MqlParam params[1]; // پارامتر
            params[0].type = TYPE_INT; params[0].integer_value = m_settings.atr_filter_period;
            atr_handle = IndicatorCreate(m_symbol, timeframe, IND_ATR, 1, params); // موقت
            if (atr_handle == INVALID_HANDLE) // چک
            {
                Log("خطای بحرانی در CalculateAtrStopLoss: هندل ATR نامعتبر است! پریود ATR در تنظیمات ورودی را بررسی کنید."); // لاگ
                return 0.0; // صفر
            }
        }
        
        double atr_buffer[]; // بافر
        if(CopyBuffer(atr_handle, 0, 1, 1, atr_buffer) < 1) // کپی
        {
            Log("داده ATR برای محاسبه حد ضرر ساده موجود نیست. (تابع CopyBuffer شکست خورد)"); // لاگ
            if (atr_handle != m_atr_handle) IndicatorRelease(atr_handle); // آزاد
            return 0.0; // صفر
        }
        
        if (atr_handle != m_atr_handle) IndicatorRelease(atr_handle); // آزاد
        
        double atr_value = atr_buffer[0]; // مقدار ATR
        double sl = is_buy ? entry_price - (atr_value * m_settings.sl_atr_multiplier) : entry_price + (atr_value * m_settings.sl_atr_multiplier); // SL اولیه
        // [NEW] اعمال حداقل فاصله و بافر ATR-based
        double min_distance = atr_value * m_settings.min_sl_distance_atr_percent / 100.0; // حداقل فاصله
        double atr_buffer_val = atr_value * m_settings.sl_buffer_atr_percent / 100.0; // بافر ATR
        if (MathAbs(entry_price - sl) < min_distance) // چک حداقل
        {
            sl = is_buy ? entry_price - min_distance : entry_price + min_distance; // اصلاح
        }
        sl = is_buy ? sl - atr_buffer_val : sl + atr_buffer_val; // اعمال بافر
        return sl; // بازگشت SL نهایی
    }

    // منطق پویا
    int history_size = m_settings.sl_vol_regime_ema_period + 5; // اندازه تاریخچه
    double atr_values[], ema_values[]; // آرایه‌ها

    int atr_sl_handle = iATR(m_symbol, timeframe, m_settings.sl_vol_regime_atr_period); // هندل ATR
    if (atr_sl_handle == INVALID_HANDLE || CopyBuffer(atr_sl_handle, 0, 0, history_size, atr_values) < history_size) // چک
    {
        Log("داده کافی برای محاسبه SL پویا موجود نیست."); // لاگ
        if(atr_sl_handle != INVALID_HANDLE) 
            IndicatorRelease(atr_sl_handle); // آزاد
        return 0.0; // صفر
    }
    
    IndicatorRelease(atr_sl_handle); // آزاد
    ArraySetAsSeries(atr_values, true);  // سری

    if(SimpleMAOnBuffer(history_size, 0, m_settings.sl_vol_regime_ema_period, MODE_EMA, atr_values, ema_values) < 1) // محاسبه EMA
    {
         Log("خطا در محاسبه EMA روی ATR."); // لاگ
         return 0.0; // صفر
    }

    double current_atr = atr_values[1];  // ATR شیفت 1
    double ema_atr = ema_values[1];      // EMA شیفت 1

    bool is_high_volatility = (current_atr > ema_atr); // چک رژیم بالا
    double final_multiplier = is_high_volatility ? m_settings.sl_high_vol_multiplier : m_settings.sl_low_vol_multiplier; // ضریب نهایی

    Log("رژیم نوسان: " + (is_high_volatility ? "بالا" : "پایین") + ". ضریب SL نهایی: " + (string)final_multiplier); // لاگ

    double sl = is_buy ? entry_price - (current_atr * final_multiplier) : entry_price + (current_atr * final_multiplier); // SL پویا
    // [NEW] اعمال حداقل فاصله و بافر ATR-based
    double min_distance = current_atr * m_settings.min_sl_distance_atr_percent / 100.0; // حداقل
    double atr_buffer_val = current_atr * m_settings.sl_buffer_atr_percent / 100.0; // بافر
    if (MathAbs(entry_price - sl) < min_distance) // چک
    {
        sl = is_buy ? entry_price - min_distance : entry_price + min_distance; // اصلاح
    }
    sl = is_buy ? sl - atr_buffer_val : sl + atr_buffer_val; // اعمال بافر
    return sl; // بازگشت
}

//+------------------------------------------------------------------+
//| محاسبه تلرانس تلاقی                                               |
//+------------------------------------------------------------------+
double CStrategyManager::GetTalaqiTolerance(int reference_shift)
{
    switch(m_settings.talaqi_calculation_mode) // سوئیچ حالت
    {
        case TALAQI_MODE_MANUAL: // دستی
            return m_settings.talaqi_distance_in_points * SymbolInfoDouble(m_symbol, SYMBOL_POINT); // بر اساس پوینت
        case TALAQI_MODE_KUMO: // کومو
            return CalculateDynamicTolerance(reference_shift); // پویا کومو
        case TALAQI_MODE_ATR: // ATR
            return CalculateAtrTolerance(reference_shift);     // ATR
        default: // پیش‌فرض
            return 0.0; // بدون تلرانس
    }
}

//+------------------------------------------------------------------+
//| محاسبه تلرانس بر اساس کومو                                       |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateDynamicTolerance(int reference_shift)
{
    if(m_settings.talaqi_kumo_factor <= 0) return 0.0; // اگر ضریب نامعتبر

    double senkou_a_buffer[], senkou_b_buffer[]; // بافرهای سنکو

    if(CopyBuffer(m_ichimoku_handle, 2, reference_shift, 1, senkou_a_buffer) < 1 || 
       CopyBuffer(m_ichimoku_handle, 3, reference_shift, 1, senkou_b_buffer) < 1)
    {
       Log("داده کافی برای محاسبه ضخامت کومو در گذشته وجود ندارد."); // لاگ
       return 0.0; // صفر
    }

    double kumo_thickness = MathAbs(senkou_a_buffer[0] - senkou_b_buffer[0]); // ضخامت کومو

    if(kumo_thickness == 0) return SymbolInfoDouble(m_symbol, SYMBOL_POINT); // حداقل کوچک

    double tolerance = kumo_thickness * m_settings.talaqi_kumo_factor; // تلرانس

    return tolerance; // بازگشت
}

//+------------------------------------------------------------------+
//| اضافه کردن سیگنال به لیست در حالت مسابقه                        |
//+------------------------------------------------------------------+
void CStrategyManager::AddOrUpdatePotentialSignal(bool is_buy)
{
    int total = ArraySize(m_potential_signals); // تعداد فعلی
    ArrayResize(m_potential_signals, total + 1); // اضافه یک عضو
    
    m_potential_signals[total].time = iTime(m_symbol, m_settings.ichimoku_timeframe, m_settings.chikou_period); // زمان
    m_potential_signals[total].is_buy = is_buy; // نوع
    m_potential_signals[total].grace_candle_count = 0; // ریست شمارنده
    
    Log("[حالت مسابقه‌ای] سیگنال نامزد جدید " + (is_buy ? "خرید" : "فروش") + " به لیست انتظار مسابقه اضافه شد. تعداد کل نامزدها: " + (string)ArraySize(m_potential_signals)); // لاگ
    
    if(m_symbol == _Symbol && m_visual_manager != NULL) // چک رسم
    m_visual_manager.DrawTripleCrossRectangle(is_buy, m_settings.chikou_period); // رسم
}

//+------------------------------------------------------------------+
//| محاسبه تلرانس بر اساس ATR                                        |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateAtrTolerance(int reference_shift)
{
    if(m_settings.talaqi_atr_multiplier <= 0) return 0.0; // اگر ضریب نامعتبر
    
    if (m_atr_handle == INVALID_HANDLE) // چک هندل
    {
        Log("محاسبه تلورانس ATR ممکن نیست چون هندل آن نامعتبر است. پریود ATR در تنظیمات ورودی را بررسی کنید."); // لاگ
        return 0.0; // صفر
    }

    double atr_buffer[]; // بافر
    if(CopyBuffer(m_atr_handle, 0, reference_shift, 1, atr_buffer) < 1) // کپی
    {
        Log("داده کافی برای محاسبه ATR در گذشته وجود ندارد."); // لاگ
        return 0.0; // صفر
    }
    
    double tolerance = atr_buffer[0] * m_settings.talaqi_atr_multiplier; // تلرانس
    return tolerance; // بازگشت
}

//+------------------------------------------------------------------+
//| چک تمام فیلترهای ورود                                            |
//+------------------------------------------------------------------+
bool CStrategyManager::AreAllFiltersPassed(bool is_buy)
{
    ENUM_TIMEFRAMES filter_tf = (m_settings.filter_context == FILTER_CONTEXT_HTF) 
                                ? m_settings.ichimoku_timeframe 
                                : m_settings.ltf_timeframe; // تایم فیلتر

    if (m_settings.enable_kumo_filter) // فیلتر کومو
    {
        if (!CheckKumoFilter(is_buy, filter_tf)) // چک
        {
            Log("فیلتر کومو رد شد."); // لاگ
            return false; // رد
        }
    }

    if (m_settings.enable_atr_filter) // فیلتر ATR
    {
        if (!CheckAtrFilter(filter_tf)) // چک
        {
            Log("فیلتر ATR رد شد."); // لاگ
            return false; // رد
        }
    }

    if (m_settings.enable_adx_filter) // فیلتر ADX
    {
        if (!CheckAdxFilter(is_buy, filter_tf)) // چک
        {
            Log("فیلتر ADX رد شد."); // لاگ
            return false; // رد
        }
    }

    // فیلترهای MKM
    if (m_settings.enable_kijun_slope_filter) // شیب کیجون
    {
        double threshold = 0.0; // آستانه
        double slope = CalculateKijunSlope(filter_tf, 5, threshold); // محاسبه
        if (is_buy && slope <= threshold) return false; // رد خرید
        if (!is_buy && slope >= -threshold) return false; // رد فروش
    }
    if (m_settings.enable_kumo_expansion_filter) // انبساط کومو
    {
        if (!IsKumoExpanding(filter_tf, 20)) return false; // رد
    }
    if (m_settings.enable_chikou_space_filter) // فضای چیکو
    {
        if (!IsChikouInOpenSpace(is_buy, filter_tf)) return false; // رد
    }

    Log("✅ تمام فیلترهای فعال با موفقیت پاس شدند."); // لاگ موفقیت
    return true; // پاس
}

//+------------------------------------------------------------------+
//| فیلتر موقعیت نسبت به کومو                                         |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckKumoFilter(bool is_buy, ENUM_TIMEFRAMES timeframe)
{
    int ichi_handle = m_ichimoku_handle; // پیش‌فرض
    if (timeframe != m_settings.ichimoku_timeframe) // متفاوت
    {
        MqlParam params[3]; // پارامترها
        params[0].type = TYPE_INT; params[0].integer_value = m_settings.tenkan_period;
        params[1].type = TYPE_INT; params[1].integer_value = m_settings.kijun_period;
        params[2].type = TYPE_INT; params[2].integer_value = m_settings.senkou_period;
        ichi_handle = IndicatorCreate(m_symbol, timeframe, IND_ICHIMOKU, 3, params); // موقت
        if (ichi_handle == INVALID_HANDLE) // چک
        {
            Log("خطا: هندل ایچیموکو برای فیلتر کومو در تایم فریم " + EnumToString(timeframe) + " ایجاد نشد."); // لاگ
            return false; // رد
        }
    }
    
    double senkou_a[], senkou_b[]; // بافرها
    if(CopyBuffer(ichi_handle, 2, 0, 1, senkou_a) < 1 || 
       CopyBuffer(ichi_handle, 3, 0, 1, senkou_b) < 1)
    {
       Log("خطا: داده کافی برای فیلتر کومو موجود نیست."); // لاگ
       if (ichi_handle != m_ichimoku_handle) IndicatorRelease(ichi_handle); // آزاد
       return false; // رد
    }
    
    if (ichi_handle != m_ichimoku_handle) IndicatorRelease(ichi_handle); // آزاد
    
    double high_kumo = MathMax(senkou_a[0], senkou_b[0]); // بالای کومو
    double low_kumo = MathMin(senkou_a[0], senkou_b[0]); // پایین کومو
    double close_price = iClose(m_symbol, timeframe, 1); // بسته شیفت 1

    if (is_buy) // خرید
    {
        return (close_price > high_kumo); // بالای کومو
    }
    else // فروش
    {
        return (close_price < low_kumo); // پایین کومو
    }
}

//+------------------------------------------------------------------+
//| فیلتر حداقل ATR                                                   |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckAtrFilter(ENUM_TIMEFRAMES timeframe)
{
    int atr_handle = m_atr_handle; // پیش‌فرض
    if (timeframe != m_settings.ichimoku_timeframe) // متفاوت
    {
        MqlParam params[1]; // پارامتر
        params[0].type = TYPE_INT; params[0].integer_value = m_settings.atr_filter_period;
        atr_handle = IndicatorCreate(m_symbol, timeframe, IND_ATR, 1, params); // موقت
        if (atr_handle == INVALID_HANDLE) // چک
        {
            Log("فیلتر ATR رد شد چون هندل آن نامعتبر است. پریود ATR در تنظیمات ورودی را بررسی کنید."); // لاگ
            return false; // رد
        }
    }
    
    double atr_value_buffer[]; // بافر
    if(CopyBuffer(atr_handle, 0, 1, 1, atr_value_buffer) < 1) // کپی
    {
       Log("خطا: داده کافی برای فیلتر ATR موجود نیست."); // لاگ
       if (atr_handle != m_atr_handle) IndicatorRelease(atr_handle); // آزاد
       return false; // رد
    }
    
    if (atr_handle != m_atr_handle) IndicatorRelease(atr_handle); // آزاد
    
    double current_atr = atr_value_buffer[0]; // ATR فعلی
    
    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT); // پوینت
    double min_atr_threshold = m_settings.atr_filter_min_value_pips * point; // آستانه
    
    if(_Digits == 3 || _Digits == 5) // تنظیم برای نمادهای 3 یا 5 رقمی
    {
        min_atr_threshold *= 10; // ضرب در 10
    }

    return (current_atr >= min_atr_threshold); // چک حداقل
}

//+------------------------------------------------------------------+
//| فیلتر ADX                                                         |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckAdxFilter(bool is_buy, ENUM_TIMEFRAMES timeframe) 
{  
    int adx_handle = m_adx_handle; // پیش‌فرض
    if (timeframe != m_settings.ichimoku_timeframe) // متفاوت
    {
        MqlParam params[1]; // پارامتر
        params[0].type = TYPE_INT; params[0].integer_value = m_settings.adx_period;
        adx_handle = IndicatorCreate(m_symbol, timeframe, IND_ADX, 1, params); // موقت
        if (adx_handle == INVALID_HANDLE) // چک
        {
            Log("خطا در ایجاد هندل ADX برای فیلتر در تایم فریم " + EnumToString(timeframe)); // لاگ
            return false; // رد
        }
    }
    
    double adx_buffer[1], di_plus_buffer[1], di_minus_buffer[1];  // بافرها
    
    if (CopyBuffer(adx_handle, 0, 1, 1, adx_buffer) < 1 ||  // ADX
        CopyBuffer(adx_handle, 1, 1, 1, di_plus_buffer) < 1 ||  // DI+
        CopyBuffer(adx_handle, 2, 1, 1, di_minus_buffer) < 1) // DI-
    {
        Log("داده کافی برای فیلتر ADX موجود نیست."); // لاگ
        if (adx_handle != m_adx_handle) IndicatorRelease(adx_handle); // آزاد
        return false; // رد
    }
    
    if (adx_handle != m_adx_handle) IndicatorRelease(adx_handle); // آزاد
    
    if (adx_buffer[0] <= m_settings.adx_threshold)  // چک قدرت
    {
        return false; // رد
    }
    
    if (is_buy) // خرید
    {
        return (di_plus_buffer[0] > di_minus_buffer[0]); // DI+ > DI-
    }
    else // فروش
    {
        return (di_minus_buffer[0] > di_plus_buffer[0]); // DI- > DI+
    }
}

//+------------------------------------------------------------------+
//| چک خروج زودرس از معاملات                                         |
//+------------------------------------------------------------------+
void CStrategyManager::CheckForEarlyExit()
{
    for (int i = PositionsTotal() - 1; i >= 0; i--)  // حلقه پوزیشن‌ها
    {
        ulong ticket = PositionGetTicket(i); // تیکت پوزیشن
        if (PositionGetString(POSITION_SYMBOL) == m_symbol && PositionGetInteger(POSITION_MAGIC) == (long)m_settings.magic_number) // چک نماد و مجیک
        {
            if (PositionSelectByTicket(ticket)) // انتخاب پوزیشن
            {
                bool is_buy = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY); // نوع پوزیشن
                if (CheckChikouRsiExit(is_buy))  // چک شرایط خروج
                { 
                    Log("🚨 سیگنال خروج زودرس برای تیکت " + (string)ticket + " صادر شد. بستن معامله..."); // لاگ
                    m_trade.PositionClose(ticket);  // بستن پوزیشن
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| چک شرایط خروج با چیکو و RSI                                      |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckChikouRsiExit(bool is_buy)
{
    double chikou_price = iClose(m_symbol, m_settings.ichimoku_timeframe, 1); // چیکو شیفت 1
    
    double tenkan_buffer[1], kijun_buffer[1], rsi_buffer[1]; // بافرها
    if(CopyBuffer(m_ichimoku_handle, 0, 1, 1, tenkan_buffer) < 1 ||
       CopyBuffer(m_ichimoku_handle, 1, 1, 1, kijun_buffer) < 1 ||
       CopyBuffer(m_rsi_exit_handle, 0, 1, 1, rsi_buffer) < 1)
    {
        return false; // اگر داده نبود
    }
    
    double tenkan = tenkan_buffer[0]; // تنکان
    double kijun = kijun_buffer[0]; // کیجون
    double rsi = rsi_buffer[0]; // RSI
    
    bool chikou_cross_confirms_exit = false; // فلگ چیکو
    bool rsi_confirms_exit = false; // فلگ RSI

    if (is_buy) // خروج از خرید (نزولی)
    {
        chikou_cross_confirms_exit = (chikou_price < MathMin(tenkan, kijun)); // چیکو زیر خطوط
        rsi_confirms_exit = (rsi < m_settings.early_exit_rsi_oversold); // RSI اشباع فروش
    }
    else // خروج از فروش (صعودی)
    {
        chikou_cross_confirms_exit = (chikou_price > MathMax(tenkan, kijun)); // چیکو بالای خطوط
        rsi_confirms_exit = (rsi > m_settings.early_exit_rsi_overbought); // RSI اشباع خرید
    }
    
    return (chikou_cross_confirms_exit && rsi_confirms_exit); // بازگشت اگر هر دو
}

//+------------------------------------------------------------------+
//| چک تایید LTF (اصلاح شده)                                         |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckLowerTfConfirmation(bool is_buy)
{
    if (is_buy)
    {
        if (m_ltf_analyzer.IsUptrend())
        {
            Log("✅ تاییدیه ساختار صعودی (HH/HL) در LTF دریافت شد.");
            return true;
        }
    }
    else 
    {
        if (m_ltf_analyzer.IsDowntrend())
        {
            Log("✅ تاییدیه ساختار نزولی (LH/LL) در LTF دریافت شد.");
            return true;
        }
    }
    return false;
}

//+------------------------------------------------------------------+
//| تابع لاگ                                                          |
//+------------------------------------------------------------------+
void CStrategyManager::Log(string message)
{
    if (m_settings.enable_logging) // اگر لاگ فعال
    {
        Print(m_symbol, ": ", message); // چاپ پیام
    }
}

//+------------------------------------------------------------------+
//| شمارش معاملات نماد                                               |
//+------------------------------------------------------------------+
int CStrategyManager::CountSymbolTrades()
{
    int count = 0; // شمارنده
    for(int i = PositionsTotal() - 1; i >= 0; i--) // حلقه پوزیشن‌ها
    {
        if(PositionGetSymbol(i) == m_symbol && PositionGetInteger(POSITION_MAGIC) == (long)m_settings.magic_number) // چک
        {
            count++; // افزایش
        }
    }
    return count; // بازگشت
}

//+------------------------------------------------------------------+
//| شمارش کل معاملات                                                 |
//+------------------------------------------------------------------+
int CStrategyManager::CountTotalTrades()
{
    int count = 0; // شمارنده
    for(int i = PositionsTotal() - 1; i >= 0; i--) // حلقه
    {
        if(PositionGetInteger(POSITION_MAGIC) == (long)m_settings.magic_number) // چک مجیک
        {
            count++; // افزایش
        }
    }
    return count; // بازگشت
}

//+------------------------------------------------------------------+
//| باز کردن معامله                                                  |
//+------------------------------------------------------------------+
void CStrategyManager::OpenTrade(bool is_buy)
{
    if(CountTotalTrades() >= m_settings.max_total_trades || CountSymbolTrades() >= m_settings.max_trades_per_symbol) // چک حد
    {
        Log("رسیدن به حد مجاز معاملات. معامله جدید باز نشد."); // لاگ
        return; // خروج
    }

    double entry_price = is_buy ? SymbolInfoDouble(m_symbol, SYMBOL_ASK) : SymbolInfoDouble(m_symbol, SYMBOL_BID); // قیمت ورود
    double sl = CalculateStopLoss(is_buy, entry_price); // محاسبه SL

    if(sl == 0) // چک SL
    {
        Log("خطا در محاسبه استاپ لاس. معامله باز نشد."); // لاگ
        return; // خروج
    }
    
    double balance = AccountInfoDouble(ACCOUNT_BALANCE); // بالانس حساب
    double risk_amount = balance * (m_settings.risk_percent_per_trade / 100.0); // ریسک به پول

    double loss_for_one_lot = 0; // ضرر یک لات
    if(!OrderCalcProfit(is_buy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL, m_symbol, 1.0, entry_price, sl, loss_for_one_lot)) // محاسبه
    {
        Log("خطا در محاسبه سود/زیان با OrderCalcProfit. کد خطا: " + (string)GetLastError()); // لاگ
        return; // خروج
    }
    loss_for_one_lot = MathAbs(loss_for_one_lot); // مطلق ضرر

    if(loss_for_one_lot <= 0) // چک معتبر
    {
        Log("میزان ضرر محاسبه شده برای ۱ لات معتبر نیست. معامله باز نشد."); // لاگ
        return; // خروج
    }

    double lot_size = NormalizeDouble(risk_amount / loss_for_one_lot, 2); // حجم لات

    double min_lot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MIN); // حداقل لات
    double max_lot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MAX); // حداکثر لات
    double lot_step = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_STEP); // گام لات
    
    lot_size = MathMax(min_lot, MathMin(max_lot, lot_size)); // محدوده
    lot_size = MathRound(lot_size / lot_step) * lot_step; // گرد کردن

    if(lot_size < min_lot) // چک حداقل
    {
        Log("حجم محاسبه شده (" + DoubleToString(lot_size,2) + ") کمتر از حداقل لات مجاز (" + DoubleToString(min_lot,2) + ") است. معامله باز نشد."); // لاگ
        return; // خروج
    }

    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT); // پوینت
    double sl_distance_points = MathAbs(entry_price - sl) / point; // فاصله SL به پوینت
    double tp_distance_points = sl_distance_points * m_settings.take_profit_ratio; // فاصله TP
    double tp = is_buy ? entry_price + tp_distance_points * point : entry_price - tp_distance_points * point; // TP
    
    int digits = (int)SymbolInfoInteger(m_symbol, SYMBOL_DIGITS); // digits نماد
    sl = NormalizeDouble(sl, digits); // نرمال SL
    tp = NormalizeDouble(tp, digits); // نرمال TP
    
    string comment = "Memento " + (is_buy ? "Buy" : "Sell"); // کامنت معامله
    MqlTradeResult result; // نتیجه معامله
    
    if(is_buy) // خرید
    {
        m_trade.Buy(lot_size, m_symbol, 0, sl, tp, comment); // باز کردن خرید
    }
    else // فروش
    {
        m_trade.Sell(lot_size, m_symbol, 0, sl, tp, comment); // باز کردن فروش
    }
    
    if(m_trade.ResultRetcode() == TRADE_RETCODE_DONE) // چک موفقیت
    {
        Log("معامله " + comment + " با لات " + DoubleToString(lot_size, 2) + " با موفقیت باز شد."); // لاگ
    }
    else // شکست
    {
        Log("خطا در باز کردن معامله " + comment + ": " + (string)m_trade.ResultRetcode() + " - " + m_trade.ResultComment()); // لاگ
    }
}

//+------------------------------------------------------------------+
//| چک آماده بودن داده‌ها                                             |
//+------------------------------------------------------------------+
bool CStrategyManager::IsDataReady()
{
    ENUM_TIMEFRAMES timeframes_to_check[3]; // آرایه تایم فریم‌ها
    timeframes_to_check[0] = m_settings.ichimoku_timeframe; // HTF
    timeframes_to_check[1] = m_settings.ltf_timeframe;      // LTF
    timeframes_to_check[2] = PERIOD_CURRENT;                 // فعلی

    int required_bars = 200;  // حداقل بار مورد نیاز

    for(int i = 0; i < 3; i++) // حلقه چک
    {
        ENUM_TIMEFRAMES tf = timeframes_to_check[i]; // تایم فعلی
        if(iBars(m_symbol, tf) < required_bars || iTime(m_symbol, tf, 1) == 0) // چک بار و زمان
        {
            // Log("داده برای تایم فریم " + EnumToString(tf) + " هنوز آماده نیست.");
            return false; // نه آماده
        }
    }
    
    return true;  // آماده
}

//+------------------------------------------------------------------+
//| چک کندل جدید                                                      |
//+------------------------------------------------------------------+
bool CStrategyManager::IsNewBar(ENUM_TIMEFRAMES timeframe, datetime &last_bar_time)
{
    datetime current_bar_time = iTime(m_symbol, timeframe, 0); // زمان فعلی
    if (current_bar_time > last_bar_time) // اگر جدید
    {
        last_bar_time = current_bar_time; // آپدیت
        return true; // جدید
    }
    return false; // قدیمی
}

//+------------------------------------------------------------------+
//| محاسبه شیب کیجون                                                 |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateKijunSlope(ENUM_TIMEFRAMES timeframe, int period, double& threshold)
{
    threshold = 0.0; // آستانه پیش‌فرض

    int kijun_handle = (timeframe == m_settings.ichimoku_timeframe) ? m_ichimoku_handle : iIchimoku(m_symbol, timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period); // هندل
    if (kijun_handle == INVALID_HANDLE) return 0.0; // شکست

    double kijun_buffer[]; // بافر
    if (CopyBuffer(kijun_handle, 1, 0, period + 1, kijun_buffer) < period + 1) // کپی
    {
        if (kijun_handle != m_ichimoku_handle) IndicatorRelease(kijun_handle); // آزاد
        return 0.0; // صفر
    }

    if (kijun_handle != m_ichimoku_handle) IndicatorRelease(kijun_handle); // آزاد

    ArraySetAsSeries(kijun_buffer, true); // سری
    double current_kijun = kijun_buffer[0]; // فعلی
    double past_kijun = kijun_buffer[period]; // گذشته

    double slope = (current_kijun - past_kijun) / period; // شیب
    return slope; // بازگشت
}

//+------------------------------------------------------------------+
//| چک انبساط کومو - بهبود: SimpleMAOnBuffer به ExponentialMAOnBuffer تغییر یافت برای واکنش سریع‌تر|
//+------------------------------------------------------------------+
bool CStrategyManager::IsKumoExpanding(ENUM_TIMEFRAMES timeframe, int period)
{
    int ichi_handle = (timeframe == m_settings.ichimoku_timeframe) ? m_ichimoku_handle : iIchimoku(m_symbol, timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period); // هندل
    if (ichi_handle == INVALID_HANDLE) return false; // شکست

    double senkou_a[], senkou_b[]; // بافرها
    if (CopyBuffer(ichi_handle, 2, 0, period, senkou_a) < period || CopyBuffer(ichi_handle, 3, 0, period, senkou_b) < period) // کپی
    {
        if (ichi_handle != m_ichimoku_handle) IndicatorRelease(ichi_handle); // آزاد
        return false; // رد
    }

    if (ichi_handle != m_ichimoku_handle) IndicatorRelease(ichi_handle); // آزاد

    ArraySetAsSeries(senkou_a, true); // سری A
    ArraySetAsSeries(senkou_b, true); // سری B

    double thickness[]; // آرایه ضخامت
    ArrayResize(thickness, period); // تغییر اندازه
    for (int i = 0; i < period; i++) // حلقه
    {
        thickness[i] = MathAbs(senkou_a[i] - senkou_b[i]); // ضخامت
    }

    // [MODIFIED] استفاده از روش امن و ساده مقایسه مستقیم
    if(ArraySize(thickness) < 2) return false; // گاردریل برای داده ناکافی
    ArraySetAsSeries(thickness, true); // سری ضخامت
    return (thickness[0] > thickness[1]); // چک افزایش (انبساط)
}

//+------------------------------------------------------------------+
//| چک فضای باز چیکو                                                 |
//+------------------------------------------------------------------+
bool CStrategyManager::IsChikouInOpenSpace(bool is_buy, ENUM_TIMEFRAMES timeframe)
{
    int ichi_handle = (timeframe == m_settings.ichimoku_timeframe) ? m_ichimoku_handle : iIchimoku(m_symbol, timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period); // هندل
    if (ichi_handle == INVALID_HANDLE) return false; // شکست

    double chikou_buffer[]; // بافر چیکو
    if (CopyBuffer(ichi_handle, 4, 1, 1, chikou_buffer) < 1) // کپی شیفت 1
    {
        if (ichi_handle != m_ichimoku_handle) IndicatorRelease(ichi_handle); // آزاد
        return false; // رد
    }

    if (ichi_handle != m_ichimoku_handle) IndicatorRelease(ichi_handle); // آزاد

    double chikou = chikou_buffer[0]; // مقدار چیکو

    double high_buffer[], low_buffer[]; // بافرهای قیمت
    CopyHigh(m_symbol, timeframe, 1, 26, high_buffer); // سقف 26 شیفت
    CopyLow(m_symbol, timeframe, 1, 26, low_buffer); // کف 26 شیفت

    if (is_buy) // خرید
    {
        return (chikou > ArrayMaximum(high_buffer)); // چیکو بالای حداکثر
    }
    else // فروش
    {
        return (chikou < ArrayMinimum(low_buffer)); // چیکو پایین حداقل
    }
}

//+------------------------------------------------------------------+
//| [NEW] محاسبه SL ساختاری                                          |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateStructuralStopLoss(bool is_buy, double entry_price)
{
    double sl_level = is_buy ? m_ltf_analyzer.GetLastSwingLow() : m_ltf_analyzer.GetLastSwingHigh(); // سطح SL ساختاری
    if (sl_level <= 0) return 0.0; // اگر نامعتبر

    double atr_buffer[1]; // بافر ATR
    if (CopyBuffer(m_atr_handle, 0, 1, 1, atr_buffer) < 1) return 0.0; // چک ATR

    double atr_value = atr_buffer[0]; // ATR فعلی
    double buffer = atr_value * m_settings.sl_buffer_atr_percent / 100.0; // بافر ATR
    sl_level = is_buy ? sl_level - buffer : sl_level + buffer; // اعمال بافر

    double min_distance = atr_value * m_settings.min_sl_distance_atr_percent / 100.0; // حداقل فاصله
    if (MathAbs(entry_price - sl_level) < min_distance) // چک حداقل
    {
        sl_level = is_buy ? entry_price - min_distance : entry_price + min_distance; // اصلاح
    }

    return sl_level; // بازگشت SL ساختاری
}


///کتابخانه ساختاری:::

//+------------------------------------------------------------------+
//|                                        MarketStructure.mqh       |
//|                 © 2025, Mohammad & Gemini                        |
//+------------------------------------------------------------------+
#property copyright "© 2025, HipoAlgorithm" // حقوق کپی‌رایت کتابخانه
#property link      "https://www.mql5.com" // لینک مرتبط
#property version   "3.1" // نسخه با اصلاحات ارتقاء

#include <Object.mqh> // کتابخانه اشیاء برای رسم

//+------------------------------------------------------------------+
//| تنظیمات ورودی کتابخانه (مستقل)                                  |
//+------------------------------------------------------------------+
input group "---=== 🏛️ Market Structure Library Settings 🏛️ ===---"; // گروه تنظیمات کتابخانه
input group "پارامترهای اصلی تحلیل"; // زیرگروه پارامترها
input int    Inp_MSS_Swing_Length   = 10;   // طول تشخیص سقف/کف (تعداد کندل از هر طرف)
input group "تنظیمات نمایشی و لاگ"; // زیرگروه نمایشی
input bool   Inp_MSS_Enable_Drawing = true;  // فعال/غیرفعال کردن رسم روی چارت
input bool   Inp_MSS_Enable_Logging = false; // فعال/غیرفعال کردن لاگ‌های کتابخانه (برای دیباگ)
input group ""; // پایان گروه

// --- تعریف انواع سیگنال خروجی ---
enum E_MSS_SignalType
{
    MSS_NONE,         // هیچ سیگنالی
    MSS_BREAK_HIGH,   // شکست ساده صعودی (BoS)
    MSS_BREAK_LOW,    // شکست ساده نزولی (BoS)
    MSS_SHIFT_UP,     // تغییر به صعودی (MSS)
    MSS_SHIFT_DOWN    // تغییر به نزولی (MSS)
};

// MarketStructure.mqh

struct SMssSignal
{
    E_MSS_SignalType type;
    double           break_price;
    datetime         break_time;
    int              swing_bar_index;
    bool             new_swing_formed;
    bool             is_swing_high;    // <<<< ✅ این خط رو اینجا اضافه کن
    
    SMssSignal() { Reset(); } 
    void Reset() { type=MSS_NONE; break_price=0.0; break_time=0; swing_bar_index=0; new_swing_formed=false; is_swing_high=false; } // به ریست هم اضافش کن

    SMssSignal(const SMssSignal &other) 
    {
        type = other.type;
        break_price = other.break_price;
        break_time = other.break_time;
        swing_bar_index = other.swing_bar_index;
        new_swing_formed = other.new_swing_formed;
        is_swing_high = other.is_swing_high; // <<<< ✅ و اینجا هم برای کپی کردن
    }
};


//+------------------------------------------------------------------+
//| کلاس اصلی تحلیل ساختار بازار                                    |
//+------------------------------------------------------------------+
class CMarketStructureShift
{
private:
    int      m_swing_length; // طول تشخیص چرخش
    string   m_symbol; // نماد
    ENUM_TIMEFRAMES m_period; // تایم فریم
    bool     m_enable_logging; // فعال لاگ
    bool     m_enable_drawing; // فعال رسم
    long     m_chart_id; // ID چارت
    string   m_obj_prefix; // پیشوند اشیاء
    datetime m_last_bar_time; // زمان آخرین بار پردازش شده
    
    double   m_swing_highs_array[]; // آرایه آخرین سقف‌ها ([0] جدیدترین)
    double   m_swing_lows_array[]; // آرایه آخرین کف‌ها ([0] جدیدترین)
    
    double   m_last_swing_h; // آخرین سقف چرخش
    double   m_last_swing_l; // آخرین کف چرخش
    int      m_last_swing_h_index; // اندیس آخرین سقف
    int      m_last_swing_l_index; // اندیس آخرین کف

    double   high(int index) { return iHigh(m_symbol, m_period, index); } // گرفتن سقف اندیس
    double   low(int index) { return iLow(m_symbol, m_period, index); } // گرفتن کف اندیس
    datetime time(int index) { return iTime(m_symbol, m_period, index); } // گرفتن زمان اندیس
    void     Log(string message); // تابع لاگ
    
    void drawSwingPoint(string objName,datetime time_param,double price,int arrCode, color clr,int direction); // رسم نقطه چرخش
    void drawBreakLevel(string objName,datetime time1,double price1, datetime time2,double price2,color clr,int direction); // رسم خط شکست BoS
    void drawBreakLevel_MSS(string objName,datetime time1,double price1, datetime time2,double price2,color clr,int direction); // رسم خط شکست MSS
    
public:
    void Init(string symbol, ENUM_TIMEFRAMES period); // مقداردهی اولیه
    SMssSignal ProcessNewBar(); // پردازش کندل جدید و بازگشت سیگنال
    double GetLastSwingHigh() const { return m_last_swing_h; } // گرفتن آخرین سقف
    double GetLastSwingLow() const { return m_last_swing_l; } // گرفتن آخرین کف
    int    GetLastSwingHighIndex() const { return m_last_swing_h_index; } // اندیس آخرین سقف
    int    GetLastSwingLowIndex() const { return m_last_swing_l_index; } // اندیس آخرین کف
    void   GetRecentHighs(double &highs[]) const { ArrayCopy(highs, m_swing_highs_array); } // کپی سقف‌ها
    void   GetRecentLows(double &lows[]) const { ArrayCopy(lows, m_swing_lows_array); } // کپی کف‌ها
    bool   IsUptrend() const; // چک روند صعودی
    bool   IsDowntrend() const; // چک روند نزولی
    double GetSecondLastSwingHigh() const; // [NEW] گرفتن دومین سقف آخر
    double GetSecondLastSwingLow() const; // [NEW] گرفتن دومین کف آخر
    bool   ScanPastForMSS(bool is_buy_direction, int lookback_bars, int &found_at_bar); // [NEW] اسکن گذشته برای MSS
};

//+------------------------------------------------------------------+
//| مقداردهی اولیه کلاس                                              |
//+------------------------------------------------------------------+
void CMarketStructureShift::Init(string symbol, ENUM_TIMEFRAMES period)
{
    m_symbol = symbol; // تنظیم نماد
    m_period = period; // تنظیم تایم فریم
    
    m_swing_length = Inp_MSS_Swing_Length > 2 ? Inp_MSS_Swing_Length : 10; // طول چرخش (حداقل 3)
    m_enable_logging = Inp_MSS_Enable_Logging; // تنظیم لاگ
    m_enable_drawing = Inp_MSS_Enable_Drawing; // تنظیم رسم
    
    m_chart_id = ChartID(); // ID چارت فعلی
    m_obj_prefix = "MSS_LIB_" + m_symbol + "_" + EnumToString(m_period) + "_"; // پیشوند اشیاء
    m_last_bar_time = 0; // ریست زمان آخرین بار
    m_last_swing_h = -1.0; // ریست آخرین سقف
    m_last_swing_l = -1.0; // ریست آخرین کف
    m_last_swing_h_index = 0; // ریست اندیس سقف
    m_last_swing_l_index = 0; // ریست اندیس کف
    
    // ریست آرایه‌ها
    ArrayFree(m_swing_highs_array); // آزاد سقف‌ها
    ArrayFree(m_swing_lows_array); // آزاد کف‌ها
    
    int highs_found = 0; // شمارنده سقف‌ها
    int lows_found = 0; // شمارنده کف‌ها
    
    // جستجو به عقب برای پیدا کردن حداقل دو سقف و کف اولیه
    for(int i = m_swing_length; i < 500 && (highs_found < 2 || lows_found < 2); i++) // حلقه به عقب
    {
        if(iBars(m_symbol, m_period) < i + m_swing_length + 1) break; // چک داده کافی
        
        bool is_high = true; // فلگ سقف
        bool is_low = true; // فلگ کف
        
        for(int j = 1; j <= m_swing_length; j++) // چک اطراف
        {
            if(high(i) <= high(i-j) || high(i) < high(i+j)) is_high = false; // چک سقف
            if(low(i) >= low(i-j) || low(i) > low(i+j)) is_low = false; // چک کف
        }
        
        if(is_high && highs_found < 2) // اگر سقف و کمتر از 2
        {
            double temp_high[1]; // آرایه موقت
            temp_high[0] = high(i); // مقدار سقف
            ArrayInsert(m_swing_highs_array, temp_high, 0); // اضافه به ابتدا
            highs_found++; // افزایش
        }
        
        if(is_low && lows_found < 2) // اگر کف و کمتر از 2
        {
            double temp_low[1]; // آرایه موقت
            temp_low[0] = low(i); // مقدار کف
            ArrayInsert(m_swing_lows_array, temp_low, 0); // اضافه به ابتدا
            lows_found++; // افزایش
        }
    }
    
    if(m_enable_logging) // اگر لاگ فعال
    {
       Print("مقداردهی اولیه MarketStructure انجام شد."); // چاپ
       Print("سقف‌های اولیه پیدا شده:"); // چاپ
       ArrayPrint(m_swing_highs_array); // چاپ آرایه
       Print("کف‌های اولیه پیدا شده:"); // چاپ
       ArrayPrint(m_swing_lows_array); // چاپ آرایه
    }
    
    Log("کتابخانه MarketStructure برای " + m_symbol + " در " + EnumToString(m_period) + " راه‌اندازی شد."); // لاگ راه‌اندازی
}

//+------------------------------------------------------------------+
//| پردازش کندل جدید (اصلاح شده)                                    |
//+------------------------------------------------------------------+
SMssSignal CMarketStructureShift::ProcessNewBar()
{
    SMssSignal result; // نتیجه سیگنال
    datetime current_bar_time = iTime(m_symbol, m_period, 0); // زمان فعلی
    if (current_bar_time == m_last_bar_time) return result; // اگر همان، خروج
    m_last_bar_time = current_bar_time; // آپدیت زمان

    const int curr_bar = m_swing_length; // بار فعلی برای چک
    if (iBars(m_symbol, m_period) < curr_bar * 2 + 1) return result; // چک داده کافی

    bool isSwingHigh = true, isSwingLow = true; // فلگ‌ها

    for (int a = 1; a <= m_swing_length; a++) // چک اطراف
    {
        if ((high(curr_bar) <= high(curr_bar - a)) || (high(curr_bar) < high(curr_bar + a))) isSwingHigh = false; // چک سقف
        if ((low(curr_bar) >= low(curr_bar - a)) || (low(curr_bar) > low(curr_bar + a))) isSwingLow = false; // چک کف
    }

    if (isSwingHigh) // اگر سقف جدید
    {
        m_last_swing_h = high(curr_bar); // تنظیم سقف
        m_last_swing_h_index = curr_bar; // اندیس
        Log("سقف چرخش جدید: " + DoubleToString(m_last_swing_h, _Digits)); // لاگ
        if (m_enable_drawing) drawSwingPoint(m_obj_prefix + TimeToString(time(curr_bar)), time(curr_bar), m_last_swing_h, 77, clrBlue, -1); // رسم

        // [MODIFIED] منطق برای آپدیت آرایه با چک اندازه
        if(ArraySize(m_swing_highs_array) > 0)
        {
           if(ArraySize(m_swing_highs_array) == 1) ArrayResize(m_swing_highs_array, 2);
           m_swing_highs_array[1] = m_swing_highs_array[0];
        }
        else ArrayResize(m_swing_highs_array, 2);
        m_swing_highs_array[0] = m_last_swing_h;
        result.new_swing_formed = true; // [NEW] اعلام تشکیل سوینگ جدید
    }
    
    if (isSwingLow) // اگر کف جدید
    {
        m_last_swing_l = low(curr_bar); // تنظیم کف
        m_last_swing_l_index = curr_bar; // اندیس
        Log("کف چرخش جدید: " + DoubleToString(m_last_swing_l, _Digits)); // لاگ
        if (m_enable_drawing) drawSwingPoint(m_obj_prefix + TimeToString(time(curr_bar)), time(curr_bar), m_last_swing_l, 77, clrRed, +1); // رسم

        // [MODIFIED] منطق برای آپدیت آرایه با چک اندازه
        if(ArraySize(m_swing_lows_array) > 0)
        {
           if(ArraySize(m_swing_lows_array) == 1) ArrayResize(m_swing_lows_array, 2);
           m_swing_lows_array[1] = m_swing_lows_array[0];
        }
        else ArrayResize(m_swing_lows_array, 2);
        m_swing_lows_array[0] = m_last_swing_l;
        result.new_swing_formed = true; // [NEW] اعلام تشکیل سوینگ جدید
    }

    double Ask = SymbolInfoDouble(m_symbol, SYMBOL_ASK); // قیمت Ask
    double Bid = SymbolInfoDouble(m_symbol, SYMBOL_BID); // قیمت Bid

    if (m_last_swing_h > 0 && Ask > m_last_swing_h) // شکست سقف
    {
        Log("شکست سقف در قیمت " + DoubleToString(m_last_swing_h, _Digits)); // لاگ
        
        bool isMSS_High = IsUptrend(); // چک MSS صعودی
        if (isMSS_High) {
            result.type = MSS_SHIFT_UP; // تغییر به صعودی
            if (m_enable_drawing) drawBreakLevel_MSS(m_obj_prefix + "MSS_UP_" + TimeToString(time(0)), time(m_last_swing_h_index), m_last_swing_h, time(0), m_last_swing_h, clrDarkGreen, -1); // رسم
        } else {
            result.type = MSS_BREAK_HIGH; // شکست ساده صعودی
            if (m_enable_drawing) drawBreakLevel(m_obj_prefix + "BOS_UP_" + TimeToString(time(0)), time(m_last_swing_h_index), m_last_swing_h, time(0), m_last_swing_h, clrBlue, -1); // رسم
        }
        
        result.break_price = m_last_swing_h; // قیمت شکست
        result.break_time = time(0); // زمان
        result.swing_bar_index = m_last_swing_h_index; // اندیس
        m_last_swing_h = -1.0; // ریست
    }
    else if (m_last_swing_l > 0 && Bid < m_last_swing_l) // شکست کف
    {
        Log("شکست کف در قیمت " + DoubleToString(m_last_swing_l, _Digits)); // لاگ
        
        bool isMSS_Low = IsDowntrend(); // چک MSS نزولی
        if (isMSS_Low) {
            result.type = MSS_SHIFT_DOWN; // تغییر به نزولی
            if (m_enable_drawing) drawBreakLevel_MSS(m_obj_prefix + "MSS_DOWN_" + TimeToString(time(0)), time(m_last_swing_l_index), m_last_swing_l, time(0), m_last_swing_l, clrBlack, +1); // رسم
        } else {
            result.type = MSS_BREAK_LOW; // شکست ساده نزولی
            if (m_enable_drawing) drawBreakLevel(m_obj_prefix + "BOS_DOWN_" + TimeToString(time(0)), time(m_last_swing_l_index), m_last_swing_l, time(0), m_last_swing_l, clrRed, +1); // رسم
        }

        result.break_price = m_last_swing_l; // قیمت
        result.break_time = time(0); // زمان
        result.swing_bar_index = m_last_swing_l_index; // اندیس
        m_last_swing_l = -1.0; // ریست
    }


      // [MODIFIED] این بخش را به انتهای تابع ProcessNewBar در MarketStructure.mqh اضافه کنید
      if (isSwingHigh)
      {
          result.new_swing_formed = true;
          result.is_swing_high = true;
      }
      if (isSwingLow)
      {
          result.new_swing_formed = true;
          result.is_swing_high = false;
      }

return result; //  
}
//+------------------------------------------------------------------+
//| تابع لاگ کتابخانه                                                |
//+------------------------------------------------------------------+
void CMarketStructureShift::Log(string message)
{
    if (m_enable_logging) // اگر فعال
    {
        Print("[MSS Lib][", m_symbol, "][", EnumToString(m_period), "]: ", message); // چاپ
    }
}

//+------------------------------------------------------------------+
//| چک روند صعودی (اصلاح شده)                                       |
//+------------------------------------------------------------------+
bool CMarketStructureShift::IsUptrend() const
{
    if (ArraySize(m_swing_highs_array) < 2 || ArraySize(m_swing_lows_array) < 2) return false; // چک حداقل 2 عضو
    // چک سقف جدید > سقف قدیمی و کف جدید > کف قدیمی
    return (m_swing_highs_array[0] > m_swing_highs_array[1] && m_swing_lows_array[0] > m_swing_lows_array[1]);
}

//+------------------------------------------------------------------+
//| چک روند نزولی (اصلاح شده)                                       |
//+------------------------------------------------------------------+
bool CMarketStructureShift::IsDowntrend() const
{
    if (ArraySize(m_swing_highs_array) < 2 || ArraySize(m_swing_lows_array) < 2) return false; // چک حداقل 2 عضو
    // چک سقف جدید < سقف قدیمی و کف جدید < کف قدیمی
    return (m_swing_highs_array[0] < m_swing_highs_array[1] && m_swing_lows_array[0] < m_swing_lows_array[1]);
}

//+------------------------------------------------------------------+
//| [NEW] گرفتن دومین سقف آخر                                        |
//+------------------------------------------------------------------+
double CMarketStructureShift::GetSecondLastSwingHigh() const
{
    if (ArraySize(m_swing_highs_array) < 2) return -1.0; // چک اندازه آرایه
    return m_swing_highs_array[1]; // بازگشت دومین عضو
}

//+------------------------------------------------------------------+
//| [NEW] گرفتن دومین کف آخر                                         |
//+------------------------------------------------------------------+
double CMarketStructureShift::GetSecondLastSwingLow() const
{
    if (ArraySize(m_swing_lows_array) < 2) return -1.0; // چک اندازه آرایه
    return m_swing_lows_array[1]; // بازگشت دومین عضو
}

//+------------------------------------------------------------------+
//| [NEW] اسکن گذشته برای پیدا کردن MSS                               |
//+------------------------------------------------------------------+
bool CMarketStructureShift::ScanPastForMSS(bool is_buy_direction, int lookback_bars, int &found_at_bar)
{
    found_at_bar = -1; // ریست اندیس
    if (lookback_bars <= 0) return false; // چک ورودی

    int total_bars = iBars(m_symbol, m_period); // تعداد بارها
    if (total_bars < lookback_bars) lookback_bars = total_bars - 1; // تنظیم نگاه به عقب

    for (int i = 1; i <= lookback_bars; i++) // حلقه به عقب
    {
        const int curr_bar = i; // بار فعلی اسکن
        if (total_bars < curr_bar + m_swing_length * 2 + 1) continue; // چک داده

        bool isSwingHigh = true, isSwingLow = true; // فلگ‌ها

        for (int a = 1; a <= m_swing_length; a++) // چک اطراف
        {
            if ((high(curr_bar) <= high(curr_bar - a)) || (high(curr_bar) < high(curr_bar + a))) isSwingHigh = false;
            if ((low(curr_bar) >= low(curr_bar - a)) || (low(curr_bar) > low(curr_bar + a))) isSwingLow = false;
        }

        double temp_high = isSwingHigh ? high(curr_bar) : 0;
        double temp_low = isSwingLow ? low(curr_bar) : 0;

        // چک شکست در جهت مورد نظر
        if (is_buy_direction && temp_high > 0 && IsUptrend()) // برای خرید و MSS صعودی
        {
            found_at_bar = curr_bar; // تنظیم اندیس
            return true; // پیدا شد
        }
        else if (!is_buy_direction && temp_low > 0 && IsDowntrend()) // برای فروش و MSS نزولی
        {
            found_at_bar = curr_bar; // تنظیم اندیس
            return true; // پیدا شد
        }
    }

    return false; // پیدا نشد
}

//+------------------------------------------------------------------+
//| رسم نقطه چرخش                                                    |
//+------------------------------------------------------------------+
void CMarketStructureShift::drawSwingPoint(string objName,datetime time_param,double price,int arrCode, color clr,int direction)
{
   if(ObjectFind(m_chart_id,objName) < 0) { // اگر شیء وجود ندارد
      ObjectCreate(m_chart_id,objName,OBJ_ARROW,0,time_param,price); // ایجاد فلش
      ObjectSetInteger(m_chart_id,objName,OBJPROP_ARROWCODE,arrCode); // کد فلش
      ObjectSetInteger(m_chart_id,objName,OBJPROP_COLOR,clr); // رنگ
      ObjectSetInteger(m_chart_id,objName,OBJPROP_FONTSIZE,10); // اندازه فونت
      if(direction > 0) ObjectSetInteger(m_chart_id,objName,OBJPROP_ANCHOR,ANCHOR_TOP); // لنگر بالا
      if(direction < 0) ObjectSetInteger(m_chart_id,objName,OBJPROP_ANCHOR,ANCHOR_BOTTOM); // لنگر پایین
      
      string text = "Swing"; // متن
      string objName_Descr = objName + text; // نام توصیفی
      ObjectCreate(m_chart_id,objName_Descr,OBJ_TEXT,0,time_param,price); // ایجاد متن
      ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_COLOR,clr); // رنگ متن
      ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_FONTSIZE,10); // اندازه
      if(direction > 0) { ObjectSetString(m_chart_id,objName_Descr,OBJPROP_TEXT,"  "+text); ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_ANCHOR,ANCHOR_LEFT_UPPER); } // متن بالا
      if(direction < 0) { ObjectSetString(m_chart_id,objName_Descr,OBJPROP_TEXT,"  "+text); ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_ANCHOR,ANCHOR_LEFT_LOWER); } // متن پایین
   }
   ChartRedraw(m_chart_id); // بازسازی چارت
}

//+------------------------------------------------------------------+
//| رسم خط شکست BoS                                                   |
//+------------------------------------------------------------------+
void CMarketStructureShift::drawBreakLevel(string objName,datetime time1,double price1, datetime time2,double price2,color clr,int direction)
{
   if(ObjectFind(m_chart_id,objName) < 0) { // اگر شیء وجود ندارد
      ObjectCreate(m_chart_id,objName,OBJ_ARROWED_LINE,0,time1,price1,time2,price2); // ایجاد خط فلش‌دار
      ObjectSetInteger(m_chart_id,objName,OBJPROP_COLOR,clr); // رنگ
      ObjectSetInteger(m_chart_id,objName,OBJPROP_WIDTH,2); // عرض
      string text = "BoS"; // متن
      string objName_Descr = objName + text; // نام
      ObjectCreate(m_chart_id,objName_Descr,OBJ_TEXT,0,time2,price2); // ایجاد متن
      ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_COLOR,clr); // رنگ
      ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_FONTSIZE,10); // اندازه
      if(direction > 0) { ObjectSetString(m_chart_id,objName_Descr,OBJPROP_TEXT,text+"  "); ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_ANCHOR,ANCHOR_RIGHT_UPPER); } // متن بالا
      if(direction < 0) { ObjectSetString(m_chart_id,objName_Descr,OBJPROP_TEXT,text+"  "); ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_ANCHOR,ANCHOR_RIGHT_LOWER); } // متن پایین
   }
   ChartRedraw(m_chart_id); // بازسازی
}

//+------------------------------------------------------------------+
//| رسم خط شکست MSS                                                   |
//+------------------------------------------------------------------+
void CMarketStructureShift::drawBreakLevel_MSS(string objName,datetime time1,double price1, datetime time2,double price2,color clr,int direction)
{
   if(ObjectFind(m_chart_id,objName) < 0) { // اگر شیء وجود ندارد
      ObjectCreate(m_chart_id,objName,OBJ_ARROWED_LINE,0,time1,price1,time2,price2); // ایجاد خط
      ObjectSetInteger(m_chart_id,objName,OBJPROP_COLOR,clr); // رنگ
      ObjectSetInteger(m_chart_id,objName,OBJPROP_WIDTH,4); // عرض بیشتر برای MSS
      string text = "MSS"; // متن
      string objName_Descr = objName + text; // نام
      ObjectCreate(m_chart_id,objName_Descr,OBJ_TEXT,0,time2,price2); // ایجاد متن
      ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_COLOR,clr); // رنگ
      ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_FONTSIZE,13); // اندازه بزرگتر
      if(direction > 0) { ObjectSetString(m_chart_id,objName_Descr,OBJPROP_TEXT,text+"  "); ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_ANCHOR,ANCHOR_RIGHT_UPPER); } // متن
      if(direction < 0) { ObjectSetString(m_chart_id,objName_Descr,OBJPROP_TEXT,text+"  "); ObjectSetInteger(m_chart_id,objName_Descr,OBJPROP_ANCHOR,ANCHOR_RIGHT_LOWER); } // متن
   }
   ChartRedraw(m_chart_id); // بازسازی
}


 
///فایل 5 کتابخانه ترلینک استاپ:::

//+------------------------------------------------------------------+
//|                                      Universal Trailing Stop Loss Library |
//|                                      File: TrailingStopManager.mqh |
//|                                      Version: 5.1 (Truly Final) |
//|                                      © 2025, Mohammad & Gemini |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "© 2025, hipoalgoritm"
#property link      "https://www.mql5.com"
#property version   "5.1"
#include <Trade\Trade.mqh>

//================================================================================//
//|                                 --- راهنمای استفاده سریع ---                   |
//|                                                                                |
//| ۱. این فایل را در کنار فایل اکسپرت خود قرار دهید.                                |
//| ۲. در فایل اکسپرت اصلی (.mq5)، این دو خط را به بالای فایل اضافه کنید:             |
//|    #include "TrailingStopManager.mqh"                                          |
//|    CTrailingStopManager TrailingStop;                                          |
//| ۳. در انتهای تابع OnInit اکسپرت خود، این خط را اضافه کنید:                      |
//|    TrailingStop.Init(magic_number);                                           |
//| ۴. در انتهای تابع OnTimer (یا OnTick) اکسپرت خود، این خط را اضافه کنید:          |
//|    TrailingStop.Process();                                                     |
//|                                                                                |
//|                                 **دیگر به هیچ فراخوانی دیگری نیاز نیست!** |
//|                                                                                |
//================================================================================//

//================================================================//
// بخش تنظیمات ورودی (Inputs) - کاملا مستقل و Plug & Play
//================================================================//
input group "---=== 🛡️ Universal Trailing & Breakeven 🛡️ ===---";
input bool Inp_TSL_Enable = true;
input double Inp_TSL_Activation_RR = 1.0;
input bool Inp_BE_Enable = true;
input double Inp_BE_Activation_RR = 1.0;
input double Inp_BE_Plus_Pips = 1.0;
enum E_TSL_Mode { TSL_MODE_TENKAN, TSL_MODE_KIJUN, TSL_MODE_MA, TSL_MODE_ATR, TSL_MODE_PSAR, TSL_MODE_PRICE_CHANNEL, TSL_MODE_CHANDELIER_ATR };
input E_TSL_Mode Inp_TSL_Mode = TSL_MODE_TENKAN;
/*input*/ double Inp_TSL_Buffer_Pips = 3.0;
/*input*/ int Inp_TSL_Ichimoku_Tenkan = 9;
/*input*/ int Inp_TSL_Ichimoku_Kijun = 26;
/*input*/ int Inp_TSL_Ichimoku_Senkou = 52;
/*input*/ int Inp_TSL_MA_Period = 50;
/*input*/ ENUM_MA_METHOD Inp_TSL_MA_Method = MODE_SMA;
/*input*/ ENUM_APPLIED_PRICE Inp_TSL_MA_Price = PRICE_CLOSE;
/*input*/ int Inp_TSL_ATR_Period = 14;
/*input*/ double Inp_TSL_ATR_Multiplier = 2.5;
/*input*/ double Inp_TSL_PSAR_Step = 0.02;
/*input*/ double Inp_TSL_PSAR_Max = 0.2;
/*input*/ int Inp_TSL_PriceChannel_Period = 22;

//+------------------------------------------------------------------+
//| ساختارهای داخلی برای مدیریت بهینه هندل‌ها و وضعیت تریدها          |
//+------------------------------------------------------------------+
struct SIndicatorHandle
{
  string symbol;
  int    handle;
};

struct STradeState
{
  ulong  ticket;
  double open_price;
  double initial_sl;
  bool   be_applied;
};

//+------------------------------------------------------------------+
//| کلاس اصلی مدیریت حد ضرر متحرک                                     |
//+------------------------------------------------------------------+
class CTrailingStopManager
{
private:
  long               m_magic_number;
  bool               m_is_initialized;
  CTrade             m_trade;

  // --- تنظیمات ---
  bool               m_tsl_enabled, m_be_enabled;
  double             m_activation_rr, m_be_activation_rr, m_be_plus_pips;
  E_TSL_Mode         m_tsl_mode;
  double             m_buffer_pips;
  int                m_ichimoku_tenkan, m_ichimoku_kijun, m_ichimoku_senkou;
  int                m_ma_period;
  ENUM_MA_METHOD     m_ma_method;
  ENUM_APPLIED_PRICE m_ma_price;
  int                m_atr_period;
  double             m_atr_multiplier;
  double             m_psar_step, m_psar_max;
  int                m_pricechannel_period;

  // --- مدیریت حالت ---
  STradeState        m_trade_states[];

  // --- مدیریت هندل‌ها ---
  SIndicatorHandle   m_ichimoku_handles[];
  SIndicatorHandle   m_ma_handles[];
  SIndicatorHandle   m_atr_handles[];
  SIndicatorHandle   m_psar_handles[];

  // --- توابع کمکی خصوصی ---
  int    GetIchimokuHandle(string symbol);
  int    GetMaHandle(string symbol);
  int    GetAtrHandle(string symbol);
  int    GetPsarHandle(string symbol);
  void   Log(string message);
  void   ManageSingleTrade(ulong ticket);
  int    FindTradeStateIndex(ulong ticket);
  void   AddTradeState(ulong ticket, double open_price, double initial_sl);
  void   CleanupTradeStates();

  double CalculateIchimokuSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculateMaSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculateAtrSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculatePsarSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculatePriceChannelSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculateChandelierAtrSL(string symbol, ENUM_POSITION_TYPE type);
  void   ManageBreakeven(int state_idx);

public:
  CTrailingStopManager() { m_magic_number = 0; m_is_initialized = false; }
  ~CTrailingStopManager();
  void Init(long magic_number);
  void Process();
};

// --- مخرب کلاس ---
CTrailingStopManager::~CTrailingStopManager()
{
  for(int i = 0; i < ArraySize(m_ichimoku_handles); i++) IndicatorRelease(m_ichimoku_handles[i].handle);
  for(int i = 0; i < ArraySize(m_ma_handles); i++) IndicatorRelease(m_ma_handles[i].handle);
  for(int i = 0; i < ArraySize(m_atr_handles); i++) IndicatorRelease(m_atr_handles[i].handle);
  for(int i = 0; i < ArraySize(m_psar_handles); i++) IndicatorRelease(m_psar_handles[i].handle);
}

// --- تابع مقداردهی اولیه ---
void CTrailingStopManager::Init(long magic_number)
{
  if(m_is_initialized) return;
  m_magic_number = magic_number;
  m_trade.SetExpertMagicNumber(m_magic_number);
  m_trade.SetAsyncMode(true);
  m_tsl_enabled = Inp_TSL_Enable;
  m_activation_rr = Inp_TSL_Activation_RR > 0 ? Inp_TSL_Activation_RR : 1.0;
  m_be_enabled = Inp_BE_Enable;
  m_be_activation_rr = Inp_BE_Activation_RR > 0 ? Inp_BE_Activation_RR : 1.0;
  m_be_plus_pips = Inp_BE_Plus_Pips;
  m_tsl_mode = Inp_TSL_Mode;
  m_buffer_pips = Inp_TSL_Buffer_Pips;
  m_ichimoku_tenkan = Inp_TSL_Ichimoku_Tenkan;
  m_ichimoku_kijun = Inp_TSL_Ichimoku_Kijun;
  m_ichimoku_senkou = Inp_TSL_Ichimoku_Senkou;
  m_ma_period = Inp_TSL_MA_Period;
  m_ma_method = Inp_TSL_MA_Method;
  m_ma_price = Inp_TSL_MA_Price;
  m_atr_period = Inp_TSL_ATR_Period;
  m_atr_multiplier = Inp_TSL_ATR_Multiplier;
  m_psar_step = Inp_TSL_PSAR_Step;
  m_psar_max = Inp_TSL_PSAR_Max;
  m_pricechannel_period = Inp_TSL_PriceChannel_Period;
  if(m_tsl_enabled || m_be_enabled) Log("کتابخانه Universal Trailing/BE با موفقیت برای مجیک نامبر " + (string)m_magic_number + " فعال شد.");
  m_is_initialized = true;
}

// ✅✅✅ تابع اصلی پردازش (منطق کاملاً مستقل) ✅✅✅
void CTrailingStopManager::Process()
{
  if(!m_is_initialized || (!m_tsl_enabled && !m_be_enabled)) return;

  // گام ۱: پوزیشن‌های جدید را به لیست اضافه کن.
  int positions_total = PositionsTotal();
  for(int i = 0; i < positions_total; i++)
  {
      ulong ticket = PositionGetTicket(i);
      if(PositionGetInteger(POSITION_MAGIC) != m_magic_number) continue;

      int state_idx = FindTradeStateIndex(ticket);

      if(state_idx == -1)
      {
          if(PositionSelectByTicket(ticket))
          {
              AddTradeState(ticket, PositionGetDouble(POSITION_PRICE_OPEN), PositionGetDouble(POSITION_SL));
          }
      }
  }

  // ✅✅✅ گام ۲: پاکسازی لیست از پوزیشن‌های بسته شده ✅✅✅
  CleanupTradeStates();

  // گام ۳: منطق تریلینگ و سربه‌سر را برای هر پوزیشن در لیست اجرا کن.
  for(int i = 0; i < ArraySize(m_trade_states); i++)
  {
    ManageSingleTrade(m_trade_states[i].ticket);
  }
}

// ✅✅✅ تابع جدید: پاکسازی حالت‌های ترید ✅✅✅
void CTrailingStopManager::CleanupTradeStates()
{
    for(int i = ArraySize(m_trade_states) - 1; i >= 0; i--)
    {
        ulong ticket = m_trade_states[i].ticket;
        // اگر پوزیشن با این تیکت پیدا نشد یا مجیک نامبرش فرق داشت، یعنی بسته شده.
        if(!PositionSelectByTicket(ticket) || PositionGetInteger(POSITION_MAGIC) != m_magic_number)
        {
            ArrayRemove(m_trade_states, i, 1);
            Log("حالت تیکت " + (string)ticket + " از لیست تریلینگ حذف شد.");
        }
    }
}


// ... بقیه توابع کلاس CTrailingStopManager (بدون تغییر) ...
void CTrailingStopManager::ManageSingleTrade(ulong ticket)
{
    if(!PositionSelectByTicket(ticket)) return;

    int state_idx = FindTradeStateIndex(ticket);
    if (state_idx == -1) return;

    double initial_sl = m_trade_states[state_idx].initial_sl;
    
    if (initial_sl == 0)
    {
        double current_sl_from_position = PositionGetDouble(POSITION_SL);
        if (current_sl_from_position > 0)
        {
            m_trade_states[state_idx].initial_sl = current_sl_from_position;
            initial_sl = current_sl_from_position;
            Log("SL اولیه برای تیکت " + (string)ticket + " با موفقیت به‌روزرسانی شد: " + (string)initial_sl);
        }
        else
        {
            return;
        }
    }
    
    if(m_be_enabled) ManageBreakeven(state_idx);

    if(!m_tsl_enabled) return;

    string symbol = PositionGetString(POSITION_SYMBOL);
    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    double open_price = PositionGetDouble(POSITION_PRICE_OPEN);
    double initial_risk = MathAbs(open_price - initial_sl);
    if(initial_risk == 0) return;

    double required_profit_for_tsl = initial_risk * m_activation_rr;
    double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
    double current_profit = (type == POSITION_TYPE_BUY) ? (current_price - open_price) : (open_price - current_price);
    
    if(current_profit < required_profit_for_tsl) return;
    
    double new_sl_level = 0;
    switch(m_tsl_mode)
    {
    case TSL_MODE_TENKAN:
    case TSL_MODE_KIJUN:
        new_sl_level = CalculateIchimokuSL(symbol, type);
        break;
    case TSL_MODE_MA:
        new_sl_level = CalculateMaSL(symbol, type);
        break;
    case TSL_MODE_ATR:
        new_sl_level = CalculateAtrSL(symbol, type);
        break;
    case TSL_MODE_PSAR:
        new_sl_level = CalculatePsarSL(symbol, type);
        break;
    case TSL_MODE_PRICE_CHANNEL:
        new_sl_level = CalculatePriceChannelSL(symbol, type);
        break;
    case TSL_MODE_CHANDELIER_ATR:
        new_sl_level = CalculateChandelierAtrSL(symbol, type);
        break;
    }
    if(new_sl_level == 0) return;
    
    double final_new_sl = new_sl_level;
    if(m_tsl_mode == TSL_MODE_TENKAN || m_tsl_mode == TSL_MODE_KIJUN || m_tsl_mode == TSL_MODE_MA)
    {
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        double pips_to_points_multiplier = (SymbolInfoInteger(symbol, SYMBOL_DIGITS) == 3 || SymbolInfoInteger(symbol, SYMBOL_DIGITS) == 5) ? 10.0 : 1.0;
        double buffer_points = m_buffer_pips * point * pips_to_points_multiplier;
        if(type == POSITION_TYPE_BUY) final_new_sl -= buffer_points;
        else final_new_sl += buffer_points;
    }
    
    int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
    final_new_sl = NormalizeDouble(final_new_sl, digits);
    double current_sl = PositionGetDouble(POSITION_SL);

    bool should_modify = false;
    if(type == POSITION_TYPE_BUY)
    {
        if(final_new_sl > current_sl && final_new_sl < current_price) should_modify = true;
    }
    else
    {
        if(final_new_sl < current_sl && final_new_sl > current_price) should_modify = true;
    }

    if(should_modify)
    {
        if(m_trade.PositionModify(ticket, final_new_sl, PositionGetDouble(POSITION_TP)))
        {
            Log("تریلینگ استاپ برای تیکت " + (string)ticket + " به قیمت " + DoubleToString(final_new_sl, digits) + " آپدیت شد.");
        }
        else
        {
            Log("خطا در آپدیت تریلینگ استاپ برای تیکت " + (string)ticket + ". کد: " + (string)m_trade.ResultRetcode() + " | " + m_trade.ResultComment());
        }
    }
}
void CTrailingStopManager::ManageBreakeven(int state_idx)
{
    if(m_trade_states[state_idx].be_applied) return;
    ulong ticket = m_trade_states[state_idx].ticket;
    if(!PositionSelectByTicket(ticket)) return;
    string symbol = PositionGetString(POSITION_SYMBOL);
    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

    double initial_sl = m_trade_states[state_idx].initial_sl;
    if(initial_sl == 0) return;
    double open_price = PositionGetDouble(POSITION_PRICE_OPEN);
    double initial_risk = MathAbs(open_price - initial_sl);
    if(initial_risk == 0) return;
    double required_profit_for_be = initial_risk * m_be_activation_rr;
    double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
    double current_profit = (type == POSITION_TYPE_BUY) ? (current_price - open_price) : (open_price - current_price);

    if(current_profit >= required_profit_for_be)
    {
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        double pips_to_points_multiplier = (SymbolInfoInteger(symbol, SYMBOL_DIGITS) == 3 || SymbolInfoInteger(symbol, SYMBOL_DIGITS) == 5) ? 10.0 : 1.0;
        double be_offset = m_be_plus_pips * point * pips_to_points_multiplier;
        double new_sl = (type == POSITION_TYPE_BUY) ? open_price + be_offset : open_price - be_offset;
        int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
        new_sl = NormalizeDouble(new_sl, digits);

        if( (type == POSITION_TYPE_BUY && new_sl > PositionGetDouble(POSITION_SL)) ||
            (type == POSITION_TYPE_SELL && new_sl < PositionGetDouble(POSITION_SL)) )
        {
            if(m_trade.PositionModify(ticket, new_sl, PositionGetDouble(POSITION_TP)))
            {
                Log("معامله تیکت " + (string)ticket + " با موفقیت سربه‌سر (Breakeven) شد.");
                m_trade_states[state_idx].be_applied = true;
            }
        }
    }
}
int CTrailingStopManager::FindTradeStateIndex(ulong ticket)
{
    for(int i = 0; i < ArraySize(m_trade_states); i++)
    {
        if(m_trade_states[i].ticket == ticket) return i;
    }
    return -1;
}
void CTrailingStopManager::AddTradeState(ulong ticket, double open_price, double initial_sl)
{
    int idx = FindTradeStateIndex(ticket);
    if(idx != -1) return;
    
    int new_idx = ArraySize(m_trade_states);
    ArrayResize(m_trade_states, new_idx + 1);
    m_trade_states[new_idx].ticket = ticket;
    m_trade_states[new_idx].open_price = open_price;
    m_trade_states[new_idx].initial_sl = initial_sl;
    m_trade_states[new_idx].be_applied = false;
    Log("حالت جدید برای تیکت " + (string)ticket + " با SL اولیه " + (string)initial_sl + " اضافه شد.");
}
int CTrailingStopManager::GetIchimokuHandle(string symbol)
{
  for(int i=0; i<ArraySize(m_ichimoku_handles); i++) if(m_ichimoku_handles[i].symbol==symbol) return m_ichimoku_handles[i].handle;
  int handle = iIchimoku(symbol, _Period, m_ichimoku_tenkan, m_ichimoku_kijun, m_ichimoku_senkou);
  if(handle!=INVALID_HANDLE){int n=ArraySize(m_ichimoku_handles); ArrayResize(m_ichimoku_handles,n+1); m_ichimoku_handles[n].symbol=symbol; m_ichimoku_handles[n].handle=handle;}
  return handle;
}
int CTrailingStopManager::GetMaHandle(string symbol)
{
  for(int i=0; i<ArraySize(m_ma_handles); i++) if(m_ma_handles[i].symbol==symbol) return m_ma_handles[i].handle;
  int handle = iMA(symbol, _Period, m_ma_period, 0, m_ma_method, m_ma_price);
  if(handle!=INVALID_HANDLE){int n=ArraySize(m_ma_handles); ArrayResize(m_ma_handles,n+1); m_ma_handles[n].symbol=symbol; m_ma_handles[n].handle=handle;}
  return handle;
}
int CTrailingStopManager::GetAtrHandle(string symbol)
{
  for(int i=0; i<ArraySize(m_atr_handles); i++) if(m_atr_handles[i].symbol==symbol) return m_atr_handles[i].handle;
  int handle = iATR(symbol, _Period, m_atr_period);
  if(handle!=INVALID_HANDLE){int n=ArraySize(m_atr_handles); ArrayResize(m_atr_handles,n+1); m_atr_handles[n].symbol=symbol; m_atr_handles[n].handle=handle;}
  return handle;
}
int CTrailingStopManager::GetPsarHandle(string symbol)
{
  for(int i=0; i<ArraySize(m_psar_handles); i++) if(m_psar_handles[i].symbol==symbol) return m_psar_handles[i].handle;
  int handle = iSAR(symbol, _Period, m_psar_step, m_psar_max);
  if(handle!=INVALID_HANDLE){int n=ArraySize(m_psar_handles); ArrayResize(m_psar_handles,n+1); m_psar_handles[n].symbol=symbol; m_psar_handles[n].handle=handle;}
  return handle;
}
void CTrailingStopManager::Log(string message)
{
  if (m_magic_number > 0) Print("TSL Manager [", (string)m_magic_number, "]: ", message);
}
double CTrailingStopManager::CalculateIchimokuSL(string symbol, ENUM_POSITION_TYPE type)
{
  int handle = GetIchimokuHandle(symbol);
  if(handle == INVALID_HANDLE) return 0.0;
  int buffer_idx = (m_tsl_mode == TSL_MODE_TENKAN) ? 0 : 1;
  double values[1];
  if(CopyBuffer(handle, buffer_idx, 1, 1, values) < 1) return 0.0;
  double line_value = values[0];
  double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
  if (type == POSITION_TYPE_BUY && line_value > current_price) return 0.0;
  if (type == POSITION_TYPE_SELL && line_value < current_price) return 0.0;
  return line_value;
}
double CTrailingStopManager::CalculateMaSL(string symbol, ENUM_POSITION_TYPE type)
{
  int handle = GetMaHandle(symbol);
  if(handle == INVALID_HANDLE) return 0.0;
  double values[1];
  if(CopyBuffer(handle, 0, 1, 1, values) < 1) return 0.0;
  double ma_value = values[0];
  double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
  if (type == POSITION_TYPE_BUY && ma_value > current_price) return 0.0;
  if (type == POSITION_TYPE_SELL && ma_value < current_price) return 0.0;
  return ma_value;
}
double CTrailingStopManager::CalculateAtrSL(string symbol, ENUM_POSITION_TYPE type)
{
  int handle = GetAtrHandle(symbol);
  if(handle == INVALID_HANDLE) return 0.0;
  double values[1];
  if(CopyBuffer(handle, 0, 1, 1, values) < 1) return 0.0;
  double atr_offset = values[0] * m_atr_multiplier;
  double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
  if(type == POSITION_TYPE_BUY) return current_price - atr_offset;
  else return current_price + atr_offset;
}
double CTrailingStopManager::CalculatePsarSL(string symbol, ENUM_POSITION_TYPE type)
{
  int handle = GetPsarHandle(symbol);
  if(handle == INVALID_HANDLE) return 0.0;
  double values[1];
  if(CopyBuffer(handle, 0, 1, 1, values) < 1) return 0.0;
  double psar_value = values[0];
  double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
  if (type == POSITION_TYPE_BUY && psar_value > current_price) return 0.0;
  if (type == POSITION_TYPE_SELL && psar_value < current_price) return 0.0;
  return psar_value;
}
double CTrailingStopManager::CalculatePriceChannelSL(string symbol, ENUM_POSITION_TYPE type)
{
  double values[];
  if(type == POSITION_TYPE_BUY)
  {
      if(CopyLow(symbol, _Period, 1, m_pricechannel_period, values) < m_pricechannel_period) return 0.0;
      return values[ArrayMinimum(values, 0, m_pricechannel_period)];
  }
  else
  {
      if(CopyHigh(symbol, _Period, 1, m_pricechannel_period, values) < m_pricechannel_period) return 0.0;
      return values[ArrayMaximum(values, 0, m_pricechannel_period)];
  }
}
double CTrailingStopManager::CalculateChandelierAtrSL(string symbol, ENUM_POSITION_TYPE type)
{
  int atr_handle = GetAtrHandle(symbol);
  if(atr_handle == INVALID_HANDLE) return 0.0;
  double atr_values[1];
  if(CopyBuffer(atr_handle, 0, 1, 1, atr_values) < 1) return 0.0;
  double atr_offset = atr_values[0] * m_atr_multiplier;
  double price_channel_values[];
  if(type == POSITION_TYPE_BUY)
  {
      if(CopyHigh(symbol, _Period, 1, m_pricechannel_period, price_channel_values) < m_pricechannel_period) return 0.0;
      double highest_high = price_channel_values[ArrayMaximum(price_channel_values, 0, m_pricechannel_period)];
      return highest_high - atr_offset;
  }
  else
  {
      if(CopyLow(symbol, _Period, 1, m_pricechannel_period, price_channel_values) < m_pricechannel_period) return 0.0;
      double lowest_low = price_channel_values[ArrayMinimum(price_channel_values, 0, m_pricechannel_period)];
      return lowest_low + atr_offset;
  }
}





