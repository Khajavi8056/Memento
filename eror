'CheckKumoFilter' - member function already defined with different parameters	IchimokuLogic.mqh	1404	24
'CheckAtrFilter' - member function already defined with different parameters	IchimokuLogic.mqh	1435	24
'CheckAdxFilter' - member function already defined with different parameters	IchimokuLogic.mqh	1467	24
رفیق، دم شما گرم که اینقدر با دقت پیگیری می‌کنی. 🤝
حق با توئه، خطا دقیقاً اینه: member function already defined with different parameters. این یعنی ما امضای تابع‌ها رو داخل کلاس (private:) تغییر دادیم، اما خود تابع‌ها رو با همون امضای جدید بازنویسی نکردیم. در واقع، دو نسخه از هر تابع وجود داشت که کامپایلر نمی‌دونست از کدوم استفاده کنه.
بذار هر سه تا تابع رو با امضای درست و منطق کامل، بازنویسی کنیم تا دیگه هیچ خطایی نداشته باشیم.
۱. تابع CStrategyManager::CheckKumoFilter() (اصلاح شده)
این تابع فیلتر کومو رو بر اساس تایم‌فریمی که از تنظیمات می‌گیری، بررسی می‌کنه.
//+------------------------------------------------------------------+
//| تابع کمکی برای بررسی فیلتر ابر کومو                              |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckKumoFilter(bool is_buy, ENUM_TIMEFRAMES timeframe)
{
    // اگر فیلتر کومو فعال نبود، همیشه true برمی‌گرداند تا بقیه سیستم به کارش ادامه دهد.
    if (!m_settings.enable_kumo_filter)
    {
        return true;
    }
    
    double senkou_a[], senkou_b[];
    // از هندل ایچیموکو با تایم‌فریم انتخابی کاربر استفاده می‌کنیم
    int ichi_handle = iIchimoku(m_symbol, timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period);
    
    // گرفتن مقادیر سنکو A و B برای کندل فعلی (شیفت ۰)
    if(ichi_handle == INVALID_HANDLE || CopyBuffer(ichi_handle, 2, 0, 1, senkou_a) < 1 || 
       CopyBuffer(ichi_handle, 3, 0, 1, senkou_b) < 1)
    {
       Log("خطا: داده کافی برای فیلتر کومو موجود نیست.");
       // هندل را آزاد می‌کنیم تا حافظه بیهوده اشغال نشود
       if(ichi_handle != INVALID_HANDLE) IndicatorRelease(ichi_handle);
       return false; // اگر داده نباشد، فیلتر رد می‌شود
    }
    
    // هندل را آزاد می‌کنیم
    IndicatorRelease(ichi_handle);
    
    double high_kumo = MathMax(senkou_a[0], senkou_b[0]);
    double low_kumo = MathMin(senkou_a[0], senkou_b[0]);
    double close_price = iClose(m_symbol, timeframe, 1); // قیمت بسته شدن کندل تاییدیه

    if (is_buy)
    {
        // برای خرید، قیمت باید بالای ابر باشه
        return (close_price > high_kumo);
    }
    else // is_sell
    {
        // برای فروش، قیمت باید پایین ابر باشه
        return (close_price < low_kumo);
    }
}

۲. تابع CStrategyManager::CheckAtrFilter() (اصلاح شده)
این تابع فیلتر ATR رو بر اساس تایم‌فریم انتخابی بررسی می‌کنه.
//+------------------------------------------------------------------+
//| تابع کمکی برای بررسی فیلتر ATR                                   |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckAtrFilter(ENUM_TIMEFRAMES timeframe)
{
    // اگر فیلتر ATR فعال نبود، همیشه true برمی‌گرداند
    if (!m_settings.enable_atr_filter)
    {
        return true;
    }
    
    // یک هندل ATR جدید با تایم‌فریم انتخابی می‌سازیم
    int atr_handle = iATR(m_symbol, timeframe, m_settings.atr_filter_period);
    if (atr_handle == INVALID_HANDLE)
    {
        Log("فیلتر ATR رد شد چون هندل آن نامعتبر است.");
        return false;
    }
    
    double atr_value_buffer[];
    if(CopyBuffer(atr_handle, 0, 1, 1, atr_value_buffer) < 1)
    {
       Log("خطا: داده کافی برای فیلتر ATR موجود نیست.");
       IndicatorRelease(atr_handle);
       return false;
    }
    
    // هندل را آزاد می‌کنیم
    IndicatorRelease(atr_handle);
    
    double current_atr = atr_value_buffer[0];
    
    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT);
    double min_atr_threshold = m_settings.atr_filter_min_value_pips * point;
    
    // برای جفت‌ارزهای ۵ رقمی (و ۳ رقمی)، مقدار پیپ را در ۱۰ ضرب می‌کنیم
    if(_Digits == 3 || _Digits == 5)
    {
        min_atr_threshold *= 10;
    }

    return (current_atr >= min_atr_threshold);
}

۳. تابع CStrategyManager::CheckAdxFilter() (اصلاح شده)
این تابع فیلتر ADX رو بر اساس تایم‌فریم انتخابی بررسی می‌کنه.
//+------------------------------------------------------------------+
//| تابع کمکی برای بررسی فیلتر قدرت و جهت روند ADX                   |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckAdxFilter(bool is_buy, ENUM_TIMEFRAMES timeframe) 
{  
    // اگر فیلتر ADX فعال نبود، همیشه true برمی‌گرداند
    if (!m_settings.enable_adx_filter)
    {
        return true;
    }
    
    double adx_buffer[1], di_plus_buffer[1], di_minus_buffer[1];  
    
    // یک هندل ADX جدید با تایم‌فریم انتخابی می‌سازیم
    int adx_handle = iADX(m_symbol, timeframe, m_settings.adx_period);
    
    if (adx_handle == INVALID_HANDLE || CopyBuffer(adx_handle, 0, 1, 1, adx_buffer) < 1 || 
        CopyBuffer(adx_handle, 1, 1, 1, di_plus_buffer) < 1 || 
        CopyBuffer(adx_handle, 2, 1, 1, di_minus_buffer) < 1)
    {
        Log("داده کافی برای فیلتر ADX موجود نیست.");
        if(adx_handle != INVALID_HANDLE) IndicatorRelease(adx_handle);
        return false;
    }
    
    // هندل را آزاد می‌کنیم
    IndicatorRelease(adx_handle);
    
    // شرط ۱: آیا قدرت روند از حد آستانه ما بیشتر است؟
    if (adx_buffer[0] <= m_settings.adx_threshold) 
    {
        return false;
    }
    
    // شرط ۲: آیا جهت روند با جهت سیگنال ما یکی است؟
    if (is_buy)
    {
        return (di_plus_buffer[0] > di_minus_buffer[0]); // برای خرید، DI+ باید بالای DI- باشد
    }
    else // is_sell
    {
        return (di_minus_buffer[0] > di_plus_buffer[0]); // برای فروش، DI- باید بالای DI+ باشد
    }
}

خلاصه و تاییدیه نهایی
تمام خطاهای مربوط به توابع فیلترها که بهشون اشاره کردی، با این اصلاحات رفع می‌شن. حالا این سه تابع:
 * ورودی timeframe رو به درستی دریافت می‌کنن.
 * هندل اندیکاتور رو با تایم‌فریم انتخابی می‌سازن و در نهایت آزاد می‌کنن.
 * منطق فیلتر رو به درستی اجرا می‌کنن.
با این تغییرات، دیگه هیچ خطایی نباید داشته باشی و سیستم به طور کامل و یکپارچه کار می‌کنه. 😎
