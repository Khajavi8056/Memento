لاک رو ببین

//#####$######### FILE: Memento.mq5###############
//+------------------------------------------------------------------+
//|                                                      Memento.mq5 |
//|                                  Copyright 2025,hipoalgoritm |
//|                                                  Final & Bulletproof |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025,hipoalgoritm"
#property link      "https://www.mql5.com"
#property version   "7.0" // یکپارچه‌سازی فیلتر رژیم بازار و قابلیت MTF
#property description "اکسپرت معاملاتی پیشرفته ممنتو بر اساس استراتژی کراس سه گانه ایچیموکو"

#include <Trade\Trade.mqh>
#include <Object.mqh>

// --- کتابخانه‌های اصلی پروژه ---
#include "set.mqh"
#include "IchimokuLogic.mqh"
#include "VisualManager.mqh"
#include "TrailingStopManager.mqh"
#include "MarketRegimeDetector.mqh" // +++ NEW: کتابخانه تشخیص رژیم بازار
#include "licensed.mqh"

//--- متغیرهای سراسری
SSettings               g_settings;
string                  g_symbols_array[];
CStrategyManager* g_symbol_managers[];
CTrailingStopManager    g_trailing_stop;
CMarketRegimeEngine     g_regime_engine; // +++ NEW: نمونه سراسری از موتور رژیم بازار
bool                    g_dashboard_needs_update = true;

//+------------------------------------------------------------------+
//| تابع اصلی مقداردهی اولیه                                         |
//+------------------------------------------------------------------+
int OnInit()
{
    //--- ✅ بخش مقداردهی اولیه تنظیمات (بازنویسی شده برای نسخه ۷.۰) ✅ ---

    // 1. تنظیمات عمومی
    g_settings.enable_dashboard           = Inp_Enable_Dashboard;
    g_settings.symbols_list               = Inp_Symbols_List;
    g_settings.magic_number               = Inp_Magic_Number;
    g_settings.enable_logging             = Inp_Enable_Logging;

    // 2. تنظیمات ایچیموکو
    g_settings.ichimoku_timeframe         = Inp_Ichimoku_Timeframe; // +++ NEW
    g_settings.tenkan_period              = Inp_Tenkan_Period;
    g_settings.kijun_period               = Inp_Kijun_Period;
    g_settings.senkou_period              = Inp_Senkou_Period;
    g_settings.chikou_period              = Inp_Chikou_Period;

    // 3. تنظیمات سیگنال و تاییدیه
    g_settings.signal_mode                = Inp_Signal_Mode;
    g_settings.confirmation_type          = Inp_Confirmation_Type;
    g_settings.grace_period_candles       = Inp_Grace_Period_Candles;
    g_settings.talaqi_calculation_mode    = Inp_Talaqi_Calculation_Mode;
    g_settings.talaqi_atr_multiplier      = Inp_Talaqi_ATR_Multiplier;
    g_settings.talaqi_distance_in_points  = Inp_Talaqi_Distance_in_Points;
    g_settings.talaqi_kumo_factor         = Inp_Talaqi_Kumo_Factor;

    // 4. تنظیمات حد ضرر
    g_settings.stoploss_type              = Inp_StopLoss_Type;
    g_settings.sl_atr_multiplier          = Inp_SL_ATR_Multiplier;
    g_settings.sl_lookback_period         = Inp_SL_Lookback_Period;
    g_settings.sl_buffer_multiplier       = Inp_SL_Buffer_Multiplier;
    g_settings.flat_kijun_period          = Inp_Flat_Kijun_Period;
    g_settings.flat_kijun_min_length      = Inp_Flat_Kijun_Min_Length;
    g_settings.pivot_lookback             = Inp_Pivot_Lookback;
    g_settings.enable_sl_vol_regime       = Inp_Enable_SL_Vol_Regime;
    g_settings.sl_vol_regime_atr_period   = Inp_SL_Vol_Regime_ATR_Period;
    g_settings.sl_vol_regime_ema_period   = Inp_SL_Vol_Regime_EMA_Period;
    g_settings.sl_high_vol_multiplier     = Inp_SL_High_Vol_Multiplier;
    g_settings.sl_low_vol_multiplier      = Inp_SL_Low_Vol_Multiplier;

    // 5. تنظیمات مدیریت سرمایه
    g_settings.risk_percent_per_trade     = Inp_Risk_Percent_Per_Trade;
    g_settings.take_profit_ratio          = Inp_Take_Profit_Ratio;
    g_settings.max_trades_per_symbol      = Inp_Max_Trades_Per_Symbol;
    g_settings.max_total_trades           = Inp_Max_Total_Trades;

    // 6. تنظیمات گرافیکی
    g_settings.object_size_multiplier     = Inp_Object_Size_Multiplier;
    g_settings.bullish_color              = Inp_Bullish_Color;
    g_settings.bearish_color              = Inp_Bearish_Color;
    
    // 7. فیلترهای ورود (نسخه جدید و ساده شده)
    g_settings.enable_regime_filter       = Inp_Enable_Regime_Filter; // +++ NEW
    g_settings.enable_kumo_filter         = Inp_Enable_Kumo_Filter;

    // --- بخش ۸ (منطق خروج پیچیده) حذف شد ---

    //------------------------------------------------------------------
    //--- راه‌اندازی ماژول‌ها ---

    int symbols_count = StringSplit(g_settings.symbols_list, ',', g_symbols_array);
    if (symbols_count == 0) {
        Print("خطا: هیچ نمادی برای معامله مشخص نشده است.");
        return INIT_FAILED;
    }

    ArrayResize(g_symbol_managers, symbols_count);
    for (int i = 0; i < symbols_count; i++) {
        string sym = g_symbols_array[i];
        StringTrimLeft(sym);
        StringTrimRight(sym);
        g_symbol_managers[i] = new CStrategyManager(sym, g_settings);
        if (g_symbol_managers[i].Init() == false) {
            Print("مقداردهی اولیه مدیر استراتژی برای نماد ", sym, " با خطا مواجه شد. عملیات متوقف می‌شود.");
            // پاکسازی در صورت خطا
             for (int j = 0; j <= i; j++) {
                if(CheckPointer(g_symbol_managers[j])==POINTER_DYNAMIC) delete g_symbol_managers[j];
            }
            ArrayFree(g_symbol_managers);
            return INIT_FAILED;
        }
    }
    Print("اکسپرت Memento با موفقیت برای نمادهای زیر مقداردهی اولیه شد: ", g_settings.symbols_list);

    // +++ NEW: راه‌اندازی موتور رژیم بازار +++
    // این موتور روی چارت اصلی اجرا می‌شود و نتایجش برای تمام مدیرهای استراتژی قابل استفاده است.
    if(g_settings.enable_regime_filter)
    {
       if(!g_regime_engine.Initialize(_Symbol, _Period, g_settings.enable_logging))
       {
          Print("خطا: راه‌اندازی موتور تشخیص رژیم بازار ناموفق بود! فیلتر غیرفعال می‌شود.");
          g_settings.enable_regime_filter = false; // در صورت خطا، فیلتر را غیرفعال کن
       }
    }
    
    g_trailing_stop.Init(g_settings.magic_number);
    EventSetTimer(1);
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| تابع پایان اکسپرت (پاکسازی)                                      |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    EventKillTimer();
    //--- پاکسازی مدیرهای استراتژی
    for (int i = 0; i < ArraySize(g_symbol_managers); i++)
    {
        if(CheckPointer(g_symbol_managers[i])==POINTER_DYNAMIC)
        {
            delete g_symbol_managers[i];
        }
    }
    ArrayFree(g_symbol_managers);

    //--- پاک کردن تمام اشیاء گرافیکی با پیشوند صحیح
    ObjectsDeleteAll(0, "MEMENTO_UI_");
    // موتور رژیم بازار و تریلینگ استاپ به صورت خودکار در دیستراکتور خود پاکسازی می‌شوند.
    ChartRedraw();
    Print("اکسپرت Memento با موفقیت غیرفعال شد. Reason: ", reason);
}

//+------------------------------------------------------------------+
//| تابع تیک (برای چک کردن لایسنس)                                    |
//+------------------------------------------------------------------+
void OnTick(void)
{
    if(CheckLicenseExpiry() == false)
    {
        ExpertRemove();
        return;
    }
}

//+------------------------------------------------------------------+
//| تابع تایمر (حلقه اصلی منطق اکسپرت)                               |
//+------------------------------------------------------------------+
void OnTimer()
{
    // +++ NEW: گام اول - تحلیل وضعیت کلی بازار +++
    // قبل از هر کاری، موتور رژیم بازار را آپدیت می‌کنیم.
    if(g_settings.enable_regime_filter)
    {
        g_regime_engine.ProcessNewBar();
    }

    //--- اجرای منطق تریلینگ استاپ برای تمام پوزیشن‌های باز
    g_trailing_stop.Process();
    
    //--- اجرای منطق سیگنال‌یابی برای تمام نمادهای تحت مدیریت
    for (int i = 0; i < ArraySize(g_symbol_managers); i++)
    {
        if (g_symbol_managers[i] != NULL)
        {
            g_symbol_managers[i].ProcessNewBar();
        }
    }

    //--- آپدیت هوشمند داشبورد فقط در صورت نیاز
    if (g_dashboard_needs_update)
    {
        // پیدا کردن نمونه‌ای از منیجر که مسئول چارت اصلی است
        for (int i = 0; i < ArraySize(g_symbol_managers); i++)
        {
            if (g_symbol_managers[i] != NULL && g_symbol_managers[i].GetSymbol() == _Symbol)
            {
                g_symbol_managers[i].UpdateMyDashboard();
                if(g_settings.enable_logging) Print("داشبورد به دلیل رویداد معاملاتی آپدیت شد.");
                break; // بعد از آپدیت از حلقه خارج شو
            }
        }
        g_dashboard_needs_update = false; // پرچم را برای آپدیت بعدی ریست کن
    }
}

//+------------------------------------------------------------------+
//| تابع رویدادهای معاملاتی                                           |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
    // ما فقط به رویدادهایی که یک معامله به تاریخچه اضافه می‌کنند علاقه داریم
    if (trans.type == TRADE_TRANSACTION_DEAL_ADD && trans.deal > 0)
    {
        // چک می‌کنیم معامله مربوط به همین اکسپرت باشه
        if (HistoryDealSelect(trans.deal) && HistoryDealGetInteger(trans.deal, DEAL_MAGIC) == (long)g_settings.magic_number)
        {
            // اگر معامله از نوع خروج از پوزیشن بود (بسته شدن)
            if(HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_OUT)
            {
                string deal_symbol = HistoryDealGetString(trans.deal, DEAL_SYMBOL);
                for(int i = 0; i < ArraySize(g_symbol_managers); i++)
                {
                    if(g_symbol_managers[i] != NULL && g_symbol_managers[i].GetSymbol() == deal_symbol)
                    {
                        CVisualManager *visual_manager = g_symbol_managers[i].GetVisualManager();
                        if(visual_manager != NULL)
                        {
                            int symbol_index = visual_manager.GetSymbolIndex(deal_symbol);
                            if(symbol_index != -1)
                            {
                                // و دفترچه حسابداری را آپدیت می‌کنیم
                                visual_manager.UpdateDashboardCache(symbol_index, 
                                                                    HistoryDealGetDouble(trans.deal, DEAL_PROFIT),
                                                                    HistoryDealGetDouble(trans.deal, DEAL_COMMISSION),
                                                                    HistoryDealGetDouble(trans.deal, DEAL_SWAP));
                            }
                        }
                        break;
                    }
                }
            }
            // در هر صورت (چه باز شدن و چه بسته شدن) داشبورد نیاز به آپدیت دارد
            g_dashboard_needs_update = true;
        }
    }
}

//+------------------------------------------------------------------+
//| تابع مدیریت رویدادهای چارت (برای کلیک روی دکمه)                   |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam)
{
    if(id == CHARTEVENT_OBJECT_CLICK)
    {
        for(int i = 0; i < ArraySize(g_symbol_managers); i++)
        {
            if(g_symbol_managers[i] != NULL && g_symbol_managers[i].GetSymbol() == _Symbol)
            {
                // رویداد را برای پردازش به مدیر گرافیک ارسال کن
                g_symbol_managers[i].GetVisualManager().OnChartEvent(id, lparam, dparam, sparam);
                break;
            }
        }
    }
}

//+------------------------------------------------------------------+
//| تابع بهینه‌سازی سفارشی (بدون تغییر)                                |
//+------------------------------------------------------------------+
//--- گروه: تنظیمات بهینه‌سازی سفارشی ---
input group "  تنظیمات بهینه‌سازی سفارشی";
input int InpMinTradesPerYear = 30; // حداقل تعداد معاملات قابل قبول در یک سال
input int InpMaxAcceptableDrawdown = 15;

// توابع OnTester و CalculateAdvancedMetrics بدون هیچ تغییری باقی می‌مانند
// ... (کد این دو تابع همانند نسخه قبلی است و برای خلاصه شدن اینجا تکرار نشده)
// ...
double OnTester()
{
   // --- 1. گرفتن تمام آمارهای استاندارد مورد نیاز ---
   double total_trades         = TesterStatistics(STAT_TRADES);
   double net_profit           = TesterStatistics(STAT_PROFIT);
   double profit_factor        = TesterStatistics(STAT_PROFIT_FACTOR);
   double sharpe_ratio         = TesterStatistics(STAT_SHARPE_RATIO);
   double max_balance_drawdown_percent = TesterStatistics(STAT_BALANCE_DDREL_PERCENT);

   // --- 2. محاسبه حداقل تعداد معاملات مورد نیاز (بدون تغییر) ---
   datetime startDate = 0, endDate = 0;
   if(HistoryDealsTotal() > 0)
     {
      startDate = (datetime)HistoryDealGetInteger(0, DEAL_TIME);
      endDate   = (datetime)HistoryDealGetInteger(HistoryDealsTotal() - 1, DEAL_TIME);
     }
   double duration_days = (endDate > startDate) ? double(endDate - startDate) / (24.0 * 3600.0) : 1.0;
   double required_min_trades = floor((duration_days / 365.0) * InpMinTradesPerYear);
   if(required_min_trades < 10) required_min_trades = 10;

   // --- 3. فیلترهای ورودی نهایی (بدون تغییر) ---
   if(total_trades < required_min_trades || profit_factor < 1.1 || sharpe_ratio <= 0 || net_profit <= 0)
     {
      return 0.0;
     }

   // --- 4. محاسبه معیارهای پیشرفته (بدون تغییر) ---
   double r_squared = 0, downside_consistency = 0;
   CalculateAdvancedMetrics(r_squared, downside_consistency);

   // --- 5. *** مهندسی امتیاز: محاسبه "ضریب مجازات" با منحنی کسینوسی *** ---
   double drawdown_penalty_factor = 0.0;
   if (max_balance_drawdown_percent < InpMaxAcceptableDrawdown && InpMaxAcceptableDrawdown > 0)
   {
      // دراودان رو به یک زاویه بین 0 تا 90 درجه (π/2 رادیان) تبدیل می‌کنیم
      double angle = (max_balance_drawdown_percent / InpMaxAcceptableDrawdown) * (M_PI / 2.0);

      // ضریب مجازات، کسینوس اون زاویه است. هرچی زاویه (دراودان) بیشتر، کسینوس (امتیاز) کمتر
      drawdown_penalty_factor = cos(angle);
   }
   // اگر دراودان بیشتر از حد مجاز باشه، ضریب صفر می‌مونه و کل پاس رد میشه

   // --- 6. محاسبه امتیاز نهایی جامع با فرمول جدید و پیوسته ---
   double final_score = 0.0;
   if(drawdown_penalty_factor > 0)
   {
      // استفاده از log برای نرمال‌سازی و جلوگیری از تاثیر بیش از حد اعداد بزرگ
      double trades_factor = log(total_trades + 1); // +1 برای جلوگیری از log(0)
      double net_profit_factor = log(net_profit + 1);

      final_score = (profit_factor * sharpe_ratio * r_squared * downside_consistency * trades_factor * net_profit_factor)
                     * drawdown_penalty_factor; // ضرب در ضریب مجازات جدید و هوشمند
   }

   // --- 7. چاپ نتیجه برای دیباگ ---
   PrintFormat("نتیجه: Trades=%d, PF=%.2f, Sharpe=%.2f, R²=%.3f, BalDD=%.2f%%, Penalty=%.2f -> امتیاز: %.4f",
               (int)total_trades, profit_factor, sharpe_ratio, r_squared, max_balance_drawdown_percent, drawdown_penalty_factor, final_score);

   return final_score;
}

struct EquityPoint { datetime time; double balance; };
struct MonthlyTrades { int year; int month; int count; };
void CalculateAdvancedMetrics(double &r_squared, double &downside_consistency)
{
   r_squared = 0;
   downside_consistency = 1.0;
   if(!HistorySelect(0, TimeCurrent())) return;
   uint total_deals = HistoryDealsTotal();
   if(total_deals < 5) return;
   EquityPoint equity_curve[];
   ArrayResize(equity_curve, (int)total_deals + 2);
   double final_balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double net_profit = TesterStatistics(STAT_PROFIT);
   double initial_balance = final_balance - net_profit;
   double current_balance = initial_balance;
   equity_curve[0].time = (datetime)HistoryDealGetInteger(0, DEAL_TIME) - 1;
   equity_curve[0].balance = current_balance;
   int equity_points = 1;
   for(uint i = 0; i < total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
        {
         current_balance += HistoryDealGetDouble(ticket, DEAL_PROFIT) + HistoryDealGetDouble(ticket, DEAL_COMMISSION) + HistoryDealGetDouble(ticket, DEAL_SWAP);
         equity_curve[equity_points].time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         equity_curve[equity_points].balance = current_balance;
         equity_points++;
        }
     }
   ArrayResize(equity_curve, equity_points);
   if(equity_points < 3) return;
   double sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0;
   for(int i = 0; i < equity_points; i++)
     {
      double x = i + 1.0; double y = equity_curve[i].balance;
      sum_x += x; sum_y += y; sum_xy += x * y; sum_x2 += x*x; sum_y2 += y*y;
     }
   double n = equity_points;
   double den_part1 = (n*sum_x2) - (sum_x*sum_x);
   double den_part2 = (n*sum_y2) - (sum_y*sum_y);
   if(den_part1 > 0 && den_part2 > 0)
     {
      double r = ((n*sum_xy) - (sum_x*sum_y)) / sqrt(den_part1 * den_part2);
      r_squared = r*r;
     }
   MonthlyTrades monthly_counts[];
   int total_months = 0;
   for(uint i=0; i<total_deals; i++)
     {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
        {
         datetime deal_time = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
         MqlDateTime dt;
         TimeToStruct(deal_time, dt);
         int month_idx = -1;
         for(int j=0; j<total_months; j++)
           {
            if(monthly_counts[j].year == dt.year && monthly_counts[j].month == dt.mon)
              {
               month_idx = j;
               break;
              }
           }
         if(month_idx == -1)
           {
            ArrayResize(monthly_counts, total_months + 1);
            monthly_counts[total_months].year = dt.year;
            monthly_counts[total_months].month = dt.mon;
            monthly_counts[total_months].count = 1;
            total_months++;
           }
         else
           {
            monthly_counts[month_idx].count++;
           }
        }
     }
   if(total_months <= 1)
     {
      downside_consistency = 1.0;
      return;
     }
   double target_trades_per_month = InpMinTradesPerYear / 12.0;
   if (target_trades_per_month < 1) target_trades_per_month = 1;
   double sum_of_squared_downside_dev = 0;
   for(int i = 0; i < total_months; i++)
     {
      if(monthly_counts[i].count < target_trades_per_month)
        {
         double deviation = target_trades_per_month - monthly_counts[i].count;
         sum_of_squared_downside_dev += deviation * deviation;
        }
     }
   double downside_variance = sum_of_squared_downside_dev / total_months;
   double downside_deviation = sqrt(downside_variance);
   downside_consistency = 1.0 / (1.0 + downside_deviation);
}



//#####$#########  FILE: set.mqh #####$######### 
//+------------------------------------------------------------------+
//|                                                                  |
//|                    Project: Memento (By HipoAlgorithm)           |
//|                    File: set.mqh (EA Settings)                   |
//|                    Version: 7.0 (MTF & Regime Filter Integration)|
//|                    © 2025, Mohammad & Gemini                     |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "© 2025, hipoalgoritm"
#property link      "https://www.mql5.com"
#property version   "7.0" // یکپارچه‌سازی فیلتر رژیم بازار و قابلیت MTF

//--- انواع شمارشی برای خوانایی بهتر کد
enum E_Confirmation_Mode { MODE_CLOSE_ONLY, MODE_OPEN_AND_CLOSE };

enum E_SL_Mode
{
    MODE_COMPLEX,         // پیچیده (کیجون فلت, پیوت و...)
    MODE_SIMPLE,          // ساده (بر اساس رنگ مخالف کندل)
    MODE_ATR              // پویا (مبتنی بر ATR)
};

enum E_Signal_Mode { MODE_REPLACE_SIGNAL, MODE_SIGNAL_CONTEST };

enum E_Talaqi_Mode
{
    TALAQI_MODE_MANUAL,     // دستی (بر اساس پوینت)
    TALAQI_MODE_KUMO,       // هوشمند (بر اساس ضخامت کومو)
    TALAQI_MODE_ATR,        // پویا (مبتنی بر ATR)
    TALAQI_MODE_ZSCORE,     // آماری (بر اساس Z-Score)
    TALAQI_MODE_MFCI        // شاخص چندعاملی (Multi-Factor Index)
};


//+------------------------------------------------------------------+
//|                      تنظیمات ورودی اکسپرت                         |
//+------------------------------------------------------------------+

// ---=== ⚙️ 1. تنظیمات عمومی (General) ⚙️ ===---
input group           "          ---=== ⚙️ 1. تنظیمات عمومی (General) ⚙️ ===---";
input bool            Inp_Enable_Dashboard  = true;                   // ✅ فعال/غیرفعال کردن داشبورد اطلاعاتی
input string          Inp_Symbols_List      = "EURUSD,GBPUSD,XAUUSD"; // لیست نمادها (جدا شده با کاما)
input int             Inp_Magic_Number      = 12345;                  // شماره جادویی معاملات
input bool            Inp_Enable_Logging    = true;                   // فعال/غیرفعال کردن لاگ‌ها

// ---=== 📈 2. تنظیمات ایچیموکو (Ichimoku Baseline) 📈 ===---
input group           "      ---=== 📈 2. تنظیمات ایچیموکو (Ichimoku) 📈 ===---";
// +++ NEW: قابلیت اجرای استراتژی روی تایم فریم دلخواه +++
input ENUM_TIMEFRAMES Inp_Ichimoku_Timeframe = PERIOD_CURRENT;         // تایم فریم محاسبات ایچیموکو
input int             Inp_Tenkan_Period     = 10;                     // دوره تنکان-سن (بهینه شده)
input int             Inp_Kijun_Period      = 28;                     // دوره کیجون-سن (بهینه شده)
input int             Inp_Senkou_Period     = 55;                     // دوره سنکو اسپن بی (بهینه شده)
input int             Inp_Chikou_Period     = 26;                     // دوره چیکو اسپن (نقطه مرجع)

// ---=== 🎯 3. سیگنال و تاییدیه (Signal & Confirmation) 🎯 ===---
input group           "---=== 🎯 3. سیگنال و تاییدیه (Signal & Confirmation) 🎯 ===---";
input E_Signal_Mode   Inp_Signal_Mode         = MODE_SIGNAL_CONTEST;  // روش مدیریت سیگنال
input E_Confirmation_Mode Inp_Confirmation_Type = MODE_CLOSE_ONLY;    // نوع تایید قیمت نهایی (بهینه شده)
input int             Inp_Grace_Period_Candles= 4;                      // تعداد کندل مهلت برای تاییدیه (بهینه شده)

// --- زیرگروه تنظیمات تلاقی (Confluence) ---
input group           "         --- تنظیمات تلاقی (Confluence) ---";
input E_Talaqi_Mode   Inp_Talaqi_Calculation_Mode = TALAQI_MODE_ATR;    // روش محاسبه فاصله تلاقی (بهینه شده)
input double          Inp_Talaqi_ATR_Multiplier     = 0.28;             // [ATR Mode] ضریب ATR برای تلاقی (بهینه شده)
input double          Inp_Talaqi_Distance_in_Points = 3.0;              // [MANUAL Mode] فاصله تلاقی (بر اساس پوینت)
input double          Inp_Talaqi_Kumo_Factor      = 0.2;              // [KUMO Mode] ضریب تلاقی (درصد ضخامت کومو)


// ---=== 🛡️ 4. مدیریت حد ضرر (Stop Loss) 🛡️ ===---
input group           "       ---=== 🛡️ 4. مدیریت حد ضرر (Stop Loss) 🛡️ ===---";
input E_SL_Mode       Inp_StopLoss_Type       = MODE_COMPLEX;           // روش محاسبه استاپ لاس
input double          Inp_SL_ATR_Multiplier   = 2.2;                    // [ATR Mode] ضریب ATR برای حد ضرر (بهینه شده)
input int             Inp_SL_Lookback_Period  = 15;                     // [SIMPLE] دوره نگاه به عقب برای یافتن سقف/کف
input double          Inp_SL_Buffer_Multiplier = 3.0;                   // [SIMPLE/COMPLEX] ضریب بافر
input int             Inp_Flat_Kijun_Period   = 50;                     // [COMPLEX] تعداد کندل برای جستجوی کیجون فلت
input int             Inp_Flat_Kijun_Min_Length = 5;                    // [COMPLEX] حداقل طول کیجون فلت
input int             Inp_Pivot_Lookback      = 30;                     // [COMPLEX] تعداد کندل برای جستجوی پیوت

// --- SL پویا بر اساس نوسان ---
input group           "    --- SL پویا بر اساس نوسان ---";
input bool            Inp_Enable_SL_Vol_Regime = false;                 // فعال سازی SL پویا با رژیم نوسان
input int             Inp_SL_Vol_Regime_ATR_Period = 14;                // [پویا] دوره ATR برای محاسبه نوسان
input int             Inp_SL_Vol_Regime_EMA_Period = 20;                // [پویا] دوره EMA برای تعریف خط رژیم نوسان
input double          Inp_SL_High_Vol_Multiplier = 2.2;                 // [پویا] ضریب ATR در رژیم نوسان بالا
input double          Inp_SL_Low_Vol_Multiplier = 1.5;                  // [پویا] ضریب ATR در رژیم نوسان پایین


// ---=== 💰 5. مدیریت سرمایه (Money Management) 💰 ===---
input group           " ---=== 💰 5. مدیریت سرمایه (Money Management) 💰 ===---";
input double          Inp_Risk_Percent_Per_Trade = 0.7;                 // درصد ریسک در هر معامله (بهینه شده)
input double          Inp_Take_Profit_Ratio   = 1.9;                    // نسبت ریسک به ریوارد برای حد سود (بهینه شده)
input int             Inp_Max_Trades_Per_Symbol = 1;                    // حداکثر معاملات باز برای هر نماد
input int             Inp_Max_Total_Trades    = 5;                      // حداکثر کل معاملات باز

// ---=== 🎨 6. تنظیمات گرافیکی (Visuals) 🎨 ===---
input group           "        ---=== 🎨 6. تنظیمات گرافیکی (Visuals) 🎨 ===---";
input double          Inp_Object_Size_Multiplier = 1.0;                 // ضریب اندازه اشیاء گرافیکی
input color           Inp_Bullish_Color       = clrLimeGreen;           // رنگ سیگنال و اشیاء خرید
input color           Inp_Bearish_Color       = clrRed;                 // رنگ سیگنال و اشیاء فروش

// ---=== 🚦 7. فیلترهای ورود (Entry Filters) 🚦 ===---
input group           "   ---=== 🚦 7. فیلترهای ورود (Entry Filters) 🚦 ===---";
// +++ NEW: فیلتر اصلی برای تشخیص شرایط بازار +++
input bool            Inp_Enable_Regime_Filter = true;                  // ✅ [فیلتر رژیم بازار]: فعال/غیرفعال (تشخیص رنج/روند)
// --- فیلتر ساده کومو ---
input bool            Inp_Enable_Kumo_Filter   = true;                  // ✅ [فیلتر کومو]: معامله نکردن داخل ابر

// ---=== 🎯 8. منطق خروج (Exit Logic) 🎯 ===---
// در این نسخه، منطق‌های خروج پیچیده حذف شده و به حد سود و حد ضرر و تریلینگ استاپ متکی هستیم.
input group "       ---=== 🎯 8. منطق خروج (Exit Logic) 🎯 ===---";


//+------------------------------------------------------------------+
//|     ساختار اصلی برای نگهداری تمام تنظیمات ورودی (SSettings)       |
//+------------------------------------------------------------------+
struct SSettings
{
    // 1. General
    bool                enable_dashboard;
    string              symbols_list;
    int                 magic_number;
    bool                enable_logging;

    // 2. Ichimoku
    ENUM_TIMEFRAMES     ichimoku_timeframe; // +++ NEW
    int                 tenkan_period;
    int                 kijun_period;
    int                 senkou_period;
    int                 chikou_period;

    // 3. Signal & Confirmation
    E_Signal_Mode       signal_mode;
    E_Confirmation_Mode confirmation_type;
    int                 grace_period_candles;

    // 3.1. Talaqi
    E_Talaqi_Mode       talaqi_calculation_mode;
    double              talaqi_distance_in_points;
    double              talaqi_kumo_factor;
    double              talaqi_atr_multiplier;

    // 4. Stop Loss
    E_SL_Mode           stoploss_type;
    double              sl_atr_multiplier;
    int                 sl_lookback_period;
    double              sl_buffer_multiplier;
    int                 flat_kijun_period;
    int                 flat_kijun_min_length;
    int                 pivot_lookback;

    // 4.1. Dynamic SL (Volatility Regime)
    bool                enable_sl_vol_regime;
    int                 sl_vol_regime_atr_period;
    int                 sl_vol_regime_ema_period;
    double              sl_high_vol_multiplier;
    double              sl_low_vol_multiplier;

    // 5. Money Management
    double              risk_percent_per_trade;
    double              take_profit_ratio;
    int                 max_trades_per_symbol;
    int                 max_total_trades;

    // 6. Visuals
    double              object_size_multiplier;
    color               bullish_color;
    color               bearish_color;

    // 7. Entry Filters
    bool                enable_regime_filter; // +++ NEW
    bool                enable_kumo_filter;

    // 8. Exit Logic - (بخش خروج‌های پیچیده حذف شد)
};





//###############  FILE: IchimokuLogic.mqh   ###############
//+------------------------------------------------------------------+
//|                                     IchimokuLogic.mqh            |
//|                          © 2025, hipoalgoritm                   |
//+------------------------------------------------------------------+
#property copyright "© 2025, hipoalgoritm"
#property link      "https://www.mql5.com"
#property version   "2.2" 
#include "set.mqh"
#include <Trade\Trade.mqh>
#include <Trade\SymbolInfo.mqh>
#include <Object.mqh>
#include "VisualManager.mqh"
#include <MovingAverages.mqh>

//+++ NEW: تعریف موتور رژیم بازار +++
extern CMarketRegimeEngine g_regime_engine;

//--- تعریف ساختار سیگنال
struct SPotentialSignal
{
    datetime        time;
    bool            is_buy;
    int             grace_candle_count;
    
    // سازنده کپی
    SPotentialSignal(const SPotentialSignal &other)
    {
        time = other.time;
        is_buy = other.is_buy;
        grace_candle_count = other.grace_candle_count;
    }
    // سازنده پیش‌فرض
    SPotentialSignal()
    {
       // خالی می‌مونه
    }
};

//+------------------------------------------------------------------+
//| کلاس مدیریت استراتژی برای یک نماد خاص                           |
//+------------------------------------------------------------------+
class CStrategyManager
{
private:
    string              m_symbol;
    SSettings           m_settings;
    CTrade              m_trade;
   
    datetime            m_last_bar_time;
    
    // --- هندل های اندیکاتور ---
    int                 m_ichimoku_handle;
    int                 m_atr_handle;      

    // --- بافرهای داده ---
    double              m_tenkan_buffer[];
    double              m_kijun_buffer[];
    double              m_high_buffer[];
    double              m_low_buffer[];
    
    // --- مدیریت سیگنال ---
    SPotentialSignal    m_signal;
    bool                m_is_waiting;
    SPotentialSignal    m_potential_signals[];
    CVisualManager*     m_visual_manager;
    
    //--- توابع کمکی ---
    void Log(string message);
    
    // --- منطق اصلی سیگنال ---
    void AddOrUpdatePotentialSignal(bool is_buy);
    bool CheckTripleCross(bool& is_buy);
    bool CheckFinalConfirmation(bool is_buy);
    
    // --- فیلترهای ورود ---
    bool AreAllFiltersPassed(bool is_buy);
    bool CheckKumoFilter();

    //--- محاسبه استاپ لاس ---
    double CalculateStopLoss(bool is_buy, double entry_price);
    double CalculateAtrStopLoss(bool is_buy, double entry_price);
    double GetTalaqiTolerance(int reference_shift);
    double CalculateAtrTolerance(int reference_shift);
    double CalculateDynamicTolerance(int reference_shift);
    double FindFlatKijun();
    double FindPivotKijun(bool is_buy);
    double FindPivotTenkan(bool is_buy);
    double FindBackupStopLoss(bool is_buy, double buffer);
    
    //--- مدیریت معاملات ---
    int CountSymbolTrades();
    int CountTotalTrades();
    void OpenTrade(bool is_buy);

public:
    CStrategyManager(string symbol, SSettings &settings);
    ~CStrategyManager();
    bool Init();
    void ProcessNewBar();
    string GetSymbol() const { return m_symbol; }
    void UpdateMyDashboard();
    CVisualManager* GetVisualManager() { return m_visual_manager; }
};

//+------------------------------------------------------------------+
//| کانستراکتور کلاس                                                |
//+------------------------------------------------------------------+
CStrategyManager::CStrategyManager(string symbol, SSettings &settings)
{
    m_symbol = symbol;
    m_settings = settings;
    m_last_bar_time = 0;
    m_is_waiting = false;
    ArrayFree(m_potential_signals);
    m_ichimoku_handle = INVALID_HANDLE;
    m_atr_handle = INVALID_HANDLE;
    m_visual_manager = new CVisualManager(m_symbol, m_settings);
}

//+------------------------------------------------------------------+
//| دیستراکتور کلاس                                                 |
//+------------------------------------------------------------------+
CStrategyManager::~CStrategyManager()
{
    if (m_visual_manager != NULL)
    {
        delete m_visual_manager;
        m_visual_manager = NULL;
    }

    if(m_ichimoku_handle != INVALID_HANDLE)
        IndicatorRelease(m_ichimoku_handle);
        
    if(m_atr_handle != INVALID_HANDLE)
        IndicatorRelease(m_atr_handle);
}

//+------------------------------------------------------------------+
//| آپدیت کردن داشبورد                                              |
//+------------------------------------------------------------------+
void CStrategyManager::UpdateMyDashboard() 
{ 
    if (m_visual_manager != NULL)
    {
        m_visual_manager.UpdateDashboard();
    }
}

//+------------------------------------------------------------------+
//| مقداردهی اولیه                                                  |
//+------------------------------------------------------------------+
bool CStrategyManager::Init()
{
    // همگام‌سازی تاریخچه با تایم‌فریم انتخابی
    int attempts = 0;
    while(iBars(m_symbol, m_settings.ichimoku_timeframe) < 200 && attempts < 100)
    {
        Sleep(100);
        MqlRates rates[];
        CopyRates(m_symbol, m_settings.ichimoku_timeframe, 0, 1, rates); 
        attempts++;
    }
    if (iBars(m_symbol, m_settings.ichimoku_timeframe) < 200)
    {
        Log("خطای بحرانی: پس از تلاش‌های مکرر، داده‌های کافی برای نماد " + m_symbol + " بارگذاری نشد.");
        return false;
    }

    m_trade.SetExpertMagicNumber(m_settings.magic_number);
    m_trade.SetTypeFillingBySymbol(m_symbol);
    
    // ساخت هندل ایچیموکو با تایم‌فریم انتخابی
    m_ichimoku_handle = iIchimoku(m_symbol, m_settings.ichimoku_timeframe, m_settings.tenkan_period, m_settings.kijun_period, m_settings.senkou_period);
    if (m_ichimoku_handle == INVALID_HANDLE)
    {
        Log("خطا در ایجاد اندیکاتور Ichimoku.");
        return false;
    }

    // ساخت هندل ATR برای محاسبات SL و تلاقی
    int atr_period_for_handle = (m_settings.enable_sl_vol_regime) ? m_settings.sl_vol_regime_atr_period : 14;
    m_atr_handle = iATR(m_symbol, m_settings.ichimoku_timeframe, atr_period_for_handle);
    if (m_atr_handle == INVALID_HANDLE)
    {
        Log("خطا در ایجاد اندیکاتور ATR برای محاسبات SL و تلاقی.");
        return false;
    }

    ArraySetAsSeries(m_tenkan_buffer, true);
    ArraySetAsSeries(m_kijun_buffer, true);
    ArraySetAsSeries(m_high_buffer, true);
    ArraySetAsSeries(m_low_buffer, true); 
    if (!m_visual_manager.Init())
    {
        Log("خطا در مقداردهی اولیه VisualManager.");
        return false;
    }

    if(m_symbol == _Symbol)
    {
        Print("--- DEBUG 1: Master instance found for '", m_symbol, "'. Calling InitDashboard...");
        m_visual_manager.InitDashboard();
    }
    
    Log("با موفقیت مقداردهی اولیه شد.");
    return true;
}

//+------------------------------------------------------------------+
//| تابع اصلی پردازش کندل جدید                                      |
//+------------------------------------------------------------------+
void CStrategyManager::ProcessNewBar()
{
    // --- گام ۰: آماده‌سازی و بررسی اولیه ---
    datetime current_bar_time = iTime(m_symbol, m_settings.ichimoku_timeframe, 0);
    
    if (current_bar_time == m_last_bar_time) 
        return; 
    
    m_last_bar_time = current_bar_time;
  
    // گیت کنترل اصلی - فیلتر رژیم بازار
    if(m_settings.enable_regime_filter)
    {
        RegimeResult regime = g_regime_engine.GetLastResult();
        if(regime.regime == REGIME_RANGE_CONSOLIDATION || regime.regime == REGIME_VOLATILITY_SQUEEZE)
        {
            return; // از پردازش این کندل خارج شو، چون بازار رنج است
        }
    }

    if(m_symbol == _Symbol && m_visual_manager != NULL)
    {
        m_visual_manager.CleanupOldObjects(200, m_settings.ichimoku_timeframe);
    }

    // --- حالت اول: منطق جایگزینی ---
    if (m_settings.signal_mode == MODE_REPLACE_SIGNAL)
    {
        bool is_new_signal_buy = false;
        if (CheckTripleCross(is_new_signal_buy))
        {
            if (m_is_waiting)
            {
                if (is_new_signal_buy != m_signal.is_buy)
                {
                    Log("[حالت جایگزینی] سیگنال جدید و مخالف پیدا شد! سیگنال قبلی کنسل شد.");
                    m_is_waiting = false;
                }
            }
            
            if (!m_is_waiting)
            {
                m_is_waiting = true;
                m_signal.time = iTime(m_symbol, m_settings.ichimoku_timeframe, m_settings.chikou_period);
                m_signal.is_buy = is_new_signal_buy;
                m_signal.grace_candle_count = 0;
                Log("[حالت جایگزینی] سیگنال اولیه " + (m_signal.is_buy ? "خرید" : "فروش") + " پیدا شد. ورود به حالت انتظار...");
                
                if(m_symbol == _Symbol && m_visual_manager != NULL) 
                    m_visual_manager.DrawTripleCrossRectangle(m_signal.is_buy, m_settings.chikou_period, m_settings.ichimoku_timeframe);
            }
        }
    
        if (m_is_waiting)
        {
            if (m_signal.grace_candle_count >= m_settings.grace_period_candles)
            {
                m_is_waiting = false;
                Log("[حالت جایگزینی] زمان تأیید سیگنال به پایان رسید و سیگنال رد شد.");
            }
            else if (CheckFinalConfirmation(m_signal.is_buy))
            {
                Log("[حالت جایگزینی] سیگنال " + (m_signal.is_buy ? "خرید" : "فروش") + " تأیید نهایی شد. بررسی فیلترها...");
                
                if (AreAllFiltersPassed(m_signal.is_buy))
                {
                    if(m_symbol == _Symbol && m_visual_manager != NULL) 
                        m_visual_manager.DrawConfirmationArrow(m_signal.is_buy, 1, m_settings.ichimoku_timeframe);
                    
                    OpenTrade(m_signal.is_buy);
                }
                else
                {
                    Log("❌ [حالت جایگزینی] معامله توسط فیلترهای نهایی رد شد.");
                }
                
                m_is_waiting = false; 
            }
            else
            {
                m_signal.grace_candle_count++;
                if(m_symbol == _Symbol && m_visual_manager != NULL) 
                    m_visual_manager.DrawScanningArea(m_signal.is_buy, m_settings.chikou_period, m_signal.grace_candle_count, m_settings.ichimoku_timeframe);
            }
        }
    }
    // --- حالت دوم: منطق مسابقه‌ای ---
    else if (m_settings.signal_mode == MODE_SIGNAL_CONTEST)
    {
        bool is_new_signal_buy = false;
        if (CheckTripleCross(is_new_signal_buy))
        {
            AddOrUpdatePotentialSignal(is_new_signal_buy);
        }

        if (ArraySize(m_potential_signals) > 0)
        {
            for (int i = ArraySize(m_potential_signals) - 1; i >= 0; i--)
            {
                if (m_potential_signals[i].grace_candle_count >= m_settings.grace_period_candles)
                {
                    Log("[حالت مسابقه‌ای] زمان نامزد " + (m_potential_signals[i].is_buy ? "خرید" : "فروش") + " به پایان رسید و از لیست حذف شد.");
                    ArrayRemove(m_potential_signals, i, 1);
                    continue;
                }
            
                if (CheckFinalConfirmation(m_potential_signals[i].is_buy))
                {
                    Log("🏆 [حالت مسابقه‌ای] برنده پیدا شد! سیگنال " + (m_potential_signals[i].is_buy ? "خرید" : "فروش") + " تأیید نهایی شد!");
                
                    if (AreAllFiltersPassed(m_potential_signals[i].is_buy))
                    {
                        if (m_symbol == _Symbol && m_visual_manager != NULL)
                            m_visual_manager.DrawConfirmationArrow(m_potential_signals[i].is_buy, 1, m_settings.ichimoku_timeframe);
                        
                        OpenTrade(m_potential_signals[i].is_buy);
                    }
                    else
                    {
                        Log("❌ [حالت مسابقه‌ای] معامله توسط فیلترهای نهایی رد شد.");
                    }
                    
                    bool winner_is_buy = m_potential_signals[i].is_buy;
                    Log("پاکسازی لیست انتظار: حذف تمام نامزدهای " + (winner_is_buy ? "خرید" : "فروش") + "...");
                    
                    for (int j = ArraySize(m_potential_signals) - 1; j >= 0; j--)
                    {
                        if (m_potential_signals[j].is_buy == winner_is_buy)
                        {
                            ArrayRemove(m_potential_signals, j, 1);
                        }
                    }
                    Log("پاکسازی انجام شد. نامزدهای خلاف جهت در لیست باقی ماندند (در صورت وجود).");
                    
                    return; 
                }
                else
                {
                    m_potential_signals[i].grace_candle_count++;
                    if (m_symbol == _Symbol && m_visual_manager != NULL)
                        m_visual_manager.DrawScanningArea(m_potential_signals[i].is_buy, m_settings.chikou_period, m_potential_signals[i].grace_candle_count, m_settings.ichimoku_timeframe);
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| منطق فاز ۱: چک کردن کراس سه گانه                               |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckTripleCross(bool& is_buy)
{
    int shift = m_settings.chikou_period;
    if (iBars(m_symbol, m_settings.ichimoku_timeframe) < shift + 2) return false;

    double tk_shifted[], ks_shifted[];
    if(CopyBuffer(m_ichimoku_handle, 0, shift, 2, tk_shifted) < 2 || 
       CopyBuffer(m_ichimoku_handle, 1, shift, 2, ks_shifted) < 2)
    {
       return false;
    }
       
    double tenkan_at_shift = tk_shifted[0];
    double kijun_at_shift = ks_shifted[0];
    double tenkan_prev_shift = tk_shifted[1];
    double kijun_prev_shift = ks_shifted[1];

    bool is_cross_up = tenkan_prev_shift < kijun_prev_shift && tenkan_at_shift > kijun_at_shift;
    bool is_cross_down = tenkan_prev_shift > kijun_prev_shift && tenkan_at_shift < kijun_at_shift;
    bool is_tk_cross = is_cross_up || is_cross_down;

    double tolerance = GetTalaqiTolerance(shift);
    bool is_confluence = (tolerance > 0) ? (MathAbs(tenkan_at_shift - kijun_at_shift) <= tolerance) : false;

    if (!is_tk_cross && !is_confluence)
    {
        return false;
    }

    double chikou_now = iClose(m_symbol, m_settings.ichimoku_timeframe, 1);
    double chikou_prev = iClose(m_symbol, m_settings.ichimoku_timeframe, 2); 

    double upper_line = MathMax(tenkan_at_shift, kijun_at_shift);
    double lower_line = MathMin(tenkan_at_shift, kijun_at_shift);

    bool chikou_crosses_up = chikou_now > upper_line && chikou_prev < upper_line;
    if (chikou_crosses_up)
    {
        is_buy = true;
        return true; 
    }

    bool chikou_crosses_down = chikou_now < lower_line && chikou_prev > lower_line;
    if (chikou_crosses_down)
    {
        is_buy = false;
        return true; 
    }

    return false;
}

//+------------------------------------------------------------------+
//| منطق فاز ۲: چک کردن تأیید نهایی                                |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckFinalConfirmation(bool is_buy)
{
    if (iBars(m_symbol, m_settings.ichimoku_timeframe) < 2) return false;

    CopyBuffer(m_ichimoku_handle, 0, 1, 1, m_tenkan_buffer);
    CopyBuffer(m_ichimoku_handle, 1, 1, 1, m_kijun_buffer);
    
    double tenkan_at_1 = m_tenkan_buffer[0];
    double kijun_at_1 = m_kijun_buffer[0];
    double open_at_1 = iOpen(m_symbol, m_settings.ichimoku_timeframe, 1);
    double close_at_1 = iClose(m_symbol, m_settings.ichimoku_timeframe, 1);
    
    if (is_buy)
    {
        if (tenkan_at_1 <= kijun_at_1) return false;
        
        if (m_settings.confirmation_type == MODE_OPEN_AND_CLOSE)
        {
            if (open_at_1 > tenkan_at_1 && open_at_1 > kijun_at_1 && 
                close_at_1 > tenkan_at_1 && close_at_1 > kijun_at_1)
            {
                return true;
            }
        }
        else
        {
            if (close_at_1 > tenkan_at_1 && close_at_1 > kijun_at_1)
            {
                return true;
            }
        }
    }
    else
    {
        if (tenkan_at_1 >= kijun_at_1) return false;
        
        if (m_settings.confirmation_type == MODE_OPEN_AND_CLOSE)
        {
            if (open_at_1 < tenkan_at_1 && open_at_1 < kijun_at_1 && 
                close_at_1 < tenkan_at_1 && close_at_1 < kijun_at_1)
            {
                return true;
            }
        }
        else
        {
            if (close_at_1 < tenkan_at_1 && close_at_1 < kijun_at_1)
            {
                return true;
            }
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| محاسبه استاپ لاس                                               |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateStopLoss(bool is_buy, double entry_price)
{
    double sl_price = 0;
    double buffer = m_settings.sl_buffer_multiplier * SymbolInfoDouble(m_symbol, SYMBOL_POINT);

    switch(m_settings.stoploss_type)
    {
        case MODE_COMPLEX:
            sl_price = FindFlatKijun();
            if (sl_price != 0) return(is_buy ? sl_price - buffer : sl_price + buffer);
            
            sl_price = FindPivotKijun(is_buy);
            if (sl_price != 0) return(is_buy ? sl_price - buffer : sl_price + buffer);
            
            sl_price = FindPivotTenkan(is_buy);
            if (sl_price != 0) return(is_buy ? sl_price - buffer : sl_price + buffer);
            
            return FindBackupStopLoss(is_buy, buffer);

        case MODE_SIMPLE:
            return FindBackupStopLoss(is_buy, buffer);

        case MODE_ATR:
            sl_price = CalculateAtrStopLoss(is_buy, entry_price);
            if(sl_price == 0)
            {
                Log("محاسبه ATR SL با خطا مواجه شد. استفاده از روش پشتیبان...");
                return FindBackupStopLoss(is_buy, buffer);
            }
            return sl_price;
    }

    return 0.0;
}

//+------------------------------------------------------------------+
//| تابع استاپ لاس پشتیبان                                         |
//+------------------------------------------------------------------+
double CStrategyManager::FindBackupStopLoss(bool is_buy, double buffer)
{
    int bars_to_check = m_settings.sl_lookback_period;
    if (iBars(m_symbol, m_settings.ichimoku_timeframe) < bars_to_check + 1) return 0;
    
    for (int i = 1; i <= bars_to_check; i++)
    {
        bool is_candle_bullish = (iClose(m_symbol, m_settings.ichimoku_timeframe, i) > iOpen(m_symbol, m_settings.ichimoku_timeframe, i));
        bool is_candle_bearish = (iClose(m_symbol, m_settings.ichimoku_timeframe, i) < iOpen(m_symbol, m_settings.ichimoku_timeframe, i));

        if (is_buy)
        {
            if (is_candle_bearish)
            {
                double sl_price = iLow(m_symbol, m_settings.ichimoku_timeframe, i) - buffer;
                Log("استاپ لاس ساده: اولین کندل نزولی در شیفت " + (string)i + " پیدا شد.");
                return sl_price;
            }
        }
        else
        {
            if (is_candle_bullish)
            {
                double sl_price = iHigh(m_symbol, m_settings.ichimoku_timeframe, i) + buffer;
                Log("استاپ لاس ساده: اولین کندل صعودی در شیفت " + (string)i + " پیدا شد.");
                return sl_price;
            }
        }
    }
    
    Log("هیچ کندل رنگ مخالفی برای استاپ لاس ساده پیدا نشد. از روش سقف/کف مطلق استفاده می‌شود.");
    CopyHigh(m_symbol, m_settings.ichimoku_timeframe, 1, bars_to_check, m_high_buffer);
    CopyLow(m_symbol, m_settings.ichimoku_timeframe, 1, bars_to_check, m_low_buffer);

    if(is_buy)
    {
       int min_index = ArrayMinimum(m_low_buffer, 0, bars_to_check);
       return m_low_buffer[min_index] - buffer;
    }
    else
    {
       int max_index = ArrayMaximum(m_high_buffer, 0, bars_to_check);
       return m_high_buffer[max_index] + buffer;
    }
}

//+------------------------------------------------------------------+
//| تابع لاگ با نمایش تایم‌فریم                                   |
//+------------------------------------------------------------------+
void CStrategyManager::Log(string message)
{
    if (m_settings.enable_logging)
    {
        Print(m_symbol, " [", EnumToString(m_settings.ichimoku_timeframe), "]: ", message);
    }
}

//+------------------------------------------------------------------+
//| شمارش معاملات نماد                                             |
//+------------------------------------------------------------------+
int CStrategyManager::CountSymbolTrades()
{
    int count = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(PositionGetSymbol(i) == m_symbol && PositionGetInteger(POSITION_MAGIC) == (long)m_settings.magic_number)
        {
            count++;
        }
    }
    return count;
}

//+------------------------------------------------------------------+
//| شمارش کل معاملات                                               |
//+------------------------------------------------------------------+
int CStrategyManager::CountTotalTrades()
{
    int count = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        if(PositionGetInteger(POSITION_MAGIC) == (long)m_settings.magic_number)
        {
            count++;
        }
    }
    return count;
}

//+------------------------------------------------------------------+
//| باز کردن معامله                                                |
//+------------------------------------------------------------------+
void CStrategyManager::OpenTrade(bool is_buy)
{
    if(CountTotalTrades() >= m_settings.max_total_trades || CountSymbolTrades() >= m_settings.max_trades_per_symbol)
    {
        Log("رسیدن به حد مجاز معاملات. معامله جدید باز نشد.");
        return;
    }

    double entry_price = is_buy ? SymbolInfoDouble(m_symbol, SYMBOL_ASK) : SymbolInfoDouble(m_symbol, SYMBOL_BID);
    double sl = CalculateStopLoss(is_buy, entry_price);

    if(sl == 0)
    {
        Log("خطا در محاسبه استاپ لاس. معامله باز نشد.");
        return;
    }
    
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double risk_amount = balance * (m_settings.risk_percent_per_trade / 100.0);

    double loss_for_one_lot = 0;
    string base_currency = AccountInfoString(ACCOUNT_CURRENCY);
    if(!OrderCalcProfit(is_buy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL, m_symbol, 1.0, entry_price, sl, loss_for_one_lot))
    {
        Log("خطا در محاسبه سود/زیان با OrderCalcProfit. کد خطا: " + (string)GetLastError());
        return;
    }
    loss_for_one_lot = MathAbs(loss_for_one_lot);

    if(loss_for_one_lot <= 0)
    {
        Log("میزان ضرر محاسبه شده برای ۱ لات معتبر نیست. معامله باز نشد.");
        return;
    }

    double lot_size = NormalizeDouble(risk_amount / loss_for_one_lot, 2);
    double min_lot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MIN);
    double max_lot = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_MAX);
    double lot_step = SymbolInfoDouble(m_symbol, SYMBOL_VOLUME_STEP);
    
    lot_size = MathMax(min_lot, MathMin(max_lot, lot_size));
    lot_size = MathRound(lot_size / lot_step) * lot_step;

    if(lot_size < min_lot)
    {
        Log("حجم محاسبه شده (" + DoubleToString(lot_size,2) + ") کمتر از حداقل لات مجاز (" + DoubleToString(min_lot,2) + ") است. معامله باز نشد.");
        return;
    }

    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT);
    double sl_distance_points = MathAbs(entry_price - sl) / point;
    double tp_distance_points = sl_distance_points * m_settings.take_profit_ratio;
    double tp = is_buy ? entry_price + tp_distance_points * point : entry_price - tp_distance_points * point;
    
    int digits = (int)SymbolInfoInteger(m_symbol, SYMBOL_DIGITS);
    sl = NormalizeDouble(sl, digits);
    tp = NormalizeDouble(tp, digits);
    
    string comment = "Memento " + (is_buy ? "Buy" : "Sell");
    MqlTradeResult result;
    
    if(is_buy)
    {
        m_trade.Buy(lot_size, m_symbol, 0, sl, tp, comment);
    }
    else
    {
        m_trade.Sell(lot_size, m_symbol, 0, sl, tp, comment);
    }
    
    if(m_trade.ResultRetcode() == TRADE_RETCODE_DONE)
    {
        Log("معامله " + comment + " با لات " + DoubleToString(lot_size, 2) + " با موفقیت باز شد.");
    }
    else
    {
        Log("خطا در باز کردن معامله " + comment + ": " + (string)m_trade.ResultRetcode() + " - " + m_trade.ResultComment());
    }
}

//+------------------------------------------------------------------+
//| پیدا کردن سطح کیجون سن فلت                                    |
//+------------------------------------------------------------------+
double CStrategyManager::FindFlatKijun()
{
    double kijun_values[];
    if (CopyBuffer(m_ichimoku_handle, 1, 1, m_settings.flat_kijun_period, kijun_values) < m_settings.flat_kijun_period)
        return 0.0;

    ArraySetAsSeries(kijun_values, true);

    int flat_count = 1;
    for (int i = 1; i < m_settings.flat_kijun_period; i++)
    {
        if (kijun_values[i] == kijun_values[i - 1])
        {
            flat_count++;
            if (flat_count >= m_settings.flat_kijun_min_length)
            {
                return kijun_values[i];
            }
        }
        else
        {
            flat_count = 1;
        }
    }

    return 0.0;
}

//+------------------------------------------------------------------+
//| پیدا کردن پیوت روی کیجون سن                                   |
//+------------------------------------------------------------------+
double CStrategyManager::FindPivotKijun(bool is_buy)
{
    double kijun_values[];
    if (CopyBuffer(m_ichimoku_handle, 1, 1, m_settings.pivot_lookback, kijun_values) < m_settings.pivot_lookback)
        return 0.0;

    ArraySetAsSeries(kijun_values, true);

    for (int i = 1; i < m_settings.pivot_lookback - 1; i++)
    {
        if (is_buy && kijun_values[i] < kijun_values[i - 1] && kijun_values[i] < kijun_values[i + 1])
        {
            return kijun_values[i];
        }
        if (!is_buy && kijun_values[i] > kijun_values[i - 1] && kijun_values[i] > kijun_values[i + 1])
        {
            return kijun_values[i];
        }
    }

    return 0.0;
}

//+------------------------------------------------------------------+
//| پیدا کردن پیوت روی تنکان سن                                   |
//+------------------------------------------------------------------+
double CStrategyManager::FindPivotTenkan(bool is_buy)
{
    double tenkan_values[];
    if (CopyBuffer(m_ichimoku_handle, 0, 1, m_settings.pivot_lookback, tenkan_values) < m_settings.pivot_lookback)
        return 0.0;

    ArraySetAsSeries(tenkan_values, true);

    for (int i = 1; i < m_settings.pivot_lookback - 1; i++)
    {
        if (is_buy && tenkan_values[i] < tenkan_values[i - 1] && tenkan_values[i] < tenkan_values[i + 1])
        {
            return tenkan_values[i];
        }
        if (!is_buy && tenkan_values[i] > tenkan_values[i - 1] && tenkan_values[i] > tenkan_values[i + 1])
        {
            return tenkan_values[i];
        }
    }

    return 0.0;
}

//+------------------------------------------------------------------+
//| محاسبه حد مجاز تلاقی                                           |
//+------------------------------------------------------------------+
double CStrategyManager::GetTalaqiTolerance(int reference_shift)
{
    switch(m_settings.talaqi_calculation_mode)
    {
        case TALAQI_MODE_MANUAL:
            return m_settings.talaqi_distance_in_points * SymbolInfoDouble(m_symbol, SYMBOL_POINT);
        
        case TALAQI_MODE_KUMO:
            return CalculateDynamicTolerance(reference_shift);
        
        case TALAQI_MODE_ATR:
            return CalculateAtrTolerance(reference_shift);
            
        default:
            return 0.0;
    }
}

//+------------------------------------------------------------------+
//| محاسبه حد مجاز تلاقی بر اساس ضخامت ابر کومو                   |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateDynamicTolerance(int reference_shift)
{
    if(m_settings.talaqi_kumo_factor <= 0) return 0.0;

    double senkou_a_buffer[], senkou_b_buffer[];
    if(CopyBuffer(m_ichimoku_handle, 2, reference_shift, 1, senkou_a_buffer) < 1 || 
       CopyBuffer(m_ichimoku_handle, 3, reference_shift, 1, senkou_b_buffer) < 1)
    {
       Log("داده کافی برای محاسبه ضخامت کومو در گذشته وجود ندارد.");
       return 0.0;
    }

    double kumo_thickness = MathAbs(senkou_a_buffer[0] - senkou_b_buffer[0]);
    if(kumo_thickness == 0) return SymbolInfoDouble(m_symbol, SYMBOL_POINT);

    double tolerance = kumo_thickness * m_settings.talaqi_kumo_factor;
    return tolerance;
}

//+------------------------------------------------------------------+
//| اضافه کردن سیگنال جدید به لیست نامزدها                        |
//+------------------------------------------------------------------+
void CStrategyManager::AddOrUpdatePotentialSignal(bool is_buy)
{
    int total = ArraySize(m_potential_signals);
    ArrayResize(m_potential_signals, total + 1);
    
    m_potential_signals[total].time = iTime(m_symbol, m_settings.ichimoku_timeframe, m_settings.chikou_period);
    m_potential_signals[total].is_buy = is_buy;
    m_potential_signals[total].grace_candle_count = 0;
    
    Log("[حالت مسابقه‌ای] سیگنال نامزد جدید " + (is_buy ? "خرید" : "فروش") + " به لیست انتظار مسابقه اضافه شد. تعداد کل نامزدها: " + (string)ArraySize(m_potential_signals));
    
    if(m_symbol == _Symbol && m_visual_manager != NULL)
        m_visual_manager.DrawTripleCrossRectangle(is_buy, m_settings.chikou_period, m_settings.ichimoku_timeframe);
}

//+------------------------------------------------------------------+
//| محاسبه حد مجاز تلاقی بر اساس ATR                               |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateAtrTolerance(int reference_shift)
{
    if(m_settings.talaqi_atr_multiplier <= 0) return 0.0;
    
    if (m_atr_handle == INVALID_HANDLE)
    {
        Log("محاسبه تلورانس ATR ممکن نیست چون هندل آن نامعتبر است.");
        return 0.0;
    }

    double atr_buffer[];
    if(CopyBuffer(m_atr_handle, 0, reference_shift, 1, atr_buffer) < 1)
    {
        Log("داده کافی برای محاسبه ATR در گذشته وجود ندارد.");
        return 0.0;
    }
    
    double tolerance = atr_buffer[0] * m_settings.talaqi_atr_multiplier;
    return tolerance;
}

//+------------------------------------------------------------------+
//| محاسبه حد ضرر ATR                                             |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateAtrStopLoss(bool is_buy, double entry_price)
{
    if (!m_settings.enable_sl_vol_regime)
    {
        if (m_atr_handle == INVALID_HANDLE)
        {
            Log("خطای بحرانی در CalculateAtrStopLoss: هندل ATR نامعتبر است!");
            return 0.0;
        }
        
        double atr_buffer[];
        if(CopyBuffer(m_atr_handle, 0, 1, 1, atr_buffer) < 1)
        {
            Log("داده ATR برای محاسبه حد ضرر ساده موجود نیست.");
            return 0.0;
        }
        
        double atr_value = atr_buffer[0];
        return is_buy ? entry_price - (atr_value * m_settings.sl_atr_multiplier) : entry_price + (atr_value * m_settings.sl_atr_multiplier);
    }

    int history_size = m_settings.sl_vol_regime_ema_period + 5;
    double atr_values[], ema_values[];

    int atr_sl_handle = iATR(m_symbol, m_settings.ichimoku_timeframe, m_settings.sl_vol_regime_atr_period);
    if (atr_sl_handle == INVALID_HANDLE || CopyBuffer(atr_sl_handle, 0, 0, history_size, atr_values) < history_size)
    {
        Log("داده کافی برای محاسبه SL پویا موجود نیست.");
        if(atr_sl_handle != INVALID_HANDLE) 
            IndicatorRelease(atr_sl_handle);
        return 0.0;
    }
    
    IndicatorRelease(atr_sl_handle);
    ArraySetAsSeries(atr_values, true); 

    if(SimpleMAOnBuffer(history_size, 0, m_settings.sl_vol_regime_ema_period, MODE_EMA, atr_values, ema_values) < 1)
    {
         Log("خطا در محاسبه EMA روی ATR.");
         return 0.0;
    }

    double current_atr = atr_values[1]; 
    double ema_atr = ema_values[1];     

    bool is_high_volatility = (current_atr > ema_atr);
    double final_multiplier = is_high_volatility ? m_settings.sl_high_vol_multiplier : m_settings.sl_low_vol_multiplier;

    Log("رژیم نوسان: " + (is_high_volatility ? "بالا" : "پایین") + ". ضریب SL نهایی: " + (string)final_multiplier);

    return is_buy ? entry_price - (current_atr * final_multiplier) : entry_price + (current_atr * final_multiplier);
}

//+------------------------------------------------------------------+
//| گیت کنترل نهایی برای فیلترها                                   |
//+------------------------------------------------------------------+
bool CStrategyManager::AreAllFiltersPassed(bool is_buy)
{
    // فیلتر رژیم بازار در ProcessNewBar چک شده است
    if(m_settings.enable_kumo_filter)
    {
        if(!CheckKumoFilter())
        {
            Log("فیلتر کومو رد شد. قیمت داخل ابر است.");
            return false;
        }
    }

    Log("✅ تمام فیلترهای فعال با موفقیت پاس شدند.");
    return true;
}

//+------------------------------------------------------------------+
//| بررسی فیلتر ابر کومو                                           |
//+------------------------------------------------------------------+
bool CStrategyManager::CheckKumoFilter()
{
    double senkou_a[1], senkou_b[1];
    if(CopyBuffer(m_ichimoku_handle, 2, 0, 1, senkou_a) < 1 || 
       CopyBuffer(m_ichimoku_handle, 3, 0, 1, senkou_b) < 1)
    {
       Log("خطا: داده کافی برای فیلتر کومو موجود نیست.");
       return false;
    }

    double high_kumo = MathMax(senkou_a[0], senkou_b[0]);
    double low_kumo = MathMin(senkou_a[0], senkou_b[0]);
    double close_price = iClose(m_symbol, m_settings.ichimoku_timeframe, 1);

    if(close_price < high_kumo && close_price > low_kumo)
    {
        return false; 
    }

    return true;
}



//###############  FILE: TrailingStopManager.mqh ##############
//

//+------------------------------------------------------------------+
//|                                      Universal Trailing Stop Loss Library |
//|                                      File: TrailingStopManager.mqh |
//|                                      Version: 5.1 (Truly Final) |
//|                                      © 2025, Mohammad & Gemini |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "© 2025, hipoalgoritm"
#property link      "https://www.mql5.com"
#property version   "5.1"
#include <Trade\Trade.mqh>

//================================================================================//
//|                                 --- راهنمای استفاده سریع ---                   |
//|                                                                                |
//| ۱. این فایل را در کنار فایل اکسپرت خود قرار دهید.                                |
//| ۲. در فایل اکسپرت اصلی (.mq5)، این دو خط را به بالای فایل اضافه کنید:             |
//|    #include "TrailingStopManager.mqh"                                          |
//|    CTrailingStopManager TrailingStop;                                          |
//| ۳. در انتهای تابع OnInit اکسپرت خود، این خط را اضافه کنید:                      |
//|    TrailingStop.Init(magic_number);                                           |
//| ۴. در انتهای تابع OnTimer (یا OnTick) اکسپرت خود، این خط را اضافه کنید:          |
//|    TrailingStop.Process();                                                     |
//|                                                                                |
//|                                 **دیگر به هیچ فراخوانی دیگری نیاز نیست!** |
//|                                                                                |
//================================================================================//

//================================================================//
// بخش تنظیمات ورودی (Inputs) - کاملا مستقل و Plug & Play
//================================================================//
input group "---=== 🛡️ Universal Trailing & Breakeven 🛡️ ===---";
input bool Inp_TSL_Enable = true;
input double Inp_TSL_Activation_RR = 1.0;
input bool Inp_BE_Enable = true;
input double Inp_BE_Activation_RR = 1.0;
input double Inp_BE_Plus_Pips = 1.0;
enum E_TSL_Mode { TSL_MODE_TENKAN, TSL_MODE_KIJUN, TSL_MODE_MA, TSL_MODE_ATR, TSL_MODE_PSAR, TSL_MODE_PRICE_CHANNEL, TSL_MODE_CHANDELIER_ATR };
input E_TSL_Mode Inp_TSL_Mode = TSL_MODE_TENKAN;
/*input*/ double Inp_TSL_Buffer_Pips = 3.0;
/*input*/ int Inp_TSL_Ichimoku_Tenkan = 9;
/*input*/ int Inp_TSL_Ichimoku_Kijun = 26;
/*input*/ int Inp_TSL_Ichimoku_Senkou = 52;
/*input*/ int Inp_TSL_MA_Period = 50;
/*input*/ ENUM_MA_METHOD Inp_TSL_MA_Method = MODE_SMA;
/*input*/ ENUM_APPLIED_PRICE Inp_TSL_MA_Price = PRICE_CLOSE;
/*input*/ int Inp_TSL_ATR_Period = 14;
/*input*/ double Inp_TSL_ATR_Multiplier = 2.5;
/*input*/ double Inp_TSL_PSAR_Step = 0.02;
/*input*/ double Inp_TSL_PSAR_Max = 0.2;
/*input*/ int Inp_TSL_PriceChannel_Period = 22;

//+------------------------------------------------------------------+
//| ساختارهای داخلی برای مدیریت بهینه هندل‌ها و وضعیت تریدها          |
//+------------------------------------------------------------------+
struct SIndicatorHandle
{
  string symbol;
  int    handle;
};

struct STradeState
{
  ulong  ticket;
  double open_price;
  double initial_sl;
  bool   be_applied;
};

//+------------------------------------------------------------------+
//| کلاس اصلی مدیریت حد ضرر متحرک                                     |
//+------------------------------------------------------------------+
class CTrailingStopManager
{
private:
  long               m_magic_number;
  bool               m_is_initialized;
  CTrade             m_trade;

  // --- تنظیمات ---
  bool               m_tsl_enabled, m_be_enabled;
  double             m_activation_rr, m_be_activation_rr, m_be_plus_pips;
  E_TSL_Mode         m_tsl_mode;
  double             m_buffer_pips;
  int                m_ichimoku_tenkan, m_ichimoku_kijun, m_ichimoku_senkou;
  int                m_ma_period;
  ENUM_MA_METHOD     m_ma_method;
  ENUM_APPLIED_PRICE m_ma_price;
  int                m_atr_period;
  double             m_atr_multiplier;
  double             m_psar_step, m_psar_max;
  int                m_pricechannel_period;

  // --- مدیریت حالت ---
  STradeState        m_trade_states[];

  // --- مدیریت هندل‌ها ---
  SIndicatorHandle   m_ichimoku_handles[];
  SIndicatorHandle   m_ma_handles[];
  SIndicatorHandle   m_atr_handles[];
  SIndicatorHandle   m_psar_handles[];

  // --- توابع کمکی خصوصی ---
  int    GetIchimokuHandle(string symbol);
  int    GetMaHandle(string symbol);
  int    GetAtrHandle(string symbol);
  int    GetPsarHandle(string symbol);
  void   Log(string message);
  void   ManageSingleTrade(ulong ticket);
  int    FindTradeStateIndex(ulong ticket);
  void   AddTradeState(ulong ticket, double open_price, double initial_sl);
  void   CleanupTradeStates();

  double CalculateIchimokuSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculateMaSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculateAtrSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculatePsarSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculatePriceChannelSL(string symbol, ENUM_POSITION_TYPE type);
  double CalculateChandelierAtrSL(string symbol, ENUM_POSITION_TYPE type);
  void   ManageBreakeven(int state_idx);

public:
  CTrailingStopManager() { m_magic_number = 0; m_is_initialized = false; }
  ~CTrailingStopManager();
  void Init(long magic_number);
  void Process();
};

// --- مخرب کلاس ---
CTrailingStopManager::~CTrailingStopManager()
{
  for(int i = 0; i < ArraySize(m_ichimoku_handles); i++) IndicatorRelease(m_ichimoku_handles[i].handle);
  for(int i = 0; i < ArraySize(m_ma_handles); i++) IndicatorRelease(m_ma_handles[i].handle);
  for(int i = 0; i < ArraySize(m_atr_handles); i++) IndicatorRelease(m_atr_handles[i].handle);
  for(int i = 0; i < ArraySize(m_psar_handles); i++) IndicatorRelease(m_psar_handles[i].handle);
}

// --- تابع مقداردهی اولیه ---
void CTrailingStopManager::Init(long magic_number)
{
  if(m_is_initialized) return;
  m_magic_number = magic_number;
  m_trade.SetExpertMagicNumber(m_magic_number);
  m_trade.SetAsyncMode(true);
  m_tsl_enabled = Inp_TSL_Enable;
  m_activation_rr = Inp_TSL_Activation_RR > 0 ? Inp_TSL_Activation_RR : 1.0;
  m_be_enabled = Inp_BE_Enable;
  m_be_activation_rr = Inp_BE_Activation_RR > 0 ? Inp_BE_Activation_RR : 1.0;
  m_be_plus_pips = Inp_BE_Plus_Pips;
  m_tsl_mode = Inp_TSL_Mode;
  m_buffer_pips = Inp_TSL_Buffer_Pips;
  m_ichimoku_tenkan = Inp_TSL_Ichimoku_Tenkan;
  m_ichimoku_kijun = Inp_TSL_Ichimoku_Kijun;
  m_ichimoku_senkou = Inp_TSL_Ichimoku_Senkou;
  m_ma_period = Inp_TSL_MA_Period;
  m_ma_method = Inp_TSL_MA_Method;
  m_ma_price = Inp_TSL_MA_Price;
  m_atr_period = Inp_TSL_ATR_Period;
  m_atr_multiplier = Inp_TSL_ATR_Multiplier;
  m_psar_step = Inp_TSL_PSAR_Step;
  m_psar_max = Inp_TSL_PSAR_Max;
  m_pricechannel_period = Inp_TSL_PriceChannel_Period;
  if(m_tsl_enabled || m_be_enabled) Log("کتابخانه Universal Trailing/BE با موفقیت برای مجیک نامبر " + (string)m_magic_number + " فعال شد.");
  m_is_initialized = true;
}

// ✅✅✅ تابع اصلی پردازش (منطق کاملاً مستقل) ✅✅✅
void CTrailingStopManager::Process()
{
  if(!m_is_initialized || (!m_tsl_enabled && !m_be_enabled)) return;

  // گام ۱: پوزیشن‌های جدید را به لیست اضافه کن.
  int positions_total = PositionsTotal();
  for(int i = 0; i < positions_total; i++)
  {
      ulong ticket = PositionGetTicket(i);
      if(PositionGetInteger(POSITION_MAGIC) != m_magic_number) continue;

      int state_idx = FindTradeStateIndex(ticket);

      if(state_idx == -1)
      {
          if(PositionSelectByTicket(ticket))
          {
              AddTradeState(ticket, PositionGetDouble(POSITION_PRICE_OPEN), PositionGetDouble(POSITION_SL));
          }
      }
  }

  // ✅✅✅ گام ۲: پاکسازی لیست از پوزیشن‌های بسته شده ✅✅✅
  CleanupTradeStates();

  // گام ۳: منطق تریلینگ و سربه‌سر را برای هر پوزیشن در لیست اجرا کن.
  for(int i = 0; i < ArraySize(m_trade_states); i++)
  {
    ManageSingleTrade(m_trade_states[i].ticket);
  }
}

// ✅✅✅ تابع جدید: پاکسازی حالت‌های ترید ✅✅✅
void CTrailingStopManager::CleanupTradeStates()
{
    for(int i = ArraySize(m_trade_states) - 1; i >= 0; i--)
    {
        ulong ticket = m_trade_states[i].ticket;
        // اگر پوزیشن با این تیکت پیدا نشد یا مجیک نامبرش فرق داشت، یعنی بسته شده.
        if(!PositionSelectByTicket(ticket) || PositionGetInteger(POSITION_MAGIC) != m_magic_number)
        {
            ArrayRemove(m_trade_states, i, 1);
            Log("حالت تیکت " + (string)ticket + " از لیست تریلینگ حذف شد.");
        }
    }
}


// ... بقیه توابع کلاس CTrailingStopManager (بدون تغییر) ...
void CTrailingStopManager::ManageSingleTrade(ulong ticket)
{
    if(!PositionSelectByTicket(ticket)) return;

    int state_idx = FindTradeStateIndex(ticket);
    if (state_idx == -1) return;

    double initial_sl = m_trade_states[state_idx].initial_sl;
    
    if (initial_sl == 0)
    {
        double current_sl_from_position = PositionGetDouble(POSITION_SL);
        if (current_sl_from_position > 0)
        {
            m_trade_states[state_idx].initial_sl = current_sl_from_position;
            initial_sl = current_sl_from_position;
            Log("SL اولیه برای تیکت " + (string)ticket + " با موفقیت به‌روزرسانی شد: " + (string)initial_sl);
        }
        else
        {
            return;
        }
    }
    
    if(m_be_enabled) ManageBreakeven(state_idx);

    if(!m_tsl_enabled) return;

    string symbol = PositionGetString(POSITION_SYMBOL);
    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    double open_price = PositionGetDouble(POSITION_PRICE_OPEN);
    double initial_risk = MathAbs(open_price - initial_sl);
    if(initial_risk == 0) return;

    double required_profit_for_tsl = initial_risk * m_activation_rr;
    double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
    double current_profit = (type == POSITION_TYPE_BUY) ? (current_price - open_price) : (open_price - current_price);
    
    if(current_profit < required_profit_for_tsl) return;
    
    double new_sl_level = 0;
    switch(m_tsl_mode)
    {
    case TSL_MODE_TENKAN:
    case TSL_MODE_KIJUN:
        new_sl_level = CalculateIchimokuSL(symbol, type);
        break;
    case TSL_MODE_MA:
        new_sl_level = CalculateMaSL(symbol, type);
        break;
    case TSL_MODE_ATR:
        new_sl_level = CalculateAtrSL(symbol, type);
        break;
    case TSL_MODE_PSAR:
        new_sl_level = CalculatePsarSL(symbol, type);
        break;
    case TSL_MODE_PRICE_CHANNEL:
        new_sl_level = CalculatePriceChannelSL(symbol, type);
        break;
    case TSL_MODE_CHANDELIER_ATR:
        new_sl_level = CalculateChandelierAtrSL(symbol, type);
        break;
    }
    if(new_sl_level == 0) return;
    
    double final_new_sl = new_sl_level;
    if(m_tsl_mode == TSL_MODE_TENKAN || m_tsl_mode == TSL_MODE_KIJUN || m_tsl_mode == TSL_MODE_MA)
    {
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        double pips_to_points_multiplier = (SymbolInfoInteger(symbol, SYMBOL_DIGITS) == 3 || SymbolInfoInteger(symbol, SYMBOL_DIGITS) == 5) ? 10.0 : 1.0;
        double buffer_points = m_buffer_pips * point * pips_to_points_multiplier;
        if(type == POSITION_TYPE_BUY) final_new_sl -= buffer_points;
        else final_new_sl += buffer_points;
    }
    
    int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
    final_new_sl = NormalizeDouble(final_new_sl, digits);
    double current_sl = PositionGetDouble(POSITION_SL);

    bool should_modify = false;
    if(type == POSITION_TYPE_BUY)
    {
        if(final_new_sl > current_sl && final_new_sl < current_price) should_modify = true;
    }
    else
    {
        if(final_new_sl < current_sl && final_new_sl > current_price) should_modify = true;
    }

    if(should_modify)
    {
        if(m_trade.PositionModify(ticket, final_new_sl, PositionGetDouble(POSITION_TP)))
        {
            Log("تریلینگ استاپ برای تیکت " + (string)ticket + " به قیمت " + DoubleToString(final_new_sl, digits) + " آپدیت شد.");
        }
        else
        {
            Log("خطا در آپدیت تریلینگ استاپ برای تیکت " + (string)ticket + ". کد: " + (string)m_trade.ResultRetcode() + " | " + m_trade.ResultComment());
        }
    }
}
void CTrailingStopManager::ManageBreakeven(int state_idx)
{
    if(m_trade_states[state_idx].be_applied) return;
    ulong ticket = m_trade_states[state_idx].ticket;
    if(!PositionSelectByTicket(ticket)) return;
    string symbol = PositionGetString(POSITION_SYMBOL);
    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

    double initial_sl = m_trade_states[state_idx].initial_sl;
    if(initial_sl == 0) return;
    double open_price = PositionGetDouble(POSITION_PRICE_OPEN);
    double initial_risk = MathAbs(open_price - initial_sl);
    if(initial_risk == 0) return;
    double required_profit_for_be = initial_risk * m_be_activation_rr;
    double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
    double current_profit = (type == POSITION_TYPE_BUY) ? (current_price - open_price) : (open_price - current_price);

    if(current_profit >= required_profit_for_be)
    {
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        double pips_to_points_multiplier = (SymbolInfoInteger(symbol, SYMBOL_DIGITS) == 3 || SymbolInfoInteger(symbol, SYMBOL_DIGITS) == 5) ? 10.0 : 1.0;
        double be_offset = m_be_plus_pips * point * pips_to_points_multiplier;
        double new_sl = (type == POSITION_TYPE_BUY) ? open_price + be_offset : open_price - be_offset;
        int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
        new_sl = NormalizeDouble(new_sl, digits);

        if( (type == POSITION_TYPE_BUY && new_sl > PositionGetDouble(POSITION_SL)) ||
            (type == POSITION_TYPE_SELL && new_sl < PositionGetDouble(POSITION_SL)) )
        {
            if(m_trade.PositionModify(ticket, new_sl, PositionGetDouble(POSITION_TP)))
            {
                Log("معامله تیکت " + (string)ticket + " با موفقیت سربه‌سر (Breakeven) شد.");
                m_trade_states[state_idx].be_applied = true;
            }
        }
    }
}
int CTrailingStopManager::FindTradeStateIndex(ulong ticket)
{
    for(int i = 0; i < ArraySize(m_trade_states); i++)
    {
        if(m_trade_states[i].ticket == ticket) return i;
    }
    return -1;
}
void CTrailingStopManager::AddTradeState(ulong ticket, double open_price, double initial_sl)
{
    int idx = FindTradeStateIndex(ticket);
    if(idx != -1) return;
    
    int new_idx = ArraySize(m_trade_states);
    ArrayResize(m_trade_states, new_idx + 1);
    m_trade_states[new_idx].ticket = ticket;
    m_trade_states[new_idx].open_price = open_price;
    m_trade_states[new_idx].initial_sl = initial_sl;
    m_trade_states[new_idx].be_applied = false;
    Log("حالت جدید برای تیکت " + (string)ticket + " با SL اولیه " + (string)initial_sl + " اضافه شد.");
}
int CTrailingStopManager::GetIchimokuHandle(string symbol)
{
  for(int i=0; i<ArraySize(m_ichimoku_handles); i++) if(m_ichimoku_handles[i].symbol==symbol) return m_ichimoku_handles[i].handle;
  int handle = iIchimoku(symbol, _Period, m_ichimoku_tenkan, m_ichimoku_kijun, m_ichimoku_senkou);
  if(handle!=INVALID_HANDLE){int n=ArraySize(m_ichimoku_handles); ArrayResize(m_ichimoku_handles,n+1); m_ichimoku_handles[n].symbol=symbol; m_ichimoku_handles[n].handle=handle;}
  return handle;
}
int CTrailingStopManager::GetMaHandle(string symbol)
{
  for(int i=0; i<ArraySize(m_ma_handles); i++) if(m_ma_handles[i].symbol==symbol) return m_ma_handles[i].handle;
  int handle = iMA(symbol, _Period, m_ma_period, 0, m_ma_method, m_ma_price);
  if(handle!=INVALID_HANDLE){int n=ArraySize(m_ma_handles); ArrayResize(m_ma_handles,n+1); m_ma_handles[n].symbol=symbol; m_ma_handles[n].handle=handle;}
  return handle;
}
int CTrailingStopManager::GetAtrHandle(string symbol)
{
  for(int i=0; i<ArraySize(m_atr_handles); i++) if(m_atr_handles[i].symbol==symbol) return m_atr_handles[i].handle;
  int handle = iATR(symbol, _Period, m_atr_period);
  if(handle!=INVALID_HANDLE){int n=ArraySize(m_atr_handles); ArrayResize(m_atr_handles,n+1); m_atr_handles[n].symbol=symbol; m_atr_handles[n].handle=handle;}
  return handle;
}
int CTrailingStopManager::GetPsarHandle(string symbol)
{
  for(int i=0; i<ArraySize(m_psar_handles); i++) if(m_psar_handles[i].symbol==symbol) return m_psar_handles[i].handle;
  int handle = iSAR(symbol, _Period, m_psar_step, m_psar_max);
  if(handle!=INVALID_HANDLE){int n=ArraySize(m_psar_handles); ArrayResize(m_psar_handles,n+1); m_psar_handles[n].symbol=symbol; m_psar_handles[n].handle=handle;}
  return handle;
}
void CTrailingStopManager::Log(string message)
{
  if (m_magic_number > 0) Print("TSL Manager [", (string)m_magic_number, "]: ", message);
}
double CTrailingStopManager::CalculateIchimokuSL(string symbol, ENUM_POSITION_TYPE type)
{
  int handle = GetIchimokuHandle(symbol);
  if(handle == INVALID_HANDLE) return 0.0;
  int buffer_idx = (m_tsl_mode == TSL_MODE_TENKAN) ? 0 : 1;
  double values[1];
  if(CopyBuffer(handle, buffer_idx, 1, 1, values) < 1) return 0.0;
  double line_value = values[0];
  double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
  if (type == POSITION_TYPE_BUY && line_value > current_price) return 0.0;
  if (type == POSITION_TYPE_SELL && line_value < current_price) return 0.0;
  return line_value;
}
double CTrailingStopManager::CalculateMaSL(string symbol, ENUM_POSITION_TYPE type)
{
  int handle = GetMaHandle(symbol);
  if(handle == INVALID_HANDLE) return 0.0;
  double values[1];
  if(CopyBuffer(handle, 0, 1, 1, values) < 1) return 0.0;
  double ma_value = values[0];
  double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
  if (type == POSITION_TYPE_BUY && ma_value > current_price) return 0.0;
  if (type == POSITION_TYPE_SELL && ma_value < current_price) return 0.0;
  return ma_value;
}
double CTrailingStopManager::CalculateAtrSL(string symbol, ENUM_POSITION_TYPE type)
{
  int handle = GetAtrHandle(symbol);
  if(handle == INVALID_HANDLE) return 0.0;
  double values[1];
  if(CopyBuffer(handle, 0, 1, 1, values) < 1) return 0.0;
  double atr_offset = values[0] * m_atr_multiplier;
  double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
  if(type == POSITION_TYPE_BUY) return current_price - atr_offset;
  else return current_price + atr_offset;
}
double CTrailingStopManager::CalculatePsarSL(string symbol, ENUM_POSITION_TYPE type)
{
  int handle = GetPsarHandle(symbol);
  if(handle == INVALID_HANDLE) return 0.0;
  double values[1];
  if(CopyBuffer(handle, 0, 1, 1, values) < 1) return 0.0;
  double psar_value = values[0];
  double current_price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
  if (type == POSITION_TYPE_BUY && psar_value > current_price) return 0.0;
  if (type == POSITION_TYPE_SELL && psar_value < current_price) return 0.0;
  return psar_value;
}
double CTrailingStopManager::CalculatePriceChannelSL(string symbol, ENUM_POSITION_TYPE type)
{
  double values[];
  if(type == POSITION_TYPE_BUY)
  {
      if(CopyLow(symbol, _Period, 1, m_pricechannel_period, values) < m_pricechannel_period) return 0.0;
      return values[ArrayMinimum(values, 0, m_pricechannel_period)];
  }
  else
  {
      if(CopyHigh(symbol, _Period, 1, m_pricechannel_period, values) < m_pricechannel_period) return 0.0;
      return values[ArrayMaximum(values, 0, m_pricechannel_period)];
  }
}
double CTrailingStopManager::CalculateChandelierAtrSL(string symbol, ENUM_POSITION_TYPE type)
{
  int atr_handle = GetAtrHandle(symbol);
  if(atr_handle == INVALID_HANDLE) return 0.0;
  double atr_values[1];
  if(CopyBuffer(atr_handle, 0, 1, 1, atr_values) < 1) return 0.0;
  double atr_offset = atr_values[0] * m_atr_multiplier;
  double price_channel_values[];
  if(type == POSITION_TYPE_BUY)
  {
      if(CopyHigh(symbol, _Period, 1, m_pricechannel_period, price_channel_values) < m_pricechannel_period) return 0.0;
      double highest_high = price_channel_values[ArrayMaximum(price_channel_values, 0, m_pricechannel_period)];
      return highest_high - atr_offset;
  }
  else
  {
      if(CopyLow(symbol, _Period, 1, m_pricechannel_period, price_channel_values) < m_pricechannel_period) return 0.0;
      double lowest_low = price_channel_values[ArrayMinimum(price_channel_values, 0, m_pricechannel_period)];
      return lowest_low + atr_offset;
  }
}


//#####$#########  FILE: VisualManager.mqh #####$######### 
//+------------------------------------------------------------------+
//|                                                                  |
//|                    Project: Memento (By HipoAlgorithm)           |
//|                    File: VisualManager.mqh (Graphics Engine)     |
//|                    Version: 3.6 (Polished & Multi-Timeframe)     |
//|                    © 2025, Mohammad & Grok                      |
//|                                                                  |
//+------------------------------------------------------------------+
#property copyright "© 2025, hipoalgoritm"
#property link      "https://www.mql5.com"
#property version   "3.6"

#include "set.mqh"

// ---===== ثابت‌های طراحی =====---
#define DASHBOARD_Y_POS 30      
#define DASHBOARD_X_GAP 10      
#define BOX_WIDTH 95           
#define BOX_HEIGHT 28           
#define SUB_PANEL_HEIGHT 40     
#define MEMENTO_OBJ_PREFIX "MEMENTO_UI_"

// --- ساختارهای داده ---
struct SPanelBox { string MainBoxName, SymbolLabelName, SubPanelName, TradesLabelName, PlLabelName; };
struct SManagedObject { string ObjectName; long CreationBar; ENUM_TIMEFRAMES Timeframe; };
struct SDashboardData { int trades_count; double cumulative_pl; };

//+------------------------------------------------------------------+
//| کلاس مدیریت گرافیک                                               |
//+------------------------------------------------------------------+
class CVisualManager
{
private:
    string              m_symbol;
    SSettings           m_settings;
    SPanelBox           m_panel_boxes[];
    string              m_symbols_list[];
    SManagedObject      m_managed_objects[];
    SDashboardData      m_dashboard_data[];
    
    bool                m_is_barchart_visible;
    string              m_chart_button_name;
    string              m_chart_panel_bg_name;
    string              m_chart_panel_title_name;

    void ShowBarChart(bool show);
    void CreateManagedObject(string obj_name, long creation_bar, ENUM_TIMEFRAMES timeframe);
    
public:
    CVisualManager(string symbol, SSettings &settings);
    ~CVisualManager();

    bool Init();
    void Deinit();
    void InitDashboard();
    void UpdateDashboard();
    
    // تابع رسم مستطیل و فلش کراس اولیه با پشتیبانی از تایم‌فریم
    void DrawTripleCrossRectangle(bool is_buy, int shift, ENUM_TIMEFRAMES timeframe);
    
    // تابع رسم فلش تأییدیه نهایی با پشتیبانی از تایم‌فریم
    void DrawConfirmationArrow(bool is_buy, int shift, ENUM_TIMEFRAMES timeframe);
    
    // تابع رسم ناحیه اسکن متحرک با پشتیبانی از تایم‌فریم
    void DrawScanningArea(bool is_buy, int start_shift, int current_shift, ENUM_TIMEFRAMES timeframe);
    
    void CleanupOldObjects(const int max_age_in_bars, ENUM_TIMEFRAMES timeframe);
    int GetSymbolIndex(string symbol);
    void UpdateDashboardCache(int symbol_index, double deal_profit, double deal_commission, double deal_swap);
    
    void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam);
};

//+------------------------------------------------------------------+
//|                      پیاده‌سازی توابع کلاس                        |
//+------------------------------------------------------------------+
CVisualManager::CVisualManager(string symbol, SSettings &settings)
{
    m_symbol = symbol;
    m_settings = settings;
    m_is_barchart_visible = false;
    m_chart_button_name = MEMENTO_OBJ_PREFIX + "ChartToggleButton";
    m_chart_panel_bg_name = MEMENTO_OBJ_PREFIX + "ChartPanelBg";
    m_chart_panel_title_name = MEMENTO_OBJ_PREFIX + "ChartPanelTitle";
}

CVisualManager::~CVisualManager() { Deinit(); }

bool CVisualManager::Init()
{
    ChartSetInteger(0, CHART_SHIFT, 1);
    ChartSetInteger(0, CHART_SHOW_GRID, false);
    return true;
}

void CVisualManager::Deinit()
{
    ObjectsDeleteAll(0, MEMENTO_OBJ_PREFIX);
    ChartRedraw(0);
}

void CVisualManager::OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
    if(id == CHARTEVENT_OBJECT_CLICK && sparam == m_chart_button_name)
    {
        m_is_barchart_visible = !m_is_barchart_visible;
        ObjectSetInteger(0, m_chart_button_name, OBJPROP_STATE, m_is_barchart_visible);
        ShowBarChart(m_is_barchart_visible);
        UpdateDashboard();
        ChartRedraw(0);
    }
}

void CVisualManager::ShowBarChart(bool show)
{
    ObjectSetInteger(0, m_chart_panel_bg_name, OBJPROP_HIDDEN, !show);
    ObjectSetInteger(0, m_chart_panel_title_name, OBJPROP_HIDDEN, !show);

    for(int i=0; i < ArraySize(m_symbols_list); i++)
    {
        string sym = m_symbols_list[i];
        ObjectSetInteger(0, MEMENTO_OBJ_PREFIX + sym + "_BarRect", OBJPROP_HIDDEN, !show);
        ObjectSetInteger(0, MEMENTO_OBJ_PREFIX + sym + "_BarLabel", OBJPROP_HIDDEN, !show);
    }
}

void CVisualManager::InitDashboard()
{
    if(!m_settings.enable_dashboard) return;
    
    StringSplit(m_settings.symbols_list, ',', m_symbols_list);
    int total_symbols = ArraySize(m_symbols_list);
    if(total_symbols == 0) return;
    
    ArrayResize(m_panel_boxes, total_symbols);
    ArrayResize(m_dashboard_data, total_symbols);
    
    int current_x = DASHBOARD_X_GAP;
    
    color main_bg_color = C'26,30,38';      
    color main_border_color = C'55,65,81';  
    color sub_bg_color = C'17,20,25';       
    color text_color_bright = clrWhite;     
    color text_color_dim = clrSilver;       

    ObjectCreate(0, m_chart_button_name, OBJ_BUTTON, 0, 0, 0);
    ObjectSetInteger(0, m_chart_button_name, OBJPROP_XDISTANCE, current_x);
    ObjectSetInteger(0, m_chart_button_name, OBJPROP_YDISTANCE, DASHBOARD_Y_POS);
    ObjectSetInteger(0, m_chart_button_name, OBJPROP_XSIZE, 25);
    ObjectSetInteger(0, m_chart_button_name, OBJPROP_YSIZE, BOX_HEIGHT);
    ObjectSetString(0, m_chart_button_name, OBJPROP_TEXT, "📈");
    ObjectSetInteger(0, m_chart_button_name, OBJPROP_BGCOLOR, main_bg_color);
    ObjectSetInteger(0, m_chart_button_name, OBJPROP_BORDER_COLOR, main_border_color);
    ObjectSetInteger(0, m_chart_button_name, OBJPROP_FONTSIZE, 12);
    ObjectSetInteger(0, m_chart_button_name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    
    current_x += 25 + DASHBOARD_X_GAP;

    for(int i = 0; i < total_symbols; i++)
    {
        string sym = m_symbols_list[i];
        StringTrimLeft(sym); StringTrimRight(sym);
        
        string base_name = MEMENTO_OBJ_PREFIX + sym;
        m_panel_boxes[i].MainBoxName      = base_name + "_MainBox";
        m_panel_boxes[i].SymbolLabelName  = base_name + "_SymbolLabel";
        m_panel_boxes[i].SubPanelName     = base_name + "_SubPanel";
        m_panel_boxes[i].TradesLabelName  = base_name + "_TradesLabel";
        m_panel_boxes[i].PlLabelName      = base_name + "_PlLabel";

        ObjectCreate(0, m_panel_boxes[i].MainBoxName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, m_panel_boxes[i].MainBoxName, OBJPROP_XDISTANCE, current_x);
        ObjectSetInteger(0, m_panel_boxes[i].MainBoxName, OBJPROP_YDISTANCE, DASHBOARD_Y_POS);
        ObjectSetInteger(0, m_panel_boxes[i].MainBoxName, OBJPROP_XSIZE, BOX_WIDTH);
        ObjectSetInteger(0, m_panel_boxes[i].MainBoxName, OBJPROP_YSIZE, BOX_HEIGHT);
        ObjectSetInteger(0, m_panel_boxes[i].MainBoxName, OBJPROP_COLOR, main_border_color);
        ObjectSetInteger(0, m_panel_boxes[i].MainBoxName, OBJPROP_BGCOLOR, main_bg_color);
        ObjectSetInteger(0, m_panel_boxes[i].MainBoxName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
        ObjectSetInteger(0, m_panel_boxes[i].MainBoxName, OBJPROP_ZORDER, 100);

        ObjectCreate(0, m_panel_boxes[i].SymbolLabelName, OBJ_LABEL, 0, 0, 0);
        ObjectSetString(0, m_panel_boxes[i].SymbolLabelName, OBJPROP_TEXT, sym);
        ObjectSetInteger(0, m_panel_boxes[i].SymbolLabelName, OBJPROP_XDISTANCE, current_x + BOX_WIDTH / 2);
        ObjectSetInteger(0, m_panel_boxes[i].SymbolLabelName, OBJPROP_YDISTANCE, DASHBOARD_Y_POS + BOX_HEIGHT / 2);
        ObjectSetInteger(0, m_panel_boxes[i].SymbolLabelName, OBJPROP_COLOR, text_color_bright);
        ObjectSetString(0, m_panel_boxes[i].SymbolLabelName, OBJPROP_FONT, "Calibri");
        ObjectSetInteger(0, m_panel_boxes[i].SymbolLabelName, OBJPROP_FONTSIZE, 12);
        ObjectSetInteger(0, m_panel_boxes[i].SymbolLabelName, OBJPROP_ANCHOR, ANCHOR_CENTER);
        ObjectSetInteger(0, m_panel_boxes[i].SymbolLabelName, OBJPROP_ZORDER, 101);

        ObjectCreate(0, m_panel_boxes[i].SubPanelName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_XDISTANCE, current_x);
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_YDISTANCE, DASHBOARD_Y_POS + BOX_HEIGHT);
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_XSIZE, BOX_WIDTH);
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_YSIZE, SUB_PANEL_HEIGHT);
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_COLOR, main_border_color);
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_BGCOLOR, sub_bg_color);
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_ZORDER, 99);
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_HIDDEN, true);

        ObjectCreate(0, m_panel_boxes[i].TradesLabelName, OBJ_LABEL, 0, 0, 0);
        ObjectSetString(0, m_panel_boxes[i].TradesLabelName, OBJPROP_TEXT, "Trades: 0");
        ObjectSetInteger(0, m_panel_boxes[i].TradesLabelName, OBJPROP_XDISTANCE, current_x + 5);
        ObjectSetInteger(0, m_panel_boxes[i].TradesLabelName, OBJPROP_YDISTANCE, DASHBOARD_Y_POS + BOX_HEIGHT + 10);
        ObjectSetInteger(0, m_panel_boxes[i].TradesLabelName, OBJPROP_COLOR, text_color_dim);
        ObjectSetString(0, m_panel_boxes[i].TradesLabelName, OBJPROP_FONT, "Calibri");
        ObjectSetInteger(0, m_panel_boxes[i].TradesLabelName, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, m_panel_boxes[i].TradesLabelName, OBJPROP_ANCHOR, ANCHOR_LEFT);
        ObjectSetInteger(0, m_panel_boxes[i].TradesLabelName, OBJPROP_HIDDEN, true);

        ObjectCreate(0, m_panel_boxes[i].PlLabelName, OBJ_LABEL, 0, 0, 0);
        ObjectSetString(0, m_panel_boxes[i].PlLabelName, OBJPROP_TEXT, "P/L: 0.0");
        ObjectSetInteger(0, m_panel_boxes[i].PlLabelName, OBJPROP_XDISTANCE, current_x + 5);
        ObjectSetInteger(0, m_panel_boxes[i].PlLabelName, OBJPROP_YDISTANCE, DASHBOARD_Y_POS + BOX_HEIGHT + 22);
        ObjectSetInteger(0, m_panel_boxes[i].PlLabelName, OBJPROP_COLOR, text_color_dim);
        ObjectSetString(0, m_panel_boxes[i].PlLabelName, OBJPROP_FONT, "Calibri");
        ObjectSetInteger(0, m_panel_boxes[i].PlLabelName, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, m_panel_boxes[i].PlLabelName, OBJPROP_ANCHOR, ANCHOR_LEFT);
        ObjectSetInteger(0, m_panel_boxes[i].PlLabelName, OBJPROP_HIDDEN, true);
        
        current_x += BOX_WIDTH + DASHBOARD_X_GAP;
        
        if(!HistorySelect(0, TimeCurrent())) continue;
        int trades_count = 0;
        double cumulative_pl = 0;
        uint total_deals = HistoryDealsTotal();
        for(uint j = 0; j < total_deals; j++) {
            ulong ticket = HistoryDealGetTicket(j);
            if(HistoryDealGetString(ticket, DEAL_SYMBOL) == sym && HistoryDealGetInteger(ticket, DEAL_MAGIC) == (long)m_settings.magic_number && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT) {
                trades_count++;
                cumulative_pl += HistoryDealGetDouble(ticket, DEAL_PROFIT) + HistoryDealGetDouble(ticket, DEAL_SWAP) + HistoryDealGetDouble(ticket, DEAL_COMMISSION);
            }
        }
        m_dashboard_data[i].trades_count = trades_count;
        m_dashboard_data[i].cumulative_pl = cumulative_pl;
    }
    
    int chart_panel_y = DASHBOARD_Y_POS + BOX_HEIGHT + SUB_PANEL_HEIGHT + 10;
    int chart_panel_width = (BOX_WIDTH + DASHBOARD_X_GAP) * total_symbols + 25;
    int chart_panel_height = 25 + (20 * total_symbols);
    
    ObjectCreate(0, m_chart_panel_bg_name, OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, m_chart_panel_bg_name, OBJPROP_XDISTANCE, DASHBOARD_X_GAP);
    ObjectSetInteger(0, m_chart_panel_bg_name, OBJPROP_YDISTANCE, chart_panel_y);
    ObjectSetInteger(0, m_chart_panel_bg_name, OBJPROP_XSIZE, chart_panel_width);
    ObjectSetInteger(0, m_chart_panel_bg_name, OBJPROP_YSIZE, chart_panel_height);
    ObjectSetInteger(0, m_chart_panel_bg_name, OBJPROP_BGCOLOR, sub_bg_color);
    ObjectSetInteger(0, m_chart_panel_bg_name, OBJPROP_COLOR, main_border_color);
    ObjectSetInteger(0, m_chart_panel_bg_name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    ObjectSetInteger(0, m_chart_panel_bg_name, OBJPROP_ZORDER, 90);

    ObjectCreate(0, m_chart_panel_title_name, OBJ_LABEL, 0, 0, 0);
    ObjectSetString(0, m_chart_panel_title_name, OBJPROP_TEXT, "P/L Distribution");
    ObjectSetInteger(0, m_chart_panel_title_name, OBJPROP_XDISTANCE, DASHBOARD_X_GAP + chart_panel_width/2);
    ObjectSetInteger(0, m_chart_panel_title_name, OBJPROP_YDISTANCE, chart_panel_y + 12);
    ObjectSetInteger(0, m_chart_panel_title_name, OBJPROP_COLOR, text_color_bright);
    ObjectSetString(0, m_chart_panel_title_name, OBJPROP_FONT, "Calibri");
    ObjectSetInteger(0, m_chart_panel_title_name, OBJPROP_FONTSIZE, 12);
    ObjectSetInteger(0, m_chart_panel_title_name, OBJPROP_ANCHOR, ANCHOR_CENTER);
    ObjectSetInteger(0, m_chart_panel_title_name, OBJPROP_ZORDER, 91);
    
    for(int i=0; i < total_symbols; i++) {
        string sym = m_symbols_list[i];
        ObjectCreate(0, MEMENTO_OBJ_PREFIX + sym + "_BarRect", OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectCreate(0, MEMENTO_OBJ_PREFIX + sym + "_BarLabel", OBJ_LABEL, 0, 0, 0);
    }
    ShowBarChart(false);
    ChartRedraw(0);
}

void CVisualManager::UpdateDashboard()
{
    if(!m_settings.enable_dashboard || ArraySize(m_symbols_list) == 0) return;
    
    int total_symbols = ArraySize(m_symbols_list);
    int current_x = DASHBOARD_X_GAP + 25 + DASHBOARD_X_GAP;

    for(int i = 0; i < total_symbols; i++)
    {
        string sym = m_symbols_list[i];
        long magic = (long)m_settings.magic_number;
        color box_color = C'26,30,38';
        color text_color = clrWhite;

        if(PositionSelect(sym) && PositionGetInteger(POSITION_MAGIC) == magic) {
            if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) {
                box_color = m_settings.bullish_color;
                text_color = clrBlack;
            } else if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL) {
                box_color = m_settings.bearish_color;
                text_color = clrWhite;
            }
        }
        ObjectSetInteger(0, m_panel_boxes[i].MainBoxName, OBJPROP_BGCOLOR, box_color);
        ObjectSetInteger(0, m_panel_boxes[i].SymbolLabelName, OBJPROP_COLOR, text_color);
        
        int trades_count = m_dashboard_data[i].trades_count;
        double cumulative_pl = m_dashboard_data[i].cumulative_pl;
        bool show_sub_panel = trades_count > 0;
        ObjectSetInteger(0, m_panel_boxes[i].SubPanelName, OBJPROP_HIDDEN, !show_sub_panel);
        ObjectSetInteger(0, m_panel_boxes[i].TradesLabelName, OBJPROP_HIDDEN, !show_sub_panel);
        ObjectSetInteger(0, m_panel_boxes[i].PlLabelName, OBJPROP_HIDDEN, !show_sub_panel);
        
        if(show_sub_panel) {
            ObjectSetString(0, m_panel_boxes[i].TradesLabelName, OBJPROP_TEXT, "Trades: " + (string)trades_count);
            ObjectSetString(0, m_panel_boxes[i].PlLabelName, OBJPROP_TEXT, "P/L: " + DoubleToString(cumulative_pl, 2));
            ObjectSetInteger(0, m_panel_boxes[i].PlLabelName, OBJPROP_COLOR, cumulative_pl >= 0 ? C'4,180,95' : C'240,82,90');
        }
        current_x += BOX_WIDTH + DASHBOARD_X_GAP;
    }
    
    if(m_is_barchart_visible)
    {
        double max_abs_pl = 0;
        for(int i=0; i < ArraySize(m_dashboard_data); i++)
        {
            if(MathAbs(m_dashboard_data[i].cumulative_pl) > max_abs_pl)
                max_abs_pl = MathAbs(m_dashboard_data[i].cumulative_pl);
        }
        if(max_abs_pl == 0) max_abs_pl = 1;

        int max_bar_width = BOX_WIDTH * 2;
        int current_y = DASHBOARD_Y_POS + BOX_HEIGHT + SUB_PANEL_HEIGHT + 10 + 30;

        for(int i=0; i < total_symbols; i++)
        {
            string sym = m_symbols_list[i];
            double pl = m_dashboard_data[i].cumulative_pl;
            string bar_rect_name = MEMENTO_OBJ_PREFIX + sym + "_BarRect";
            string bar_label_name = MEMENTO_OBJ_PREFIX + sym + "_BarLabel";
            
            int bar_width = (int)((MathAbs(pl) / max_abs_pl) * max_bar_width);
            color bar_color = (pl >= 0) ? C'4,180,95' : C'240,82,90';

            ObjectSetInteger(0, bar_rect_name, OBJPROP_XDISTANCE, DASHBOARD_X_GAP + 70);
            ObjectSetInteger(0, bar_rect_name, OBJPROP_YDISTANCE, current_y);
            ObjectSetInteger(0, bar_rect_name, OBJPROP_XSIZE, bar_width);
            ObjectSetInteger(0, bar_rect_name, OBJPROP_YSIZE, 15);
            ObjectSetInteger(0, bar_rect_name, OBJPROP_BGCOLOR, bar_color);
            ObjectSetInteger(0, bar_rect_name, OBJPROP_COLOR, C'55,65,81');
            ObjectSetInteger(0, bar_rect_name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
            ObjectSetInteger(0, bar_rect_name, OBJPROP_ZORDER, 92);
            
            string label_text = StringFormat("%s : %.2f", sym, pl);
            ObjectSetString(0, bar_label_name, OBJPROP_TEXT, label_text);
            ObjectSetInteger(0, bar_label_name, OBJPROP_XDISTANCE, DASHBOARD_X_GAP + 65);
            ObjectSetInteger(0, bar_label_name, OBJPROP_YDISTANCE, current_y + 8);
            ObjectSetInteger(0, bar_label_name, OBJPROP_COLOR, clrSilver);
            ObjectSetString(0, bar_label_name, OBJPROP_FONT, "Calibri");
            ObjectSetInteger(0, bar_label_name, OBJPROP_FONTSIZE, 9);
            ObjectSetInteger(0, bar_label_name, OBJPROP_ANCHOR, ANCHOR_RIGHT);
            ObjectSetInteger(0, bar_label_name, OBJPROP_ZORDER, 93);
            
            current_y += 20;
        }
    }
    ChartRedraw(0);
}

// تابع رسم مستطیل و فلش کراس اولیه با پشتیبانی از تایم‌فریم
void CVisualManager::DrawTripleCrossRectangle(bool is_buy, int shift, ENUM_TIMEFRAMES timeframe)
{
    string obj_name_rect = MEMENTO_OBJ_PREFIX + m_symbol + "_SignalRect_" + (string)iTime(m_symbol, timeframe, shift);
    string obj_name_arrow = MEMENTO_OBJ_PREFIX + m_symbol + "_SignalArrow_" + (string)iTime(m_symbol, timeframe, shift);
    
    ObjectDelete(0, obj_name_rect);
    ObjectDelete(0, obj_name_arrow);

    datetime time1 = iTime(m_symbol, timeframe, shift + 1);
    datetime time2 = iTime(m_symbol, timeframe, shift);
    double high = iHigh(m_symbol, timeframe, shift); 
    double low = iLow(m_symbol, timeframe, shift);
    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT);
    double buffer = 10 * point * m_settings.object_size_multiplier;
    
    // رسم مستطیل کراس
    if(ObjectCreate(0, obj_name_rect, OBJ_RECTANGLE, 0, time1, low - buffer, time2, high + buffer))
    {
        ObjectSetInteger(0, obj_name_rect, OBJPROP_COLOR, is_buy ? m_settings.bullish_color : m_settings.bearish_color);
        ObjectSetInteger(0, obj_name_rect, OBJPROP_STYLE, STYLE_SOLID); 
        ObjectSetInteger(0, obj_name_rect, OBJPROP_WIDTH, 1); 
        ObjectSetInteger(0, obj_name_rect, OBJPROP_BACK, true);
        ObjectSetInteger(0, obj_name_rect, OBJPROP_FILL, false);
        CreateManagedObject(obj_name_rect, (long)iBars(m_symbol, timeframe), timeframe);
    }
    
    // رسم فلش کراس (shift کندل قبل) با کدهای جدید و فاصله مناسب
    double arrow_offset = 5 * point * m_settings.object_size_multiplier;
    double price = is_buy ? low - arrow_offset : high + arrow_offset;
    uchar code = is_buy ? 211 : 212;
    
    if(ObjectCreate(0, obj_name_arrow, OBJ_ARROW, 0, iTime(m_symbol, timeframe, shift), price))
    {
        ObjectSetInteger(0, obj_name_arrow, OBJPROP_ARROWCODE, code);
        ObjectSetString(0, obj_name_arrow, OBJPROP_FONT, "Wingdings");
        ObjectSetInteger(0, obj_name_arrow, OBJPROP_COLOR, is_buy ? clrGreen : clrRed);
        ObjectSetInteger(0, obj_name_arrow, OBJPROP_WIDTH, (int)(2 * m_settings.object_size_multiplier)); 
        CreateManagedObject(obj_name_arrow, (long)iBars(m_symbol, timeframe), timeframe);
    }
}

// تابع رسم فلش تأییدیه نهایی با پشتیبانی از تایم‌فریم
void CVisualManager::DrawConfirmationArrow(bool is_buy, int shift, ENUM_TIMEFRAMES timeframe)
{
    string obj_name = MEMENTO_OBJ_PREFIX + m_symbol + "_ConfirmArrow_" + (string)iTime(m_symbol, timeframe, shift);
    ObjectDelete(0, obj_name);
    
    double point = SymbolInfoDouble(m_symbol, SYMBOL_POINT);
    double offset = 15 * point * m_settings.object_size_multiplier;
    double price = is_buy ? iLow(m_symbol, timeframe, shift) - offset : iHigh(m_symbol, timeframe, shift) + offset;
    
    // محاسبه فاصله معقول از کندل
    double candle_range = MathAbs(iHigh(m_symbol, timeframe, shift) - iLow(m_symbol, timeframe, shift));
    double final_offset = candle_range * 0.5;
    price = is_buy ? iLow(m_symbol, timeframe, shift) - final_offset : iHigh(m_symbol, timeframe, shift) + final_offset;
    
    uchar code = 181;
    color arrow_color = is_buy ? m_settings.bullish_color : m_settings.bearish_color;

    if(ObjectCreate(0, obj_name, OBJ_ARROW, 0, iTime(m_symbol, timeframe, shift), price))
    {
        ObjectSetInteger(0, obj_name, OBJPROP_ARROWCODE, code);
        ObjectSetString(0, obj_name, OBJPROP_FONT, "Wingdings");
        ObjectSetInteger(0, obj_name, OBJPROP_COLOR, arrow_color);
        ObjectSetInteger(0, obj_name, OBJPROP_WIDTH, (int)(5 * m_settings.object_size_multiplier));
        CreateManagedObject(obj_name, (long)iBars(m_symbol, timeframe), timeframe);
    }
}

// تابع رسم ناحیه اسکن متحرک با پشتیبانی از تایم‌فریم
void CVisualManager::DrawScanningArea(bool is_buy, int start_shift, int current_shift, ENUM_TIMEFRAMES timeframe)
{
    string rect_name = MEMENTO_OBJ_PREFIX + m_symbol + "_ScanningRect";
    
    ObjectDelete(0, rect_name);
    
    if (current_shift < 1 || current_shift > start_shift) return;

    double max_high = 0;
    double min_low = 999999;
    
    MqlRates rates[];
    int bars_to_copy = start_shift - current_shift + 1;
    if(CopyRates(m_symbol, timeframe, current_shift, bars_to_copy, rates) > 0)
    {
        for(int i = 0; i < ArraySize(rates); i++)
        {
            if(rates[i].high > max_high) max_high = rates[i].high;
            if(rates[i].low < min_low) min_low = rates[i].low;
        }
    }

    if(max_high > 0 && min_low < 999999)
    {
        datetime time_start_rect = iTime(m_symbol, timeframe, start_shift);
        datetime time_end_rect = iTime(m_symbol, timeframe, current_shift);
        
        if(ObjectCreate(0, rect_name, OBJ_RECTANGLE, 0, time_start_rect, min_low, time_end_rect, max_high))
        {
            color scan_color = is_buy ? clrLightSkyBlue : clrPaleGoldenrod;
            ObjectSetInteger(0, rect_name, OBJPROP_COLOR, scan_color);
            ObjectSetInteger(0, rect_name, OBJPROP_STYLE, STYLE_SOLID); 
            ObjectSetInteger(0, rect_name, OBJPROP_WIDTH, 1); 
            ObjectSetInteger(0, rect_name, OBJPROP_BACK, true);
            ObjectSetInteger(0, rect_name, OBJPROP_FILL, true);
            ObjectSetInteger(0, rect_name, OBJPROP_SELECTABLE, false);
            CreateManagedObject(rect_name, (long)iBars(m_symbol, timeframe), timeframe);
        }
    }
}

void CVisualManager::CleanupOldObjects(const int max_age_in_bars, ENUM_TIMEFRAMES timeframe)
{
    if (max_age_in_bars <= 0) return;
    long current_bar_count = (long)iBars(m_symbol, timeframe);
    for (int i = ArraySize(m_managed_objects) - 1; i >= 0; i--)
    {
        if (m_managed_objects[i].Timeframe == timeframe && 
            current_bar_count - m_managed_objects[i].CreationBar >= max_age_in_bars)
        {
            ObjectDelete(0, m_managed_objects[i].ObjectName);
            ArrayRemove(m_managed_objects, i, 1);
        }
    }
}

int CVisualManager::GetSymbolIndex(string symbol)
{
    for(int i = 0; i < ArraySize(m_symbols_list); i++)
    {
        if(m_symbols_list[i] == symbol) return i;
    }
    return -1;
}

void CVisualManager::UpdateDashboardCache(int symbol_index, double deal_profit, double deal_commission, double deal_swap)
{
    if(symbol_index >= 0 && symbol_index < ArraySize(m_dashboard_data))
    {
        m_dashboard_data[symbol_index].trades_count++;
        m_dashboard_data[symbol_index].cumulative_pl += deal_profit + deal_commission + deal_swap;
    }
}

void CVisualManager::CreateManagedObject(string obj_name, long creation_bar, ENUM_TIMEFRAMES timeframe)
{
    int total = ArraySize(m_managed_objects);
    ArrayResize(m_managed_objects, total + 1);
    m_managed_objects[total].ObjectName = obj_name;
    m_managed_objects[total].CreationBar = creation_bar;
    m_managed_objects[total].Timeframe = timeframe;
}



//#####$#########  FILE: MarketRegimeDetector.mqh  #####$######### 

/*//+------------------------------------------------------------------+
//|                                       MarketRegimeDetector.mqh    |
//|        Project: ,هذف اصلی پروژه تعین نوع رژیم بازار هست 
//|
//|
//|           
 //|               
              {این کتابخانه به عنوان یک ابزار برای  تشخیص خواهد بود نه یک سیستم که سیکنال نهای را بدهد}
//|         
                © 2025, HipoAlgorithm & mohammad khajavi              |
//|                      Version: 2.2                          |
//+------------------------------------------------------------------+*/


#property copyright "© 2025, HipoAlgorithm & khajavi"
#property link      "https://www.mql5.com"
#property version   "2.2"

//+------------------------------------------------------------------+
//| بخش ۱: تعاریف اولیه (Enums and Structs)                         |
//+------------------------------------------------------------------+

// کامنت فارسی: تعریف حالات مختلف بازار برای شناسایی رژیم‌ها
enum ENUM_MARKET_REGIME
{
    REGIME_STRONG_BULL_TREND,         // روند صعودی قوی
    REGIME_AVERAGE_BULL_TREND,        // روند صعودی متوسط
    REGIME_BULL_TREND_EXHAUSTION,     // خستگی روند صعودی
    REGIME_STRONG_BEAR_TREND,         // روند نزولی قوی
    REGIME_AVERAGE_BEAR_TREND,        // روند نزولی متوسط
    REGIME_BEAR_TREND_EXHAUSTION,     // خستگی روند نزولی
    REGIME_RANGE_CONSOLIDATION,       // بازار رنج (خنثی)
    REGIME_VOLATILITY_SQUEEZE,        // فشردگی نوسانات
    REGIME_PROBABLE_BEARISH_REVERSAL, // بازگشت نزولی احتمالی
    REGIME_PROBABLE_BULLISH_REVERSAL, // بازگشت صعودی احتمالی
    REGIME_BULLISH_BREAKOUT_CONFIRMED, // شروع روند صعودی (شکست تایید شده)
    REGIME_BEARISH_BREAKOUT_CONFIRMED, // شروع روند نزولی (شکست تایید شده)
    REGIME_PROBABLE_FAKEOUT,          // شکست کاذب احتمالی
    REGIME_UNDEFINED                  // حالت نامشخص
};

// کامنت فارسی: ساختار برای نگهداری اطلاعات نقاط چرخش
struct SwingPoint
{
    datetime time;         // زمان کندل
    double   price;        // قیمت High یا Low
    int      bar_index;    // اندیس کندل
};

// کامنت فارسی: ساختار خروجی تحلیل رژیم بازار
struct RegimeResult
{
    ENUM_MARKET_REGIME regime;              // رژیم تشخیص داده شده
    double             confidenceScore;     // امتیاز اطمینان (0.0 تا 1.0)
    string             reasoning;           // توضیح متنی برای دیباگ
    datetime           analysisTime;        // زمان تحلیل
};

// کامنت فارسی: تعریف وضعیت ساختار بازار
enum ENUM_STRUCTURE_STATE
{
    STRUCTURE_UPTREND_BOS,          // روند صعودی با شکست ساختار
    STRUCTURE_DOWNTREND_BOS,        // روند نزولی با شکست ساختار
    STRUCTURE_BEARISH_CHoCH,        // تغییر شخصیت نزولی
    STRUCTURE_BULLISH_CHoCH,        // تغییر شخصیت صعودی
    STRUCTURE_CONSOLIDATION_RANGE,  // بازار رنج
    STRUCTURE_BREAKOUT_FROM_RANGE,  // شکست از رنج
    STRUCTURE_UNDEFINED             // نامشخص
};

// کامنت فارسی: تعریف وضعیت نوسانات بازار
enum ENUM_VOLATILITY_STATE
{
    VOLATILITY_SQUEEZE,     // فشردگی
    VOLATILITY_EXPANSION,   // انبساط
    VOLATILITY_NORMAL       // نرمال
};

// کامنت فارسی: ساختار خروجی ماژول مومنتوم
struct MomentumResult
{
    double score;               // امتیاز مومنتوم (-100 تا +100)
    bool   exhaustion_signal;   // سیگنال خستگی روند
    double hurst_exponent;      // توان هرست
    bool   is_conflicting;      // تضاد بین ADX و Hurst
};

//+------------------------------------------------------------------+
//| بخش ۲: تعریف کلاس‌ها                                            |
//+------------------------------------------------------------------+

// کامنت فارسی: کلاس برای مدیریت لاگ‌ها با قابلیت فعال/غیرفعال
class CLogManager
{
private:
    bool   m_enabled;       // وضعیت فعال بودن لاگ
    string m_symbol;        // نماد برای شناسایی در لاگ
    ENUM_TIMEFRAMES m_period; // تایم‌فریم برای شناسایی در لاگ

public:
    CLogManager() : m_enabled(false), m_symbol(""), m_period(PERIOD_CURRENT) {}
    void Initialize(const string symbol, const ENUM_TIMEFRAMES period, bool enable)
    {
        m_symbol = symbol;
        m_period = period;
        m_enabled = enable;
    }
    void Log(const string message)
    {
        if(m_enabled)
            Print(StringFormat("[MarketRegimeDetector][%s][%s] %s", m_symbol, EnumToString(m_period), message));
    }
};

// کامنت فارسی: کلاس تحلیل ساختار بازار برای شناسایی نقاط چرخش و //+------------------------------------------------------------------+
//| (نسخه کاملاً اصلاح شده با منطق صحیح اندیس‌گذاری)                   |
//+------------------------------------------------------------------+
class CStructureAnalyzer
{
private:
    string             m_symbol;
    ENUM_TIMEFRAMES    m_period;
    int                m_fractal_n;
    double             m_consolidation_factor;
    double             m_fractal_atr_filter_factor;
    int                m_atr_period_consolidation;
    int                m_atr_handle;
    SwingPoint         m_swing_highs[];
    SwingPoint         m_swing_lows[];
    long               m_last_processed_bar_time;
    CLogManager* m_logger;

    // ✅✅✅ تابع بازنویسی شده برای یافتن نقاط چرخش با آرایه سریالی (Series Array) ✅✅✅
    void FindSwingPoints(const MqlRates &rates[], const double &atr_buf[], const int bars_to_check)
    {
        long current_bar_time = (long)rates[0].time;
        if(current_bar_time == m_last_processed_bar_time && ArraySize(m_swing_highs) > 0) return;

        ArrayFree(m_swing_highs);
        ArrayFree(m_swing_lows);

        // حلقه از کندل‌های اخیر به سمت کندل‌های قدیمی‌تر حرکت می‌کند (مناسب برای آرایه سریالی)
        for(int i = m_fractal_n; i < bars_to_check - m_fractal_n; i++)
        {
            bool is_swing_high = true;
            bool is_swing_low = true;

            // چک کردن کندل‌های اطراف برای پیدا کردن فرکتال
            for(int j = 1; j <= m_fractal_n; j++)
            {
                // rates[i] کندل مرکزی است
                // rates[i-j] کندل‌های جدیدتر (به سمت چپ) هستند
                // rates[i+j] کندل‌های قدیمی‌تر (به سمت راست) هستند
                if(rates[i].high <= rates[i-j].high || rates[i].high < rates[i+j].high) // برای سقف، از سقف‌های قدیمی‌تر باید اکیدا بزرگتر باشد
                    is_swing_high = false;
                if(rates[i].low >= rates[i-j].low || rates[i].low > rates[i+j].low) // برای کف، از کف‌های قدیمی‌تر باید اکیدا کوچکتر باشد
                    is_swing_low = false;
            }

            if(is_swing_high)
            {
                SwingPoint sh;
                sh.time = rates[i].time;
                sh.price = rates[i].high;
                sh.bar_index = i; // اندیس سریالی (0 = کندل فعلی)
                int size = ArraySize(m_swing_highs);
                ArrayResize(m_swing_highs, size + 1);
                m_swing_highs[size] = sh;
            }
            if(is_swing_low)
            {
                SwingPoint sl;
                sl.time = rates[i].time;
                sl.price = rates[i].low;
                sl.bar_index = i; // اندیس سریالی
                int size = ArraySize(m_swing_lows);
                ArrayResize(m_swing_lows, size + 1);
                m_swing_lows[size] = sl;
            }
        }
        m_last_processed_bar_time = current_bar_time;
    }

public:
    CStructureAnalyzer() : m_fractal_n(2), m_consolidation_factor(4.0), m_fractal_atr_filter_factor(0.5),
                           m_atr_period_consolidation(50), m_atr_handle(INVALID_HANDLE), m_last_processed_bar_time(0), m_logger(NULL) {}
    ~CStructureAnalyzer() { if(m_atr_handle != INVALID_HANDLE) IndicatorRelease(m_atr_handle); }

    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, CLogManager &logger,
                    const int fractal_n=2, const double consolidation_factor=4.0,
                    const int atr_period_consolidation=50, const double fractal_atr_filter_factor=0.5)
    {
        m_symbol = symbol;
        m_period = period;
        m_fractal_n = fractal_n > 0 ? fractal_n : 2;
        m_consolidation_factor = consolidation_factor;
        m_atr_period_consolidation = atr_period_consolidation;
        m_fractal_atr_filter_factor = fractal_atr_filter_factor;
        m_logger = &logger;
        m_atr_handle = iATR(m_symbol, m_period, m_atr_period_consolidation);
        if(m_atr_handle == INVALID_HANDLE)
        {
            m_logger.Log("خطا: ایجاد هندل ATR ناموفق");
            return false;
        }
        return true;
    }

    int GetAtrHandle() const { return m_atr_handle; }

    // ✅✅✅ تابع بازنویسی شده برای تحلیل ساختار با دسترسی صحیح به نقاط چرخش ✅✅✅
    ENUM_STRUCTURE_STATE Analyze(const MqlRates &rates[], const double &atr_buf[], const int bars_to_process)
    {
        FindSwingPoints(rates, atr_buf, bars_to_process);
        int highs_count = ArraySize(m_swing_highs);
        int lows_count = ArraySize(m_swing_lows);

        if(highs_count < 2 || lows_count < 2) return STRUCTURE_UNDEFINED;

        // چون نقاط از جدید به قدیم پیدا شدند، اندیس 0 جدیدترین و اندیس 1 ماقبل آخر است
        SwingPoint last_h = m_swing_highs[0];
        SwingPoint prev_h = m_swing_highs[1];
        SwingPoint last_l = m_swing_lows[0];
        SwingPoint prev_l = m_swing_lows[1];

        double last_swing_range = MathAbs(last_h.price - last_l.price);
        double atr = atr_buf[1]; // ATR کندل قبلی (بسته شده)
        if(atr > 0 && last_swing_range < m_consolidation_factor * atr)
        {
            return STRUCTURE_CONSOLIDATION_RANGE;
        }

        double current_close = rates[1].close; // قیمت بسته شده کندل قبلی
        bool is_uptrend = (last_h.price > prev_h.price && last_l.price > prev_l.price);
        bool is_downtrend = (last_h.price < prev_h.price && last_l.price < prev_l.price);

        if(is_uptrend)
        {
            if(current_close > last_h.price) return STRUCTURE_UPTREND_BOS;
            if(current_close < last_l.price) return STRUCTURE_BEARISH_CHoCH;
            return STRUCTURE_CONSOLIDATION_RANGE;
        }
        else if(is_downtrend)
        {
            if(current_close < last_l.price) return STRUCTURE_DOWNTREND_BOS;
            if(current_close > last_h.price) return STRUCTURE_BULLISH_CHoCH;
            return STRUCTURE_CONSOLIDATION_RANGE;
        }

        return STRUCTURE_CONSOLIDATION_RANGE;
    }

    int GetSwingHighs(SwingPoint &result_array[]) const
    {
        if(ArraySize(m_swing_highs) > 0) ArrayCopy(result_array, m_swing_highs);
        return ArraySize(m_swing_highs);
    }

    int GetSwingLows(SwingPoint &result_array[]) const
    {
        if(ArraySize(m_swing_lows) > 0) ArrayCopy(result_array, m_swing_lows);
        return ArraySize(m_swing_lows);
    }
};


// کامنت فارسی: کلاس تحلیل مومنتوم و خستگی روند
class CMomentumAnalyzer
{
private:
    string             m_symbol;
    ENUM_TIMEFRAMES    m_period;
    int                m_adx_period;
    int                m_rsi_period;
    int                m_hurst_window;
    double             m_adx_threshold;
    double             m_hurst_threshold;
    int                m_adx_handle;
    int                m_rsi_handle;
    double             m_adx_main_buf[];
    double             m_adx_plus_di_buf[];
    double             m_adx_minus_di_buf[];
    double             m_rsi_buf[];
    CStructureAnalyzer* m_structure_analyzer;
    CLogManager*       m_logger; // هشدار: ریسک Dangling Pointer در صورت مدیریت نادرست چرخه عمر
    double             m_last_hurst;

    // کامنت فارسی: محاسبه آستانه تطبیقی ADX با محدودسازی بازه
    void CalculateAdaptiveAdxThreshold(const double &adx_buf[])
    {
        const int long_window = 500;
        if(ArraySize(adx_buf) < long_window)
        {
            m_adx_threshold = 25.0;
            m_logger.Log("خطا: داده کافی برای محاسبه آستانه ADX موجود نیست");
            return;
        }

        double sum = 0, sum_sq = 0;
        for(int i = 0; i < long_window; i++)
        {
            sum += adx_buf[i];
            sum_sq += adx_buf[i] * adx_buf[i];
        }
        double avg = sum / long_window;
        double variance = (sum_sq / long_window) - (avg * avg);
        double stddev = MathSqrt(variance);
        double calculated_adaptive_threshold = avg + 0.5 * stddev;
        m_adx_threshold = fmax(20.0, fmin(45.0, calculated_adaptive_threshold));
        m_logger.Log(StringFormat("آستانه تطبیقی ADX: %.2f", m_adx_threshold));
    }

    // کامنت فارسی: محاسبه امتیاز ADX
    double CalculateAdxScore()
    {
        double adx_value = m_adx_main_buf[0];
        double plus_di = m_adx_plus_di_buf[0];
        double minus_di = m_adx_minus_di_buf[0];
        double score = 0;
        if(adx_value > m_adx_threshold)
        {
            score = (adx_value - m_adx_threshold) / (75.0 - m_adx_threshold) * 100.0;
            score = MathMin(100, score);
        }
        if(plus_di < minus_di) score *= -1;
        return score;
    }

    // کامنت فارسی: محاسبه شیب ADX برای تشخیص خستگی
    double CalculateAdxSlope()
    {
        return m_adx_main_buf[0] - m_adx_main_buf[2];
    }

    // کامنت فارسی: تشخیص واگرایی RSI با نقاط چرخش
        // ✅✅✅ تابع بازنویسی شده برای تشخیص واگرایی با اندیس‌گذاری ساده شده ✅✅✅
    bool DetectDivergence(const MqlRates &rates[])
    {
        if(m_structure_analyzer == NULL) return false;
        SwingPoint highs[], lows[];
        int highs_count = m_structure_analyzer.GetSwingHighs(highs);
        int lows_count = m_structure_analyzer.GetSwingLows(lows);
        if(highs_count < 2 || lows_count < 2) return false;

        // جدیدترین نقاط چرخش در اندیس 0 و 1 قرار دارند
        SwingPoint h1 = highs[0]; // جدیدترین سقف
        SwingPoint h2 = highs[1]; // سقف ماقبل آخر
        SwingPoint l1 = lows[0];  // جدیدترین کف
        SwingPoint l2 = lows[1];  // کف ماقبل آخر

        // اندیس‌های bar_index الان مستقیم با اندیس آرایه RSI (که سریالی است) مطابقت دارند
        int h1_idx = h1.bar_index;
        int h2_idx = h2.bar_index;
        int l1_idx = l1.bar_index;
        int l2_idx = l2.bar_index;
        
        // اطمینان از اینکه اندیس‌ها در محدوده آرایه RSI هستند
        int max_idx = (int)MathMax(MathMax(h1_idx, h2_idx), MathMax(l1_idx, l2_idx));
        if(max_idx >= ArraySize(m_rsi_buf)) return false;

        // بررسی واگرایی نزولی: سقف بالاتر در قیمت، سقف پایین‌تر در RSI
        if(h1.price > h2.price && m_rsi_buf[h1_idx] < m_rsi_buf[h2_idx]) return true;
        
        // بررسی واگرایی صعودی: کف پایین‌تر در قیمت، کف بالاتر در RSI
        if(l1.price < l2.price && m_rsi_buf[l1_idx] > m_rsi_buf[l2_idx]) return true;
        
        return false;
    }


    // کامنت فارسی: محاسبه توان Hurst به صورت افزایشی
    double CalculateHurstExponent(const MqlRates &rates[])
    {
        if(ArraySize(rates) < m_hurst_window)
        {
            m_logger.Log("خطا: داده کافی برای محاسبه Hurst موجود نیست");
            return m_last_hurst;
        }

        double log_returns[];
        ArrayResize(log_returns, m_hurst_window - 1, 100);
        for(int i = 0; i < m_hurst_window - 1; i++)
        {
            if(rates[i].close > 0) log_returns[i] = MathLog(rates[i+1].close / rates[i].close);
            else log_returns[i] = 0;
        }

        int n = ArraySize(log_returns);
        if(n < 16) return m_last_hurst;

        double cum_dev = 0, max_dev = 0, min_dev = 0, mean = 0;
        for(int i = 0; i < n; i++) mean += log_returns[i];
        mean /= n;

        double std_dev = 0;
        for(int i = 0; i < n; i++)
        {
            double dev = log_returns[i] - mean;
            cum_dev += dev;
            max_dev = MathMax(max_dev, cum_dev);
            min_dev = MathMin(min_dev, cum_dev);
            std_dev += dev * dev;
        }
        std_dev = MathSqrt(std_dev / n);

        double rs = (max_dev - min_dev) / std_dev;
        if(rs <= 0 || n <= 1) return m_last_hurst;

        m_last_hurst = MathLog(rs) / MathLog(n);
        return m_last_hurst;
    }

public:
    CMomentumAnalyzer() : m_adx_handle(INVALID_HANDLE), m_rsi_handle(INVALID_HANDLE), m_structure_analyzer(NULL),
                          m_adx_threshold(25.0), m_hurst_threshold(0.55), m_logger(NULL), m_last_hurst(0.5) {}
    ~CMomentumAnalyzer()
    {
        if(m_adx_handle != INVALID_HANDLE) IndicatorRelease(m_adx_handle);
        if(m_rsi_handle != INVALID_HANDLE) IndicatorRelease(m_rsi_handle);
    }

    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, CStructureAnalyzer &structure_analyzer, CLogManager &logger,
                    const int adx_period=14, const int rsi_period=14, const int hurst_window=252, const double hurst_threshold=0.55)
    {
        m_symbol = symbol;
        m_period = period;
        m_structure_analyzer = &structure_analyzer;
        m_logger = &logger;
        m_adx_period = adx_period;
        m_rsi_period = rsi_period;
        m_hurst_window = hurst_window;
        m_hurst_threshold = hurst_threshold;

        m_adx_handle = iADX(m_symbol, m_period, m_adx_period);
        if(m_adx_handle == INVALID_HANDLE)
        {
            m_logger.Log("خطا: ایجاد هندل ADX ناموفق");
            return false;
        }

        m_rsi_handle = iRSI(m_symbol, m_period, m_rsi_period, PRICE_CLOSE);
        if(m_rsi_handle == INVALID_HANDLE)
        {
            m_logger.Log("خطا: ایجاد هندل RSI ناموفق");
            return false;
        }

        return true;
    }

    // کامنت فارسی: تحلیل مومنتوم و تشخیص خستگی روند
    MomentumResult Analyze(const MqlRates &rates[], const double &adx_buf[], const double &plus_di_buf[], 
                           const double &minus_di_buf[], const double &rsi_buf[])
    {
        MomentumResult result = {0, false, 0.5, false};

        if(ArraySize(adx_buf) < 3 || ArraySize(plus_di_buf) < 3 || ArraySize(minus_di_buf) < 3)
        {
            m_logger.Log("خطا: داده کافی برای تحلیل ADX موجود نیست");
            return result;
        }

        m_adx_main_buf[0] = adx_buf[0];
        m_adx_main_buf[1] = adx_buf[1];
        m_adx_main_buf[2] = adx_buf[2];
        m_adx_plus_di_buf[0] = plus_di_buf[0];
        m_adx_minus_di_buf[0] = minus_di_buf[0];
        ArrayCopy(m_rsi_buf, rsi_buf);

        CalculateAdaptiveAdxThreshold(adx_buf);
        double adx_score = CalculateAdxScore();
        double hurst = CalculateHurstExponent(rates);
        result.hurst_exponent = hurst;

        double hurst_factor = (hurst - 0.5) * 200.0;
        if(m_adx_plus_di_buf[0] < m_adx_minus_di_buf[0]) hurst_factor *= -1;

        result.score = (adx_score * 0.5) + (hurst_factor * 0.5);
        bool adx_exhaustion = (m_adx_main_buf[0] > 40 && CalculateAdxSlope() < 0);
        bool divergence_found = DetectDivergence(rates);
        result.exhaustion_signal = adx_exhaustion || divergence_found;
        result.is_conflicting = (m_adx_main_buf[0] > m_adx_threshold) != (hurst > 0.55);

        m_logger.Log(StringFormat("مومنتوم: امتیاز=%.2f, خستگی=%s, Hurst=%.2f, تضاد=%s",
                                 result.score, result.exhaustion_signal ? "بله" : "خیر", hurst, result.is_conflicting ? "بله" : "خیر"));
        return result;
    }
};

// کامنت فارسی: کلاس تحلیل نوسانات بازار
class CVolatilityAnalyzer
{
private:
    string             m_symbol;
    ENUM_TIMEFRAMES    m_period;
    int                m_bb_period;
    double             m_bb_deviation;
    int                m_lookback_period;
    int                m_atr_period;
    double             m_squeeze_percentile;
    double             m_expansion_percentile;
    double             m_atr_confirm_factor;
    int                m_bb_handle;
    int                m_atr_handle;
    double             m_bbw_history[];
    CLogManager*       m_logger; // هشدار: ریسک Dangling Pointer در صورت مدیریت نادرست چرخه عمر

public:
    CVolatilityAnalyzer() : m_bb_handle(INVALID_HANDLE), m_atr_handle(INVALID_HANDLE),
                            m_squeeze_percentile(10.0), m_expansion_percentile(90.0), m_atr_confirm_factor(0.8), m_logger(NULL) {}
    ~CVolatilityAnalyzer()
    {
        if(m_bb_handle != INVALID_HANDLE) IndicatorRelease(m_bb_handle);
        if(m_atr_handle != INVALID_HANDLE) IndicatorRelease(m_atr_handle);
    }

    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, CLogManager &logger, const int bb_period=20, const double bb_dev=2.0,
                    const int lookback=252, const int atr_period=14, const double squeeze_percentile=10.0,
                    const double expansion_percentile=90.0, const double atr_confirm_factor=0.8)
    {
        m_symbol = symbol;
        m_period = period;
        m_logger = &logger;
        m_bb_period = bb_period;
        m_bb_deviation = bb_dev;
        m_lookback_period = lookback;
        m_atr_period = atr_period;
        m_squeeze_percentile = squeeze_percentile;
        m_expansion_percentile = expansion_percentile;
        m_atr_confirm_factor = atr_confirm_factor;

        m_bb_handle = iBands(m_symbol, m_period, m_bb_period, 0, m_bb_deviation, PRICE_CLOSE);
        if(m_bb_handle == INVALID_HANDLE)
        {
            m_logger.Log("خطا: ایجاد هندل Bollinger Bands ناموفق");
            return false;
        }

        m_atr_handle = iATR(m_symbol, m_period, m_atr_period);
        if(m_atr_handle == INVALID_HANDLE)
        {
            m_logger.Log("خطا: ایجاد هندل ATR ناموفق");
            return false;
        }
        return true;
    }

    // کامنت فارسی: تحلیل نوسانات با بولینگر و ATR
    ENUM_VOLATILITY_STATE Analyze(const double &upper_buf[], const double &lower_buf[], const double &middle_buf[], const double &atr_buf[])
    {
        if(ArraySize(upper_buf) < m_lookback_period || ArraySize(lower_buf) < m_lookback_period || ArraySize(middle_buf) < m_lookback_period)
        {
            m_logger.Log("خطا: داده کافی برای تحلیل بولینگر موجود نیست");
            return VOLATILITY_NORMAL;
        }

        ArrayResize(m_bbw_history, m_lookback_period, 100);
        for(int i = 0; i < m_lookback_period; i++)
        {
            m_bbw_history[i] = middle_buf[i] > 0 ? (upper_buf[i] - lower_buf[i]) / middle_buf[i] : 0;
        }

        double current_bbw = m_bbw_history[0];
        int count_less = 0;
        for(int i = 1; i < m_lookback_period; i++)
        {
            if(m_bbw_history[i] < current_bbw) count_less++;
        }

        double percentile_rank = (double)count_less / (m_lookback_period - 1) * 100.0;
        if(ArraySize(atr_buf) < m_bb_period + 1)
        {
            m_logger.Log("خطا: داده کافی برای تحلیل ATR موجود نیست");
            return VOLATILITY_NORMAL;
        }

        double sum_atr = 0;
        for(int i = 1; i <= m_bb_period; i++) sum_atr += atr_buf[i];
        double atr_ma = sum_atr / m_bb_period;
        bool atr_confirms_squeeze = (atr_buf[0] < atr_ma * m_atr_confirm_factor);

        if(percentile_rank < m_squeeze_percentile && atr_confirms_squeeze)
        {
            m_logger.Log("نوسانات: فشردگی تشخیص داده شد");
            return VOLATILITY_SQUEEZE;
        }
        if(percentile_rank > m_expansion_percentile)
        {
            m_logger.Log("نوسانات: انبساط تشخیص داده شد");
            return VOLATILITY_EXPANSION;
        }
        m_logger.Log("نوسانات: حالت نرمال");
        return VOLATILITY_NORMAL;
    }
};
//+------------------------------------------------------------------+
//| CBreakoutValidator (نسخه ۲.۲ - بازنویسی کامل)                     |
//+------------------------------------------------------------------+
// کامنت فارسی: کلاس اعتبارسنجی شکست‌ها با تأیید چند تایم‌فریمی
class CBreakoutValidator
{
private:
    string             m_symbol;
    ENUM_TIMEFRAMES    m_period;
    int                m_ema_period_mtf;    // دوره EMA برای تأیید چند تایم‌فریمی
    int                m_rsi_period;
    int                m_ema_handle_mtf;   // هندل EMA برای تایم‌فریم بالاتر
    int                m_rsi_handle;
    double             m_weight_mtf_confirmation; // وزن تأیید چند تایم‌فریمی
    double             m_weight_price_action;
    double             m_weight_momentum;
    double             m_weight_follow_through;
    double             m_body_ratio_high;
    double             m_body_ratio_medium;
    double             m_rsi_cross_level;
    double             m_last_bvs;
    CLogManager* m_logger;

    // کامنت فارسی: محاسبه امتیاز تأیید چند تایم‌فریمی با EMA در تایم‌فریم بالاتر (نسخه امن و بدون ریپینت)
    double GetMtfConfirmationScore(const bool is_bullish, const ENUM_TIMEFRAMES htf_period)
    {
        // بارگذاری داده‌های کندل بسته شده قبلی (شیفت ۱) از تایم‌فریم بالاتر
        MqlRates htf_rates[];
        if(CopyRates(m_symbol, htf_period, 1, 1, htf_rates) < 1)
        {
            m_logger.Log("خطا: داده قیمت برای تایم‌فریم بالاتر موجود نیست");
            return 0;
        }
        
        // بارگذاری داده‌های EMA از کندل بسته شده قبلی (شیفت ۱) از تایم‌فریم بالاتر
        double ema_buf[];
        if(CopyBuffer(m_ema_handle_mtf, 0, 1, 1, ema_buf) < 1)
        {
            m_logger.Log("خطا: داده EMA برای تایم‌فریم بالاتر موجود نیست");
            return 0;
        }
        
        double close_price = htf_rates[0].close;
        double ema_value = ema_buf[0];

        // بررسی تأیید روند در تایم‌فریم بالاتر
        if(is_bullish && close_price > ema_value)
        {
            m_logger.Log("تأیید MTF: شکست صعودی با قیمت بالای EMA در HTF");
            return m_weight_mtf_confirmation;
        }
        if(!is_bullish && close_price < ema_value)
        {
            m_logger.Log("تأیید MTF: شکست نزولی با قیمت پایین EMA در HTF");
            return m_weight_mtf_confirmation;
        }

        m_logger.Log("عدم تأیید MTF: شکست با روند تایم‌فریم بالاتر همخوانی ندارد");
        return 0;
    }
    
    // ... سایر توابع GetPriceActionScore, GetMomentumScore, GetFollowThroughScore بدون تغییر باقی می‌مانند ...
    double GetPriceActionScore(const int index, const bool is_bullish, const MqlRates &rates[])
    {
        if(index >= ArraySize(rates))
        {
            m_logger.Log("خطا: اندیس نامعتبر برای محاسبه پرایس اکشن");
            return 0;
        }

        double range = rates[index].high - rates[index].low;
        if(range == 0) return 0;
        double body = MathAbs(rates[index].close - rates[index].open);
        double body_ratio = body / range;
        double close_pos = is_bullish ? (rates[index].close - rates[index].low) / range : (rates[index].high - rates[index].close) / range;

        if(body_ratio > m_body_ratio_high && close_pos > 0.7) return m_weight_price_action;
        if(body_ratio > m_body_ratio_medium && close_pos > 0.5) return m_weight_price_action * 0.5;
        return 0;
    }
    
    double GetMomentumScore(const int index, const bool is_bullish, const double &rsi_buf[])
    {
        if(index >= ArraySize(rsi_buf))
        {
            m_logger.Log("خطا: اندیس نامعتبر برای محاسبه مومنتوم RSI");
            return 0;
        }

        double rsi = rsi_buf[index];
        if(is_bullish && rsi > m_rsi_cross_level)
            return MathMin(m_weight_momentum, (rsi - m_rsi_cross_level) / (100 - m_rsi_cross_level) * m_weight_momentum);
        if(!is_bullish && rsi < m_rsi_cross_level)
            return MathMin(m_weight_momentum, (m_rsi_cross_level - rsi) / m_rsi_cross_level * m_weight_momentum);
        return 0;
    }

    double GetFollowThroughScore(const int index, const double breakout_level, const bool is_bullish, const MqlRates &rates[])
    {
        if(index >= ArraySize(rates))
        {
            m_logger.Log("خطا: اندیس نامعتبر برای محاسبه Follow-Through");
            return 0;
        }

        if(is_bullish && rates[index].low > breakout_level) return m_weight_follow_through;
        if(!is_bullish && rates[index].high < breakout_level) return m_weight_follow_through;
        return 0;
    }

public:
    CBreakoutValidator() : m_ema_handle_mtf(INVALID_HANDLE), m_rsi_handle(INVALID_HANDLE), m_last_bvs(0),
                           m_ema_period_mtf(50), m_rsi_period(14),
                           m_weight_mtf_confirmation(4.0), m_weight_price_action(3.0), m_weight_momentum(2.0),
                           m_weight_follow_through(1.0), m_body_ratio_high(0.7), m_body_ratio_medium(0.5),
                           m_rsi_cross_level(50.0), m_logger(NULL) {}
    ~CBreakoutValidator()
    {
        if(m_ema_handle_mtf != INVALID_HANDLE) IndicatorRelease(m_ema_handle_mtf);
        if(m_rsi_handle != INVALID_HANDLE) IndicatorRelease(m_rsi_handle);
    }

    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, CLogManager &logger, const int ema_period_mtf=50,
                    const int rsi_period=14, const double weight_mtf_confirmation=4.0,
                    const double weight_price_action=3.0, const double weight_momentum=2.0, const double weight_follow_through=1.0,
                    const double body_ratio_high=0.7, const double body_ratio_medium=0.5, const double rsi_cross_level=50.0)
    {
        m_symbol = symbol;
        m_period = period;
        m_logger = &logger;
        m_ema_period_mtf = ema_period_mtf;
        m_rsi_period = rsi_period;
        m_weight_mtf_confirmation = weight_mtf_confirmation;
        m_weight_price_action = weight_price_action;
        m_weight_momentum = weight_momentum;
        m_weight_follow_through = weight_follow_through;
        m_body_ratio_high = body_ratio_high;
        m_body_ratio_medium = body_ratio_medium;
        m_rsi_cross_level = rsi_cross_level;

        m_rsi_handle = iRSI(m_symbol, m_period, m_rsi_period, PRICE_CLOSE);
        if(m_rsi_handle == INVALID_HANDLE)
        {
            m_logger.Log("خطا: ایجاد هندل RSI برای Breakout ناموفق");
            return false;
        }
        return true;
    }

    bool SetMtfEmaHandle(const ENUM_TIMEFRAMES htf_period)
    {
        if(m_ema_handle_mtf != INVALID_HANDLE) 
            IndicatorRelease(m_ema_handle_mtf);
            
        m_ema_handle_mtf = iMA(m_symbol, htf_period, m_ema_period_mtf, 0, MODE_EMA, PRICE_CLOSE);
        if(m_ema_handle_mtf == INVALID_HANDLE)
        {
            m_logger.Log("خطا: ایجاد هندل EMA برای تایم‌فریم بالاتر ناموفق");
            return false;
        }
        m_logger.Log("هندل EMA برای تایم‌فریم بالاتر با موفقیت تنظیم شد.");
        return true;
    }

    double CalculateBVS(const int breakout_candle_index, const bool is_bullish_breakout, const double breakout_level,
                        const MqlRates &rates[], const double &rsi_buf[], const ENUM_TIMEFRAMES htf_period)
    {
        double score = 0;
        score += GetMtfConfirmationScore(is_bullish_breakout, htf_period);
        score += GetPriceActionScore(breakout_candle_index, is_bullish_breakout, rates);
        score += GetMomentumScore(breakout_candle_index, is_bullish_breakout, rsi_buf);
        score += GetFollowThroughScore(breakout_candle_index - 1, breakout_level, is_bullish_breakout, rates);
        m_last_bvs = MathMin(10.0, score);
        m_logger.Log(StringFormat("BVS محاسبه شد: %.2f", m_last_bvs));
        return m_last_bvs;
    }
};


// کامنت فارسی: کلاس نمایش رژیم بازار روی چارت
class CRegimeVisualizer
{
private:
    string             m_symbol;
    ENUM_TIMEFRAMES    m_period;
    string             m_object_name;
    int                m_offset_x;
    int                m_offset_y;
    int                m_font_size;
    string             m_font_name;
    CLogManager*       m_logger; // هشدار: ریسک Dangling Pointer در صورت مدیریت نادرست چرخه عمر

    // کامنت فارسی: دریافت متن و رنگ رژیم
    void GetRegimeTextAndColor(const ENUM_MARKET_REGIME regime, string &text, color &clr)
    {
        switch(regime)
        {
            case REGIME_STRONG_BULL_TREND:
            case REGIME_AVERAGE_BULL_TREND:
            case REGIME_BULL_TREND_EXHAUSTION:
            case REGIME_PROBABLE_BULLISH_REVERSAL:
            case REGIME_BULLISH_BREAKOUT_CONFIRMED:
                text = EnumToString(regime);
                clr = clrGreen;
                break;
            case REGIME_STRONG_BEAR_TREND:
            case REGIME_AVERAGE_BEAR_TREND:
            case REGIME_BEAR_TREND_EXHAUSTION:
            case REGIME_PROBABLE_BEARISH_REVERSAL:
            case REGIME_BEARISH_BREAKOUT_CONFIRMED:
                text = EnumToString(regime);
                clr = clrRed;
                break;
            case REGIME_RANGE_CONSOLIDATION:
            case REGIME_VOLATILITY_SQUEEZE:
                text = EnumToString(regime);
                clr = clrYellow;
                break;
            case REGIME_PROBABLE_FAKEOUT:
                text = EnumToString(regime);
                clr = clrOrange;
                break;
            case REGIME_UNDEFINED:
                text = "نامشخص";
                clr = clrGray;
                break;
            default:
                text = "نامشخص";
                clr = clrGray;
                break;
        }
    }

public:
    CRegimeVisualizer() : m_object_name("MarketRegimeText"), m_offset_x(20), m_offset_y(20),
                          m_font_size(12), m_font_name("Arial"), m_logger(NULL) {}
    ~CRegimeVisualizer() { ObjectsDeleteAll(0, m_object_name); }

    bool Initialize(const string symbol, const ENUM_TIMEFRAMES period, CLogManager &logger)
    {
        m_symbol = symbol;
        m_period = period;
        m_logger = &logger;
        ObjectsDeleteAll(0, m_object_name);
        return true;
    }

    // کامنت فارسی: به‌روزرسانی نمایش رژیم روی چارت
    void Update(const RegimeResult &result)
    {
        string text;
        color clr;
        GetRegimeTextAndColor(result.regime, text, clr);
        text = StringFormat("%s (اطمینان: %.2f)", text, result.confidenceScore);

        if(ObjectFind(0, m_object_name) < 0)
        {
            ObjectCreate(0, m_object_name, OBJ_LABEL, 0, 0, 0);
            ObjectSetInteger(0, m_object_name, OBJPROP_CORNER, CORNER_RIGHT_UPPER);
            ObjectSetInteger(0, m_object_name, OBJPROP_XDISTANCE, m_offset_x);
            ObjectSetInteger(0, m_object_name, OBJPROP_YDISTANCE, m_offset_y);
            ObjectSetInteger(0, m_object_name, OBJPROP_FONTSIZE, m_font_size);
            ObjectSetString(0, m_object_name, OBJPROP_FONT, m_font_name);
        }

        ObjectSetString(0, m_object_name, OBJPROP_TEXT, text);
        ObjectSetInteger(0, m_object_name, OBJPROP_COLOR, clr);
        ChartRedraw(0);
        m_logger.Log(StringFormat("نمایش رژیم: %s", text));
    }
};

//+------------------------------------------------------------------+
//| CMarketRegimeEngine (نسخه ۲.۲ - نهایی و بازنویسی شده)             |
//+------------------------------------------------------------------+
// کامنت فارسی: کلاس اصلی موتور تشخیص رژیم بازار
class CMarketRegimeEngine
{
private:
    CStructureAnalyzer   m_structure;
    CMomentumAnalyzer    m_momentum;
    CVolatilityAnalyzer  m_volatility;
    CBreakoutValidator   m_breakout;
    CRegimeVisualizer    m_visualizer;
    CLogManager          m_logger;
    bool                 m_is_initialized;
    ENUM_TIMEFRAMES      m_period; // تایم‌فریم تحلیل
    RegimeResult         m_last_result;
    datetime             m_last_analysis_time;
    ENUM_STRUCTURE_STATE m_last_structure_state;
    double               m_last_breakout_level;
    bool                 m_pending_follow_through;
    double               m_momentum_strong_threshold;
    double               m_momentum_average_threshold;
    double               m_bvs_high_prob;
    double               m_bvs_fakeout;
    MqlRates             m_rates_buf[]; // بافر مرکزی برای داده‌های کندل
    double               m_atr_structure_buf[]; // بافر ATR برای ساختار
    double               m_atr_volatility_buf[];
    double               m_adx_main_buf[]; // بافر ADX Main
    double               m_adx_plus_di_buf[]; // بافر ADX +DI
    double               m_adx_minus_di_buf[]; // بافر ADX -DI
    double               m_rsi_buf[]; // بافر RSI
    double               m_bb_upper_buf[]; // بافر باند بالا
    double               m_bb_lower_buf[]; // بافر باند پایین
    double               m_bb_middle_buf[]; // بافر باند میانی
    double               m_structure_weight; // وزن ساختار
    double               m_momentum_weight; // وزن مومنتوم
    double               m_volatility_weight; // وزن نوسانات
    double               m_bvs_weight; // وزن BVS

    // کامنت فارسی: انتخاب هوشمند تایم‌فریم بالاتر برای تأیید چند تایم‌فریمی
    ENUM_TIMEFRAMES GetHigherOrderflowTimeframe(const ENUM_TIMEFRAMES current_period)
    {
        switch(current_period)
        {
            case PERIOD_M1:  return PERIOD_M5;
            case PERIOD_M5:  return PERIOD_M15;
            case PERIOD_M15: return PERIOD_H1;
            case PERIOD_M30: return PERIOD_H4;
            case PERIOD_H1:  return PERIOD_H4;
            case PERIOD_H4:  return PERIOD_D1;
            case PERIOD_D1:  return PERIOD_W1;
            case PERIOD_W1:  return PERIOD_MN1;
            default:         return current_period;
        }
    }

    // کامنت فارسی: تعیین رژیم نهایی با ماتریس تصمیم
    RegimeResult DetermineFinalRegime(const ENUM_STRUCTURE_STATE structure, const MomentumResult momentum,
                                     const ENUM_VOLATILITY_STATE volatility, double bvs)
    {
        RegimeResult result;
        result.analysisTime = TimeCurrent();
        result.confidenceScore = 0;
        result.reasoning = "";
        result.regime = REGIME_UNDEFINED;

        if(momentum.is_conflicting)
        {
            result.regime = REGIME_UNDEFINED;
            result.reasoning = "تضاد سیگنال بین مومنتوم کوتاه‌مدت (ADX) و بلندمدت (Hurst)";
            m_logger.Log(result.reasoning);
            return result;
        }

        if(structure == STRUCTURE_UPTREND_BOS)
        {
            if(momentum.score > m_momentum_strong_threshold && !momentum.exhaustion_signal && volatility == VOLATILITY_EXPANSION)
            {
                result.regime = REGIME_STRONG_BULL_TREND;
                result.reasoning = "روند صعودی قوی: BOS صعودی، مومنتوم بالا، بدون خستگی، انبساط";
            }
            else if(momentum.score > m_momentum_average_threshold && !momentum.exhaustion_signal)
            {
                result.regime = REGIME_AVERAGE_BULL_TREND;
                result.reasoning = "روند صعودی متوسط: BOS صعودی، مومنتوم متوسط، بدون خستگی";
            }
            else
            {
                result.regime = REGIME_BULL_TREND_EXHAUSTION;
                result.reasoning = "خستگی روند صعودی: BOS صعودی اما مومنتوم پایین یا خستگی";
            }
        }
        else if(structure == STRUCTURE_DOWNTREND_BOS)
        {
            if(momentum.score < -m_momentum_strong_threshold && !momentum.exhaustion_signal && volatility == VOLATILITY_EXPANSION)
            {
                result.regime = REGIME_STRONG_BEAR_TREND;
                result.reasoning = "روند نزولی قوی: BOS نزولی، مومنتوم پایین، بدون خستگی، انبساط";
            }
            else if(momentum.score < -m_momentum_average_threshold && !momentum.exhaustion_signal)
            {
                result.regime = REGIME_AVERAGE_BEAR_TREND;
                result.reasoning = "روند نزولی متوسط: BOS نزولی، مومنتوم متوسط، بدون خستگی";
            }
            else
            {
                result.regime = REGIME_BEAR_TREND_EXHAUSTION;
                result.reasoning = "خستگی روند نزولی: BOS نزولی اما مومنتوم بالا یا خستگی";
            }
        }
        else if(structure == STRUCTURE_CONSOLIDATION_RANGE)
        {
            if(MathAbs(momentum.score) < m_momentum_average_threshold)
            {
                if(volatility == VOLATILITY_SQUEEZE)
                {
                    result.regime = REGIME_VOLATILITY_SQUEEZE;
                    result.reasoning = "فشردگی نوسانات: ساختار خنثی، مومنتوم نزدیک صفر، فشردگی";
                }
                else
                {
                    result.regime = REGIME_RANGE_CONSOLIDATION;
                    result.reasoning = "بازار رنج: ساختار خنثی، مومنتوم نزدیک صفر، نوسانات نرمال";
                }
            }
        }
        else if(structure == STRUCTURE_BEARISH_CHoCH)
        {
            if(momentum.score < 0 && momentum.exhaustion_signal && volatility == VOLATILITY_EXPANSION)
            {
                result.regime = REGIME_PROBABLE_BEARISH_REVERSAL;
                result.reasoning = "بازگشت نزولی احتمالی: CHoCH نزولی، مومنتوم در حال کاهش، خستگی، انبساط";
            }
        }
        else if(structure == STRUCTURE_BULLISH_CHoCH)
        {
            if(momentum.score > 0 && momentum.exhaustion_signal && volatility == VOLATILITY_EXPANSION)
            {
                result.regime = REGIME_PROBABLE_BULLISH_REVERSAL;
                result.reasoning = "بازگشت صعودی احتمالی: CHoCH صعودی، مومنتوم در حال افزایش، خستگی، انبساط";
            }
        }

        if(bvs > 0)
        {
            bool is_bullish = momentum.score > 0;
            if(bvs > m_bvs_high_prob && MathAbs(momentum.score) > m_momentum_average_threshold && volatility == VOLATILITY_EXPANSION)
            {
                result.regime = is_bullish ? REGIME_BULLISH_BREAKOUT_CONFIRMED : REGIME_BEARISH_BREAKOUT_CONFIRMED;
                result.reasoning = StringFormat("شروع روند %s (شکست تایید شده): BVS >%.1f، مومنتوم قوی، انبساط",
                                               is_bullish ? "صعودی" : "نزولی", m_bvs_high_prob);
            }
            else if(bvs < m_bvs_fakeout)
            {
                result.regime = REGIME_PROBABLE_FAKEOUT;
                result.reasoning = StringFormat("شکست کاذب احتمالی: BVS <%.1f", m_bvs_fakeout);
            }
        }

        if(result.regime == REGIME_UNDEFINED)
            result.reasoning = "هیچ رژیم واضحی تشخیص داده نشد";

        m_logger.Log(StringFormat("رژیم نهایی: %s, دلیل: %s", EnumToString(result.regime), result.reasoning));
        return result;
    }

    // کامنت فارسی: محاسبه امتیاز اطمینان
    double CalculateConfidenceScore(const ENUM_STRUCTURE_STATE structure, const MomentumResult momentum,
                                   const ENUM_VOLATILITY_STATE volatility, const double bvs)
    {
        double structure_norm = (structure == STRUCTURE_BEARISH_CHoCH || structure == STRUCTURE_BULLISH_CHoCH) ? 0.8 :
                               (structure == STRUCTURE_CONSOLIDATION_RANGE ? 0.7 : 1.0);
        double momentum_norm = MathAbs(momentum.score) / 100.0;
        if(momentum.exhaustion_signal) momentum_norm *= 0.9;
        double volatility_norm = (volatility == VOLATILITY_NORMAL) ? 0.5 : 1.0;
        double bvs_norm = (bvs > 0) ? bvs / 10.0 : 0.0;

        double confidence = (bvs > 0) ? 
                           (m_structure_weight * structure_norm + m_momentum_weight * momentum_norm + m_bvs_weight * bvs_norm) :
                           (m_structure_weight * structure_norm + m_momentum_weight * momentum_norm + m_volatility_weight * volatility_norm);
        return MathMin(1.0, confidence);
    }

public:
    CMarketRegimeEngine() : m_is_initialized(false), m_period(PERIOD_CURRENT), m_last_analysis_time(0),
                            m_last_structure_state(STRUCTURE_UNDEFINED), m_last_breakout_level(0), m_pending_follow_through(false),
                            m_momentum_strong_threshold(70.0), m_momentum_average_threshold(40.0),
                            m_bvs_high_prob(7.0), m_bvs_fakeout(4.0),
                            m_structure_weight(0.4), m_momentum_weight(0.4), m_volatility_weight(0.2), m_bvs_weight(0.2) {}
    
    // کامنت فارسی: راه‌اندازی همه ماژول‌ها با سوئیچ لاگ و تایم‌فریم تحلیل
    bool Initialize(const string symbol, const ENUM_TIMEFRAMES analysis_period, const bool enable_logging,
                    const int fractal_n=2, const double consolidation_factor=4.0, const int atr_period_consolidation=50,
                    const double fractal_atr_filter_factor=0.5, const int adx_period=14, const int rsi_period=14,
                    const int hurst_window=252, const double hurst_threshold=0.55, const int bb_period=20,
                    const double bb_dev=2.0, const int lookback=252, const int atr_period=14,
                    const double squeeze_percentile=10.0, const double expansion_percentile=90.0,
                    const double atr_confirm_factor=0.8, const int ema_period_mtf=50,
                    const double weight_mtf_confirmation=4.0, const double weight_price_action=3.0,
                    const double weight_momentum=2.0, const double weight_follow_through=1.0,
                    const double body_ratio_high=0.7, const double body_ratio_medium=0.5,
                    const double rsi_cross_level=50.0, const double momentum_strong_threshold=70.0,
                    const double momentum_average_threshold=40.0, const double bvs_high_prob=7.0,
                    const double bvs_fakeout=4.0, const double structure_weight=0.4,
                    const double momentum_weight=0.4, const double volatility_weight=0.2, const double bvs_weight=0.2)
    {
        m_period = analysis_period;
        m_logger.Initialize(symbol, m_period, enable_logging);
        if(!m_structure.Initialize(symbol, m_period, m_logger, fractal_n, consolidation_factor, atr_period_consolidation, fractal_atr_filter_factor))
            return false;
        if(!m_momentum.Initialize(symbol, m_period, m_structure, m_logger, adx_period, rsi_period, hurst_window, hurst_threshold))
            return false;
        if(!m_volatility.Initialize(symbol, m_period, m_logger, bb_period, bb_dev, lookback, atr_period, squeeze_percentile, expansion_percentile, atr_confirm_factor))
            return false;
        if(!m_breakout.Initialize(symbol, m_period, m_logger, ema_period_mtf, rsi_period, weight_mtf_confirmation,
                                  weight_price_action, weight_momentum, weight_follow_through, body_ratio_high, body_ratio_medium, rsi_cross_level))
            return false;
        if(!m_breakout.SetMtfEmaHandle(GetHigherOrderflowTimeframe(m_period)))
            return false;
        if(!m_visualizer.Initialize(symbol, m_period, m_logger))
            return false;
        m_momentum_strong_threshold = momentum_strong_threshold;
        m_momentum_average_threshold = momentum_average_threshold;
        m_bvs_high_prob = bvs_high_prob;
        m_bvs_fakeout = bvs_fakeout;
        m_structure_weight = structure_weight;
        m_momentum_weight = momentum_weight;
        m_volatility_weight = volatility_weight;
        m_bvs_weight = bvs_weight;
        m_is_initialized = true;
        m_logger.Log("موتور رژیم بازار با موفقیت راه‌اندازی شد");
        return true;
    }

    // کامنت فارسی: پردازش کندل جدید و به‌روزرسانی رژیم
    bool ProcessNewBar()
    {
        if(!m_is_initialized)
        {
            m_logger.Log("خطا: موتور راه‌اندازی نشده است");
            return false;
        }

        datetime current_bar_time = (datetime)SeriesInfoInteger(_Symbol, m_period, SERIES_LASTBAR_DATE);
        if(current_bar_time == m_last_analysis_time) return false;
          
              // بارگذاری داده‌ها به بافرهای مرکزی (نسخه اصلاح شده با اندیس‌گذاری استاندارد)
            const int bars_to_process = 500;
            ArraySetAsSeries(m_rates_buf, true); // ✅ اصلاح: استانداردسازی اندیس‌گذاری
            if(CopyRates(_Symbol, m_period, 0, bars_to_process, m_rates_buf) < bars_to_process)
            {
                m_logger.Log("خطا: داده کافی برای کندل‌ها موجود نیست");
                return false;
            }
            
            ArraySetAsSeries(m_atr_structure_buf, true); // ✅ اصلاح
            if(CopyBuffer(m_structure.GetAtrHandle(), 0, 0, bars_to_process, m_atr_structure_buf) < bars_to_process)
            {
                m_logger.Log("خطا: داده کافی برای ATR ساختار موجود نیست");
                return false;
            }
            
            ArraySetAsSeries(m_atr_volatility_buf, true); // ✅ اصلاح
            if(CopyBuffer(m_volatility.GetAtrHandle(), 0, 0, bars_to_process, m_atr_volatility_buf) < bars_to_process)
            {
                m_logger.Log("خطا: داده کافی برای ATR نوسانات موجود نیست");
                return false;
            }
            
            ArraySetAsSeries(m_adx_main_buf, true); // ✅ اصلاح
            ArraySetAsSeries(m_adx_plus_di_buf, true); // ✅ اصلاح
            ArraySetAsSeries(m_adx_minus_di_buf, true); // ✅ اصلاح
            if(CopyBuffer(m_momentum.GetAdxHandle(), 0, 0, bars_to_process, m_adx_main_buf) < bars_to_process ||
               CopyBuffer(m_momentum.GetAdxHandle(), 1, 0, bars_to_process, m_adx_plus_di_buf) < bars_to_process ||
               CopyBuffer(m_momentum.GetAdxHandle(), 2, 0, bars_to_process, m_adx_minus_di_buf) < bars_to_process)
            {
                m_logger.Log("خطا: داده کافی برای ADX موجود نیست");
                return false;
            }
            
            ArraySetAsSeries(m_rsi_buf, true); // ✅ اصلاح
            if(CopyBuffer(m_breakout.GetRsiHandle(), 0, 0, bars_to_process, m_rsi_buf) < bars_to_process)
            {
                m_logger.Log("خطا: داده کافی برای RSI موجود نیست");
                return false;
            }
            
            ArraySetAsSeries(m_bb_upper_buf, true); // ✅ اصلاح
            ArraySetAsSeries(m_bb_lower_buf, true); // ✅ اصلاح
            ArraySetAsSeries(m_bb_middle_buf, true); // ✅ اصلاح
            if(CopyBuffer(m_volatility.GetBBHandle(), 1, 0, bars_to_process, m_bb_upper_buf) < bars_to_process ||
               CopyBuffer(m_volatility.GetBBHandle(), 2, 0, bars_to_process, m_bb_lower_buf) < bars_to_process ||
               CopyBuffer(m_volatility.GetBBHandle(), 0, 0, bars_to_process, m_bb_middle_buf) < bars_to_process)
            {
                m_logger.Log("خطا: داده کافی برای Bollinger Bands موجود نیست");
                return false;
            }
            
        ENUM_STRUCTURE_STATE structure = m_structure.Analyze(m_rates_buf, m_atr_structure_buf, bars_to_process);
        MomentumResult momentum = m_momentum.Analyze(m_rates_buf, m_adx_main_buf, m_adx_plus_di_buf, m_adx_minus_di_buf, m_rsi_buf);
        ENUM_VOLATILITY_STATE volatility = m_volatility.Analyze(m_bb_upper_buf, m_bb_lower_buf, m_bb_middle_buf, m_atr_volatility_buf);
        double bvs = 0;
        bool is_breakout_event = (m_last_structure_state == STRUCTURE_CONSOLIDATION_RANGE) &&
                                 (structure != STRUCTURE_CONSOLIDATION_RANGE && structure != STRUCTURE_UNDEFINED);

        double breakout_level = 0;
        if(is_breakout_event)
        {
            bool is_bullish = (structure == STRUCTURE_UPTREND_BOS || structure == STRUCTURE_BULLISH_CHoCH);
            SwingPoint swings[];
            if(is_bullish)
            {
                m_structure.GetSwingHighs(swings);
                if(ArraySize(swings) > 0) breakout_level = swings[ArraySize(swings)-1].price;
            }
            else
            {
                m_structure.GetSwingLows(swings); // ✅ اصلاح اشتباه تایپی
                if(ArraySize(swings) > 0) breakout_level = swings[ArraySize(swings)-1].price;
            }
            // ✅ اصلاح: کندل شکست، کندل شماره ۱ (آخرین کندل بسته شده) است
            bvs = m_breakout.CalculateBVS(1, is_bullish, breakout_level, m_rates_buf, m_rsi_buf, GetHigherOrderflowTimeframe(m_period));
            m_last_breakout_level = breakout_level;
            m_pending_follow_through = true;
        }
        else if(m_pending_follow_through)
        {
            bool is_bullish = (m_last_result.regime == REGIME_BULLISH_BREAKOUT_CONFIRMED); // جهت را از نتیجه قبلی میگیریم
            // ✅ اصلاح: کندل تایید، کندل شماره ۱ (آخرین کندل بسته شده) است که در فراخوانی قبلی کندل ۰ بوده
            bvs = m_breakout.CalculateBVS(1, is_bullish, m_last_breakout_level, m_rates_buf, m_rsi_buf, GetHigherOrderflowTimeframe(m_period));
            m_pending_follow_through = false;
        }

        m_last_result = DetermineFinalRegime(structure, momentum, volatility, bvs);
        m_last_result.confidenceScore = CalculateConfidenceScore(structure, momentum, volatility, bvs);
        m_visualizer.Update(m_last_result);
        m_last_analysis_time = current_bar_time;
        m_last_structure_state = structure;
        return true;
    }

    RegimeResult GetLastResult() const { return m_last_result; }
};







#######$$$$$$$$$$$$$$$##########   end    ###########$$$

