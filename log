function 'CStrategyManager::FindFlatKijun' must have a body	IchimokuLogic.mqh	80	12
ایول! اینم از اون ارورهای خوب و واضحه که دقیقاً میگه مشکل چیه.
معنی ارور چیه؟
کامپایلر خیلی رک و راست داره بهت میگه: "رفیق، تو توی تعریف کلاس CStrategyManager (همون بالای فایل IchimokuLogic.mqh) قول دادی که یه تابعی به اسم FindFlatKijun وجود داره، ولی من کل کد رو گشتم و بدنه (body) یا همون کد اصلی این تابع رو پیدا نکردم که ببینم قراره چیکار کنه!"
اگه دقت کنی، تو سه تا تابع رو برای محاسبه استاپ لاس پیچیده تعریف کردی ولی براشون کدی ننوشتی:
 * FindFlatKijun()
 * FindPivotKijun(bool is_buy)
 * FindPivotTenkan(bool is_buy)
وقتی CalculateStopLoss رو صدا می‌زنی، اونم میاد این سه تا تابع رو صدا بزنه ولی چون اینا وجود خارجی ندارن، کامپایلر ارور میده.
راه حل چیه؟
باید بدنه‌ی این سه تا تابع رو به فایل IchimokuLogic.mqh اضافه کنیم. من برات منطق استاندارد و معقولی رو برای هر کدوم نوشتم که میتونی ازشون استفاده کنی.
۱. اضافه کردن تنظیمات جدید
برای اینکه این توابع جدید قابل تنظیم باشن، اول باید چندتا پارامتر ورودی جدید به اکسپرتت اضافه کنی.
 * الف) برو به فایل اصلی Memento.mq5 و این چند خط رو به بخش input group "4. Stop Loss Settings" اضافه کن:
   //--- تنظیمات استاپ لاس
input group "4. Stop Loss Settings"
enum E_SL_Mode { MODE_COMPLEX, MODE_SIMPLE };
input E_SL_Mode Inp_StopLoss_Type       = MODE_COMPLEX;     // روش محاسبه استاپ لاس
input int Inp_SL_Lookback_Period  = 15;         // دوره نگاه به عقب برای استاپ لاس ساده
input double Inp_SL_Buffer_Multiplier    = 3.0;      // ضریب بافر استاپ لاس
// --- این سه خط جدید رو اضافه کن ---
input int Inp_Flat_Kijun_Period = 50;         // تعداد کندل برای جستجوی کیجون فلت
input int Inp_Flat_Kijun_Min_Length = 5;      // حداقل طول کیجون فلت
input int Inp_Pivot_Lookback      = 30;         // تعداد کندل برای جستجوی پیوت

 * ب) حالا برو به فایل set.mqh و این سه متغیر جدید رو به struct SSettings اضافه کن:
   struct SSettings
{
    // ... بقیه تنظیماتت
    E_SL_Mode           stoploss_type;
    int                 sl_lookback_period;
    double              sl_buffer_multiplier;

    // --- این سه خط جدید رو اضافه کن ---
    int                 flat_kijun_period;
    int                 flat_kijun_min_length;
    int                 pivot_lookback;

    // ... بقیه تنظیماتت
};

 * ج) یادت نره توی تابع OnInit فایل Memento.mq5 این سه تا متغیر جدید رو هم مقداردهی کنی:
   g_settings.sl_buffer_multiplier         = Inp_SL_Buffer_Multiplier;
// --- این سه خط جدید رو اضافه کن ---
g_settings.flat_kijun_period            = Inp_Flat_Kijun_Period;
g_settings.flat_kijun_min_length        = Inp_Flat_Kijun_Min_Length;
g_settings.pivot_lookback               = Inp_Pivot_Lookback;

g_settings.risk_percent_per_trade       = Inp_Risk_Percent_Per_Trade;

۲. اضافه کردن کد توابع گمشده
حالا این تیکه کد کامل و آماده رو کپی کن و به انتهای فایل IchimokuLogic.mqh، درست قبل از آخرین خط (//+---...) اضافه کن.
//+------------------------------------------------------------------+
//| پیدا کردن سطح کیجون سن فلت (صاف)                                  |
//+------------------------------------------------------------------+
double CStrategyManager::FindFlatKijun()
{
    double kijun_values[];
    if (CopyBuffer(m_ichimoku_handle, 1, 1, m_settings.flat_kijun_period, kijun_values) < m_settings.flat_kijun_period)
        return 0.0;

    ArraySetAsSeries(kijun_values, true);

    int flat_count = 1;
    for (int i = 1; i < m_settings.flat_kijun_period; i++)
    {
        if (kijun_values[i] == kijun_values[i - 1])
        {
            flat_count++;
            if (flat_count >= m_settings.flat_kijun_min_length)
            {
                return kijun_values[i]; // سطح فلت پیدا شد
            }
        }
        else
        {
            flat_count = 1; // ریست کردن شمارنده
        }
    }

    return 0.0; // هیچ سطح فلتی پیدا نشد
}

//+------------------------------------------------------------------+
//| پیدا کردن پیوت (نقطه چرخش) روی کیجون سن                          |
//+------------------------------------------------------------------+
double CStrategyManager::FindPivotKijun(bool is_buy)
{
    double kijun_values[];
    if (CopyBuffer(m_ichimoku_handle, 1, 1, m_settings.pivot_lookback, kijun_values) < m_settings.pivot_lookback)
        return 0.0;

    ArraySetAsSeries(kijun_values, true);

    for (int i = 1; i < m_settings.pivot_lookback - 1; i++)
    {
        // برای معامله خرید، دنبال یک دره (پیوت کف) می‌گردیم
        if (is_buy && kijun_values[i] < kijun_values[i - 1] && kijun_values[i] < kijun_values[i + 1])
        {
            return kijun_values[i];
        }
        // برای معامله فروش، دنبال یک قله (پیوت سقف) می‌گردیم
        if (!is_buy && kijun_values[i] > kijun_values[i - 1] && kijun_values[i] > kijun_values[i + 1])
        {
            return kijun_values[i];
        }
    }

    return 0.0; // هیچ پیوتی پیدا نشد
}

//+------------------------------------------------------------------+
//| پیدا کردن پیوت (نقطه چرخش) روی تنکان سن                          |
//+------------------------------------------------------------------+
double CStrategyManager::FindPivotTenkan(bool is_buy)
{
    double tenkan_values[];
    if (CopyBuffer(m_ichimoku_handle, 0, 1, m_settings.pivot_lookback, tenkan_values) < m_settings.pivot_lookback)
        return 0.0;

    ArraySetAsSeries(tenkan_values, true);

    for (int i = 1; i < m_settings.pivot_lookback - 1; i++)
    {
        // برای معامله خرید، دنبال یک دره (پیوت کف) می‌گردیم
        if (is_buy && tenkan_values[i] < tenkan_values[i - 1] && tenkan_values[i] < tenkan_values[i + 1])
        {
            return tenkan_values[i];
        }
        // برای معامله فروش، دنبال یک قله (پیوت سقف) می‌گردیم
        if (!is_buy && tenkan_values[i] > tenkan_values[i - 1] && tenkan_values[i] > tenkan_values[i + 1])
        {
            return tenkan_values[i];
        }
    }

    return 0.0; // هیچ پیوتی پیدا نشد
}

این سه تا تابع رو که اضافه کنی، دیگه اون بخش محاسبه استاپ لاس پیچیده‌ت کامل میشه و اکسپرت باید بدون هیچ مشکلی کامپایل بشه. برو که داشته باشیم!
