عالیه! فکرت کاملاً درسته و خیلی هم حرفه‌ایه. این کارت باعث میشه کد مثل یه قصر شیک باشه که هر اتاقش کار خودشو می‌کنه و همه چی سر جای خودشه.
دقیقاً همونطور که گفتی، به جای اینکه منطق محاسبه فاصله رو وسط تابع اصلی (CheckTripleCross) شلوغ کنیم، یه تابع تر و تمیز و جدا براش می‌نویسیم. این کار خوانایی کد رو فوق‌العاده بالا میبره.
بزن بریم این تغییر رو با هم پیاده کنیم.
گام اول: تعریف تابع جدید
ما یه تابع جدید به اسم CalculateDynamicTolerance می‌نویسیم که کارش فقط و فقط محاسبه همین "حد مجاز تلاقی" به روش هوشمند خودته. این تابع رو به کلاس CStrategyManager در فایل IchimokuLogic.mqh اضافه می‌کنیم.
این کد کامل تابع جدیده:
(این رو می‌تونی به انتهای فایل IchimokuLogic.mqh اضافه کنی)
//+------------------------------------------------------------------+
//| محاسبه حد مجاز تلاقی به صورت داینامیک بر اساس تاریخچه بازار        |
//+------------------------------------------------------------------+
double CStrategyManager::CalculateDynamicTolerance(int reference_shift)
{
    // --- گام ۱: محاسبه میانگین فاصله تاریخی تنکان و کیجون ---
    double total_distance = 0;
    int lookback = m_settings.talaqi_lookback_period; // خواندن دوره نگاه به عقب از تنظیمات

    if(lookback <= 0) return 0.0; // اگر کاربر دوره را صفر گذاشته بود

    // بافرها رو برای بازه مورد نیاز پر می‌کنیم
    double past_tenkan[];
    double past_kijun[];
    if(CopyBuffer(m_ichimoku_handle, 0, reference_shift, lookback, past_tenkan) < lookback || 
       CopyBuffer(m_ichimoku_handle, 1, reference_shift, lookback, past_kijun) < lookback)
    {
       Log("داده کافی برای محاسبه فاصله تاریخی تلاقی وجود ندارد.");
       return 0.0; // اگر داده کافی نبود، مقدار صفر برمی‌گردانیم
    }
    
    // حلقه برای جمع کردن فاصله‌ها در دوره نگاه به عقب
    for(int i = 0; i < lookback; i++)
    {
        total_distance += MathAbs(past_tenkan[i] - past_kijun[i]);
    }
    
    double average_historical_distance = total_distance / lookback;
    
    // --- گام ۲: محاسبه حد مجاز نهایی بر اساس ضریب ورودی ---
    double tolerance = average_historical_distance * m_settings.talaqi_hist_multiplier;
    
    return tolerance;
}

گام دوم: معرفی تابع جدید به کلاس
حالا باید به کلاس CStrategyManager بگیم که یه همچین تابع جدیدی داریم. پس اسمش رو به لیست توابع private در تعریف کلاس اضافه می‌کنیم.
در بالای فایل IchimokuLogic.mqh، داخل تعریف class CStrategyManager این خط رو اضافه کن:
class CStrategyManager
{
private:
    // ... سایر متغیرها و توابع ...
    
    // --- محاسبه استاپ لاس
    double CalculateStopLoss(bool is_buy, double entry_price);
    double CalculateDynamicTolerance(int reference_shift); // <<-- این خط رو اضافه کن
    double FindFlatKijun();
    // ...
};

گام سوم: استفاده از تابع جدید در منطق اصلی
حالا میریم سراغ تابع CheckTripleCross و به جای اون همه کد شلوغ، فقط تابع جدیدمون رو صدا می‌زنیم. ببین چقدر تمیز و خوانا میشه!
کد فعلی (قبل از تغییر):
// ...
// --- محاسبه فاصله تاریخی تنکان و کیجون ---
double total_distance = 0;
// ... (و کل اون حلقه و محاسبات) ...
bool is_confluence = current_distance <= tolerance;
// ...

کد جدید و نهایی (بعد از تغییر):
bool CStrategyManager::CheckTripleCross(bool& is_buy)
{
    int shift = m_settings.chikou_period;
    if (iBars(m_symbol, _Period) < shift + 2) return false;

    // ... گرفتن مقادیر تنکان و کیجون ...
    double tenkan_at_shift = m_tenkan_buffer[0];
    double kijun_at_shift = m_kijun_buffer[0];

    // --- محاسبه حد مجاز تلاقی فقط با یک خط کد! ---
    double tolerance = CalculateDynamicTolerance(shift);

    // --- مقایسه فاصله فعلی با حد مجاز ---
    double current_distance = MathAbs(tenkan_at_shift - kijun_at_shift);
    bool is_confluence = (tolerance > 0) ? (current_distance <= tolerance) : false;
    
    // ... بقیه کد برای چک کردن سیگنال خرید و فروش ...
    if (tenkan_crossover || (is_confluence && tenkan_at_shift > kijun_at_shift))
    {
       // ...
    }
    // ...
    return false;
}

تمام شد!
اینجوری، تابع CheckTripleCross فقط کار اصلی خودش رو که چک کردن سیگناله انجام میده و اصلاً براش مهم نیست tolerance چطوری حساب شده. فقط تابع CalculateDynamicTolerance رو صدا میزنه و مقدار نهایی رو میگیره.
تمیز، ساده، حرفه‌ای. دقیقاً همون چیزی که می‌خواستی. دمت گرم بابت این پیشنهاد ساختاری عالی!
